{
  "version": 3,
  "sources": ["../../../../node_modules/.bun/better-auth@1.4.10+dff6582bb4965509/node_modules/better-auth/src/utils/url.ts", "../../../../node_modules/.bun/better-auth@1.4.10+dff6582bb4965509/node_modules/better-auth/src/client/fetch-plugins.ts", "../../../../node_modules/.bun/better-auth@1.4.10+dff6582bb4965509/node_modules/better-auth/src/client/parser.ts", "../../../../node_modules/.bun/nanostores@1.1.0/node_modules/nanostores/clean-stores/index.js", "../../../../node_modules/.bun/nanostores@1.1.0/node_modules/nanostores/atom/index.js", "../../../../node_modules/.bun/nanostores@1.1.0/node_modules/nanostores/lifecycle/index.js", "../../../../node_modules/.bun/better-auth@1.4.10+dff6582bb4965509/node_modules/better-auth/src/client/query.ts", "../../../../node_modules/.bun/better-auth@1.4.10+dff6582bb4965509/node_modules/better-auth/src/client/broadcast-channel.ts", "../../../../node_modules/.bun/better-auth@1.4.10+dff6582bb4965509/node_modules/better-auth/src/client/focus-manager.ts", "../../../../node_modules/.bun/better-auth@1.4.10+dff6582bb4965509/node_modules/better-auth/src/client/online-manager.ts", "../../../../node_modules/.bun/better-auth@1.4.10+dff6582bb4965509/node_modules/better-auth/src/client/session-refresh.ts", "../../../../node_modules/.bun/better-auth@1.4.10+dff6582bb4965509/node_modules/better-auth/src/client/session-atom.ts", "../../../../node_modules/.bun/better-auth@1.4.10+dff6582bb4965509/node_modules/better-auth/src/client/config.ts", "../../../../node_modules/.bun/better-auth@1.4.10+dff6582bb4965509/node_modules/better-auth/src/utils/is-atom.ts", "../../../../node_modules/.bun/better-auth@1.4.10+dff6582bb4965509/node_modules/better-auth/src/client/proxy.ts"],
  "sourcesContent": ["import { env } from \"@better-auth/core/env\";\nimport { BetterAuthError } from \"@better-auth/core/error\";\n\nfunction checkHasPath(url: string): boolean {\n\ttry {\n\t\tconst parsedUrl = new URL(url);\n\t\tconst pathname = parsedUrl.pathname.replace(/\\/+$/, \"\") || \"/\";\n\t\treturn pathname !== \"/\";\n\t} catch {\n\t\tthrow new BetterAuthError(\n\t\t\t`Invalid base URL: ${url}. Please provide a valid base URL.`,\n\t\t);\n\t}\n}\n\nfunction assertHasProtocol(url: string): void {\n\ttry {\n\t\tconst parsedUrl = new URL(url);\n\t\tif (parsedUrl.protocol !== \"http:\" && parsedUrl.protocol !== \"https:\") {\n\t\t\tthrow new BetterAuthError(\n\t\t\t\t`Invalid base URL: ${url}. URL must include 'http://' or 'https://'`,\n\t\t\t);\n\t\t}\n\t} catch (error) {\n\t\tif (error instanceof BetterAuthError) {\n\t\t\tthrow error;\n\t\t}\n\t\tthrow new BetterAuthError(\n\t\t\t`Invalid base URL: ${url}. Please provide a valid base URL.`,\n\t\t\tString(error),\n\t\t);\n\t}\n}\n\nfunction withPath(url: string, path = \"/api/auth\") {\n\tassertHasProtocol(url);\n\n\tconst hasPath = checkHasPath(url);\n\tif (hasPath) {\n\t\treturn url;\n\t}\n\n\tconst trimmedUrl = url.replace(/\\/+$/, \"\");\n\n\tif (!path || path === \"/\") {\n\t\treturn trimmedUrl;\n\t}\n\n\tpath = path.startsWith(\"/\") ? path : `/${path}`;\n\treturn `${trimmedUrl}${path}`;\n}\n\nfunction validateProxyHeader(header: string, type: \"host\" | \"proto\"): boolean {\n\tif (!header || header.trim() === \"\") {\n\t\treturn false;\n\t}\n\n\tif (type === \"proto\") {\n\t\t// Only allow http and https protocols\n\t\treturn header === \"http\" || header === \"https\";\n\t}\n\n\tif (type === \"host\") {\n\t\tconst suspiciousPatterns = [\n\t\t\t/\\.\\./, // Path traversal\n\t\t\t/\\0/, // Null bytes\n\t\t\t/[\\s]/, // Whitespace (except legitimate spaces that should be trimmed)\n\t\t\t/^[.]/, // Starting with dot\n\t\t\t/[<>'\"]/, // HTML/script injection characters\n\t\t\t/javascript:/i, // Protocol injection\n\t\t\t/file:/i, // File protocol\n\t\t\t/data:/i, // Data protocol\n\t\t];\n\n\t\tif (suspiciousPatterns.some((pattern) => pattern.test(header))) {\n\t\t\treturn false;\n\t\t}\n\n\t\t// Basic hostname validation (allows localhost, IPs, and domains with ports)\n\t\t// This is a simple check, not exhaustive RFC validation\n\t\tconst hostnameRegex =\n\t\t\t/^[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(\\.[a-zA-Z0-9]([a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*(:[0-9]{1,5})?$/;\n\n\t\t// Also allow IPv4 addresses\n\t\tconst ipv4Regex = /^(\\d{1,3}\\.){3}\\d{1,3}(:[0-9]{1,5})?$/;\n\n\t\t// Also allow IPv6 addresses in brackets\n\t\tconst ipv6Regex = /^\\[[0-9a-fA-F:]+\\](:[0-9]{1,5})?$/;\n\n\t\t// Allow localhost variations\n\t\tconst localhostRegex = /^localhost(:[0-9]{1,5})?$/i;\n\n\t\treturn (\n\t\t\thostnameRegex.test(header) ||\n\t\t\tipv4Regex.test(header) ||\n\t\t\tipv6Regex.test(header) ||\n\t\t\tlocalhostRegex.test(header)\n\t\t);\n\t}\n\n\treturn false;\n}\n\nexport function getBaseURL(\n\turl?: string,\n\tpath?: string,\n\trequest?: Request,\n\tloadEnv?: boolean,\n\ttrustedProxyHeaders?: boolean | undefined,\n) {\n\tif (url) {\n\t\treturn withPath(url, path);\n\t}\n\n\tif (loadEnv !== false) {\n\t\tconst fromEnv =\n\t\t\tenv.BETTER_AUTH_URL ||\n\t\t\tenv.NEXT_PUBLIC_BETTER_AUTH_URL ||\n\t\t\tenv.PUBLIC_BETTER_AUTH_URL ||\n\t\t\tenv.NUXT_PUBLIC_BETTER_AUTH_URL ||\n\t\t\tenv.NUXT_PUBLIC_AUTH_URL ||\n\t\t\t(env.BASE_URL !== \"/\" ? env.BASE_URL : undefined);\n\n\t\tif (fromEnv) {\n\t\t\treturn withPath(fromEnv, path);\n\t\t}\n\t}\n\n\tconst fromRequest = request?.headers.get(\"x-forwarded-host\");\n\tconst fromRequestProto = request?.headers.get(\"x-forwarded-proto\");\n\tif (fromRequest && fromRequestProto && trustedProxyHeaders) {\n\t\tif (\n\t\t\tvalidateProxyHeader(fromRequestProto, \"proto\") &&\n\t\t\tvalidateProxyHeader(fromRequest, \"host\")\n\t\t) {\n\t\t\ttry {\n\t\t\t\treturn withPath(`${fromRequestProto}://${fromRequest}`, path);\n\t\t\t} catch (_error) {}\n\t\t}\n\t}\n\n\tif (request) {\n\t\tconst url = getOrigin(request.url);\n\t\tif (!url) {\n\t\t\tthrow new BetterAuthError(\n\t\t\t\t\"Could not get origin from request. Please provide a valid base URL.\",\n\t\t\t);\n\t\t}\n\t\treturn withPath(url, path);\n\t}\n\n\tif (typeof window !== \"undefined\" && window.location) {\n\t\treturn withPath(window.location.origin, path);\n\t}\n\treturn undefined;\n}\n\nexport function getOrigin(url: string) {\n\ttry {\n\t\tconst parsedUrl = new URL(url);\n\t\t// For custom URL schemes (like exp://), the origin property returns the string \"null\"\n\t\t// instead of null. We need to handle this case and return null so the fallback logic works.\n\t\treturn parsedUrl.origin === \"null\" ? null : parsedUrl.origin;\n\t} catch {\n\t\treturn null;\n\t}\n}\n\nexport function getProtocol(url: string) {\n\ttry {\n\t\tconst parsedUrl = new URL(url);\n\t\treturn parsedUrl.protocol;\n\t} catch {\n\t\treturn null;\n\t}\n}\n\nexport function getHost(url: string) {\n\ttry {\n\t\tconst parsedUrl = new URL(url);\n\t\treturn parsedUrl.host;\n\t} catch {\n\t\treturn null;\n\t}\n}\n", "import type { BetterFetchPlugin } from \"@better-fetch/fetch\";\n\nexport const redirectPlugin = {\n\tid: \"redirect\",\n\tname: \"Redirect\",\n\thooks: {\n\t\tonSuccess(context) {\n\t\t\tif (context.data?.url && context.data?.redirect) {\n\t\t\t\tif (typeof window !== \"undefined\" && window.location) {\n\t\t\t\t\tif (window.location) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\twindow.location.href = context.data.url;\n\t\t\t\t\t\t} catch {}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t},\n} satisfies BetterFetchPlugin;\n", "const PROTO_POLLUTION_PATTERNS = {\n\tproto:\n\t\t/\"(?:_|\\\\u0{2}5[Ff]){2}(?:p|\\\\u0{2}70)(?:r|\\\\u0{2}72)(?:o|\\\\u0{2}6[Ff])(?:t|\\\\u0{2}74)(?:o|\\\\u0{2}6[Ff])(?:_|\\\\u0{2}5[Ff]){2}\"\\s*:/,\n\tconstructor:\n\t\t/\"(?:c|\\\\u0063)(?:o|\\\\u006[Ff])(?:n|\\\\u006[Ee])(?:s|\\\\u0073)(?:t|\\\\u0074)(?:r|\\\\u0072)(?:u|\\\\u0075)(?:c|\\\\u0063)(?:t|\\\\u0074)(?:o|\\\\u006[Ff])(?:r|\\\\u0072)\"\\s*:/,\n\tprotoShort: /\"__proto__\"\\s*:/,\n\tconstructorShort: /\"constructor\"\\s*:/,\n} as const;\n\nconst JSON_SIGNATURE =\n\t/^\\s*[\"[{]|^\\s*-?\\d{1,16}(\\.\\d{1,17})?([Ee][+-]?\\d+)?\\s*$/;\n\nconst SPECIAL_VALUES = {\n\ttrue: true,\n\tfalse: false,\n\tnull: null,\n\tundefined: undefined,\n\tnan: Number.NaN,\n\tinfinity: Number.POSITIVE_INFINITY,\n\t\"-infinity\": Number.NEGATIVE_INFINITY,\n} as const;\n\nconst ISO_DATE_REGEX =\n\t/^(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})(?:\\.(\\d{1,7}))?(?:Z|([+-])(\\d{2}):(\\d{2}))$/;\n\ntype ParseOptions = {\n\t/** Throw errors instead of returning the original value */\n\tstrict?: boolean | undefined;\n\t/** Log warnings when suspicious patterns are detected */\n\twarnings?: boolean | undefined;\n\t/** Custom reviver function */\n\treviver?: ((key: string, value: any) => any) | undefined;\n\t/** Automatically convert ISO date strings to Date objects */\n\tparseDates?: boolean | undefined;\n};\n\nfunction isValidDate(date: Date): boolean {\n\treturn date instanceof Date && !isNaN(date.getTime());\n}\n\nfunction parseISODate(value: string): Date | null {\n\tconst match = ISO_DATE_REGEX.exec(value);\n\tif (!match) return null;\n\n\tconst [\n\t\t,\n\t\tyear,\n\t\tmonth,\n\t\tday,\n\t\thour,\n\t\tminute,\n\t\tsecond,\n\t\tms,\n\t\toffsetSign,\n\t\toffsetHour,\n\t\toffsetMinute,\n\t] = match;\n\n\tlet date = new Date(\n\t\tDate.UTC(\n\t\t\tparseInt(year!, 10),\n\t\t\tparseInt(month!, 10) - 1,\n\t\t\tparseInt(day!, 10),\n\t\t\tparseInt(hour!, 10),\n\t\t\tparseInt(minute!, 10),\n\t\t\tparseInt(second!, 10),\n\t\t\tms ? parseInt(ms.padEnd(3, \"0\"), 10) : 0,\n\t\t),\n\t);\n\n\tif (offsetSign) {\n\t\tconst offset =\n\t\t\t(parseInt(offsetHour!, 10) * 60 + parseInt(offsetMinute!, 10)) *\n\t\t\t(offsetSign === \"+\" ? -1 : 1);\n\t\tdate.setUTCMinutes(date.getUTCMinutes() + offset);\n\t}\n\n\treturn isValidDate(date) ? date : null;\n}\n\nfunction betterJSONParse<T = unknown>(\n\tvalue: unknown,\n\toptions: ParseOptions = {},\n): T {\n\tconst {\n\t\tstrict = false,\n\t\twarnings = false,\n\t\treviver,\n\t\tparseDates = true,\n\t} = options;\n\n\tif (typeof value !== \"string\") {\n\t\treturn value as T;\n\t}\n\n\tconst trimmed = value.trim();\n\n\tif (\n\t\ttrimmed.length > 0 &&\n\t\ttrimmed[0] === '\"' &&\n\t\ttrimmed.endsWith('\"') &&\n\t\t!trimmed.slice(1, -1).includes('\"')\n\t) {\n\t\treturn trimmed.slice(1, -1) as T;\n\t}\n\n\tconst lowerValue = trimmed.toLowerCase();\n\tif (lowerValue.length <= 9 && lowerValue in SPECIAL_VALUES) {\n\t\treturn SPECIAL_VALUES[lowerValue as keyof typeof SPECIAL_VALUES] as T;\n\t}\n\n\tif (!JSON_SIGNATURE.test(trimmed)) {\n\t\tif (strict) {\n\t\t\tthrow new SyntaxError(\"[better-json] Invalid JSON\");\n\t\t}\n\t\treturn value as T;\n\t}\n\n\tconst hasProtoPattern = Object.entries(PROTO_POLLUTION_PATTERNS).some(\n\t\t([key, pattern]) => {\n\t\t\tconst matches = pattern.test(trimmed);\n\t\t\tif (matches && warnings) {\n\t\t\t\tconsole.warn(\n\t\t\t\t\t`[better-json] Detected potential prototype pollution attempt using ${key} pattern`,\n\t\t\t\t);\n\t\t\t}\n\t\t\treturn matches;\n\t\t},\n\t);\n\n\tif (hasProtoPattern && strict) {\n\t\tthrow new Error(\n\t\t\t\"[better-json] Potential prototype pollution attempt detected\",\n\t\t);\n\t}\n\n\ttry {\n\t\tconst secureReviver = (key: string, value: any) => {\n\t\t\tif (\n\t\t\t\tkey === \"__proto__\" ||\n\t\t\t\t(key === \"constructor\" &&\n\t\t\t\t\tvalue &&\n\t\t\t\t\ttypeof value === \"object\" &&\n\t\t\t\t\t\"prototype\" in value)\n\t\t\t) {\n\t\t\t\tif (warnings) {\n\t\t\t\t\tconsole.warn(\n\t\t\t\t\t\t`[better-json] Dropping \"${key}\" key to prevent prototype pollution`,\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\treturn undefined;\n\t\t\t}\n\n\t\t\tif (parseDates && typeof value === \"string\") {\n\t\t\t\tconst date = parseISODate(value);\n\t\t\t\tif (date) {\n\t\t\t\t\treturn date;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn reviver ? reviver(key, value) : value;\n\t\t};\n\n\t\treturn JSON.parse(trimmed, secureReviver);\n\t} catch (error) {\n\t\tif (strict) {\n\t\t\tthrow error;\n\t\t}\n\t\treturn value as T;\n\t}\n}\n\nexport function parseJSON<T = unknown>(\n\tvalue: unknown,\n\toptions: ParseOptions = { strict: true },\n): T {\n\treturn betterJSONParse<T>(value, options);\n}\n", "import { cleanTasks } from '../task/index.js'\n\nexport let clean = Symbol('clean')\n\nexport let cleanStores = (...stores) => {\n  if (process.env.NODE_ENV === 'production') {\n    throw new Error(\n      'cleanStores() can be used only during development or tests'\n    )\n  }\n  cleanTasks()\n  for (let $store of stores) {\n    if ($store) {\n      if ($store.mocked) delete $store.mocked\n      if ($store[clean]) $store[clean]()\n    }\n  }\n}\n", "import { clean } from '../clean-stores/index.js'\n\nlet listenerQueue = []\nlet lqIndex = 0\nconst QUEUE_ITEMS_PER_LISTENER = 4\nexport let epoch = 0\n\n/* @__NO_SIDE_EFFECTS__ */\nexport const atom = initialValue => {\n  let listeners = []\n  let $atom = {\n    get() {\n      if (!$atom.lc) {\n        $atom.listen(() => {})()\n      }\n      return $atom.value\n    },\n    lc: 0,\n    listen(listener) {\n      $atom.lc = listeners.push(listener)\n\n      return () => {\n        for (\n          let i = lqIndex + QUEUE_ITEMS_PER_LISTENER;\n          i < listenerQueue.length;\n\n        ) {\n          if (listenerQueue[i] === listener) {\n            listenerQueue.splice(i, QUEUE_ITEMS_PER_LISTENER)\n          } else {\n            i += QUEUE_ITEMS_PER_LISTENER\n          }\n        }\n\n        let index = listeners.indexOf(listener)\n        if (~index) {\n          listeners.splice(index, 1)\n          if (!--$atom.lc) $atom.off()\n        }\n      }\n    },\n    notify(oldValue, changedKey) {\n      epoch++\n      let runListenerQueue = !listenerQueue.length\n      for (let listener of listeners) {\n        listenerQueue.push(listener, $atom.value, oldValue, changedKey)\n      }\n\n      if (runListenerQueue) {\n        for (\n          lqIndex = 0;\n          lqIndex < listenerQueue.length;\n          lqIndex += QUEUE_ITEMS_PER_LISTENER\n        ) {\n          listenerQueue[lqIndex](\n            listenerQueue[lqIndex + 1],\n            listenerQueue[lqIndex + 2],\n            listenerQueue[lqIndex + 3]\n          )\n        }\n        listenerQueue.length = 0\n      }\n    },\n    /* It will be called on last listener unsubscribing.\n       We will redefine it in onMount and onStop. */\n    off() {},\n    set(newValue) {\n      let oldValue = $atom.value\n      if (oldValue !== newValue) {\n        $atom.value = newValue\n        $atom.notify(oldValue)\n      }\n    },\n    subscribe(listener) {\n      let unbind = $atom.listen(listener)\n      listener($atom.value)\n      return unbind\n    },\n    value: initialValue\n  }\n\n  if (process.env.NODE_ENV !== 'production') {\n    $atom[clean] = () => {\n      listeners = []\n      $atom.lc = 0\n      $atom.off()\n    }\n  }\n\n  return $atom\n}\n\nexport const readonlyType = store => store\n", "import { clean } from '../clean-stores/index.js'\n\nconst START = 0\nconst STOP = 1\nconst SET = 2\nconst NOTIFY = 3\nconst MOUNT = 5\nconst UNMOUNT = 6\nconst REVERT_MUTATION = 10\n\nexport let on = (object, listener, eventKey, mutateStore) => {\n  object.events = object.events || {}\n  if (!object.events[eventKey + REVERT_MUTATION]) {\n    object.events[eventKey + REVERT_MUTATION] = mutateStore(eventProps => {\n      // eslint-disable-next-line no-sequences\n      object.events[eventKey].reduceRight((event, l) => (l(event), event), {\n        shared: {},\n        ...eventProps\n      })\n    })\n  }\n  object.events[eventKey] = object.events[eventKey] || []\n  object.events[eventKey].push(listener)\n  return () => {\n    let currentListeners = object.events[eventKey]\n    let index = currentListeners.indexOf(listener)\n    currentListeners.splice(index, 1)\n    if (!currentListeners.length) {\n      delete object.events[eventKey]\n      object.events[eventKey + REVERT_MUTATION]()\n      delete object.events[eventKey + REVERT_MUTATION]\n    }\n  }\n}\n\nexport let onStart = ($store, listener) =>\n  on($store, listener, START, runListeners => {\n    let originListen = $store.listen\n    $store.listen = arg => {\n      if (!$store.lc && !$store.starting) {\n        $store.starting = true\n        runListeners()\n        delete $store.starting\n      }\n      return originListen(arg)\n    }\n    return () => {\n      $store.listen = originListen\n    }\n  })\n\nexport let onStop = ($store, listener) =>\n  on($store, listener, STOP, runListeners => {\n    let originOff = $store.off\n    $store.off = () => {\n      runListeners()\n      originOff()\n    }\n    return () => {\n      $store.off = originOff\n    }\n  })\n\nexport let onSet = ($store, listener) =>\n  on($store, listener, SET, runListeners => {\n    let originSet = $store.set\n    let originSetKey = $store.setKey\n    if ($store.setKey) {\n      $store.setKey = (changed, changedValue) => {\n        let isAborted\n        let abort = () => {\n          isAborted = true\n        }\n\n        runListeners({\n          abort,\n          changed,\n          newValue: { ...$store.value, [changed]: changedValue }\n        })\n        if (!isAborted) return originSetKey(changed, changedValue)\n      }\n    }\n    $store.set = newValue => {\n      let isAborted\n      let abort = () => {\n        isAborted = true\n      }\n\n      runListeners({ abort, newValue })\n      if (!isAborted) return originSet(newValue)\n    }\n    return () => {\n      $store.set = originSet\n      $store.setKey = originSetKey\n    }\n  })\n\nexport let onNotify = ($store, listener) =>\n  on($store, listener, NOTIFY, runListeners => {\n    let originNotify = $store.notify\n    $store.notify = (oldValue, changed) => {\n      let isAborted\n      let abort = () => {\n        isAborted = true\n      }\n\n      runListeners({ abort, changed, oldValue })\n      if (!isAborted) return originNotify(oldValue, changed)\n    }\n    return () => {\n      $store.notify = originNotify\n    }\n  })\n\nexport let STORE_UNMOUNT_DELAY = 1000\n\nexport let onMount = ($store, initialize) => {\n  let listener = payload => {\n    let destroy = initialize(payload)\n    if (destroy) $store.events[UNMOUNT].push(destroy)\n  }\n  return on($store, listener, MOUNT, runListeners => {\n    let originListen = $store.listen\n    $store.listen = (...args) => {\n      if (!$store.lc && !$store.active) {\n        $store.active = true\n        runListeners()\n      }\n      return originListen(...args)\n    }\n\n    let originOff = $store.off\n    $store.events[UNMOUNT] = []\n    $store.off = () => {\n      originOff()\n      setTimeout(() => {\n        if ($store.active && !$store.lc) {\n          $store.active = false\n          for (let destroy of $store.events[UNMOUNT]) destroy()\n          $store.events[UNMOUNT] = []\n        }\n      }, STORE_UNMOUNT_DELAY)\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      let originClean = $store[clean]\n      $store[clean] = () => {\n        for (let destroy of $store.events[UNMOUNT]) destroy()\n        $store.events[UNMOUNT] = []\n        $store.active = false\n        originClean()\n      }\n    }\n\n    return () => {\n      $store.listen = originListen\n      $store.off = originOff\n    }\n  })\n}\n", "import type { ClientFetchOption } from \"@better-auth/core\";\nimport type { BetterFetch, BetterFetchError } from \"@better-fetch/fetch\";\nimport type { PreinitializedWritableAtom } from \"nanostores\";\nimport { atom, onMount } from \"nanostores\";\nimport type { SessionQueryParams } from \"./types\";\n\n// SSR detection\nconst isServer = () => typeof window === \"undefined\";\n\nexport type AuthQueryAtom<T> = PreinitializedWritableAtom<{\n\tdata: null | T;\n\terror: null | BetterFetchError;\n\tisPending: boolean;\n\tisRefetching: boolean;\n\trefetch: (\n\t\tqueryParams?: { query?: SessionQueryParams } | undefined,\n\t) => Promise<void>;\n}>;\n\nexport const useAuthQuery = <T>(\n\tinitializedAtom:\n\t\t| PreinitializedWritableAtom<any>\n\t\t| PreinitializedWritableAtom<any>[],\n\tpath: string,\n\t$fetch: BetterFetch,\n\toptions?:\n\t\t| (\n\t\t\t\t| ((value: {\n\t\t\t\t\t\tdata: null | T;\n\t\t\t\t\t\terror: null | BetterFetchError;\n\t\t\t\t\t\tisPending: boolean;\n\t\t\t\t  }) => ClientFetchOption)\n\t\t\t\t| ClientFetchOption\n\t\t  )\n\t\t| undefined,\n) => {\n\tconst value: AuthQueryAtom<T> = atom({\n\t\tdata: null,\n\t\terror: null,\n\t\tisPending: true,\n\t\tisRefetching: false,\n\t\trefetch: (queryParams) => fn(queryParams),\n\t});\n\n\tconst fn = async (\n\t\tqueryParams?: { query?: SessionQueryParams } | undefined,\n\t) => {\n\t\treturn new Promise<void>((resolve) => {\n\t\t\tconst opts =\n\t\t\t\ttypeof options === \"function\"\n\t\t\t\t\t? options({\n\t\t\t\t\t\t\tdata: value.get().data,\n\t\t\t\t\t\t\terror: value.get().error,\n\t\t\t\t\t\t\tisPending: value.get().isPending,\n\t\t\t\t\t\t})\n\t\t\t\t\t: options;\n\n\t\t\t$fetch<T>(path, {\n\t\t\t\t...opts,\n\t\t\t\tquery: {\n\t\t\t\t\t...opts?.query,\n\t\t\t\t\t...queryParams?.query,\n\t\t\t\t},\n\t\t\t\tasync onSuccess(context) {\n\t\t\t\t\tvalue.set({\n\t\t\t\t\t\tdata: context.data,\n\t\t\t\t\t\terror: null,\n\t\t\t\t\t\tisPending: false,\n\t\t\t\t\t\tisRefetching: false,\n\t\t\t\t\t\trefetch: value.value.refetch,\n\t\t\t\t\t});\n\t\t\t\t\tawait opts?.onSuccess?.(context);\n\t\t\t\t},\n\t\t\t\tasync onError(context) {\n\t\t\t\t\tconst { request } = context;\n\t\t\t\t\tconst retryAttempts =\n\t\t\t\t\t\ttypeof request.retry === \"number\"\n\t\t\t\t\t\t\t? request.retry\n\t\t\t\t\t\t\t: request.retry?.attempts;\n\t\t\t\t\tconst retryAttempt = request.retryAttempt || 0;\n\t\t\t\t\tif (retryAttempts && retryAttempt < retryAttempts) return;\n\t\t\t\t\tvalue.set({\n\t\t\t\t\t\terror: context.error,\n\t\t\t\t\t\tdata: null,\n\t\t\t\t\t\tisPending: false,\n\t\t\t\t\t\tisRefetching: false,\n\t\t\t\t\t\trefetch: value.value.refetch,\n\t\t\t\t\t});\n\t\t\t\t\tawait opts?.onError?.(context);\n\t\t\t\t},\n\t\t\t\tasync onRequest(context) {\n\t\t\t\t\tconst currentValue = value.get();\n\t\t\t\t\tvalue.set({\n\t\t\t\t\t\tisPending: currentValue.data === null,\n\t\t\t\t\t\tdata: currentValue.data,\n\t\t\t\t\t\terror: null,\n\t\t\t\t\t\tisRefetching: true,\n\t\t\t\t\t\trefetch: value.value.refetch,\n\t\t\t\t\t});\n\t\t\t\t\tawait opts?.onRequest?.(context);\n\t\t\t\t},\n\t\t\t})\n\t\t\t\t.catch((error) => {\n\t\t\t\t\tvalue.set({\n\t\t\t\t\t\terror,\n\t\t\t\t\t\tdata: null,\n\t\t\t\t\t\tisPending: false,\n\t\t\t\t\t\tisRefetching: false,\n\t\t\t\t\t\trefetch: value.value.refetch,\n\t\t\t\t\t});\n\t\t\t\t})\n\t\t\t\t.finally(() => {\n\t\t\t\t\tresolve(void 0);\n\t\t\t\t});\n\t\t});\n\t};\n\tinitializedAtom = Array.isArray(initializedAtom)\n\t\t? initializedAtom\n\t\t: [initializedAtom];\n\tlet isMounted = false;\n\n\tfor (const initAtom of initializedAtom) {\n\t\tinitAtom.subscribe(async () => {\n\t\t\tif (isServer()) {\n\t\t\t\t// On server, don't trigger fetch\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (isMounted) {\n\t\t\t\tawait fn();\n\t\t\t} else {\n\t\t\t\tonMount(value, () => {\n\t\t\t\t\tconst timeoutId = setTimeout(async () => {\n\t\t\t\t\t\tif (!isMounted) {\n\t\t\t\t\t\t\tawait fn();\n\t\t\t\t\t\t\tisMounted = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}, 0);\n\t\t\t\t\treturn () => {\n\t\t\t\t\t\tvalue.off();\n\t\t\t\t\t\tinitAtom.off();\n\t\t\t\t\t\tclearTimeout(timeoutId);\n\t\t\t\t\t};\n\t\t\t\t});\n\t\t\t}\n\t\t});\n\t}\n\treturn value;\n};\n", "export interface BroadcastMessage {\n\tevent?: \"session\" | undefined;\n\tdata?: { trigger?: \"signout\" | \"getSession\" | \"updateUser\" } | undefined;\n\tclientId: string;\n\ttimestamp: number;\n}\n\nexport type BroadcastListener = (message: BroadcastMessage) => void;\n\nexport const kBroadcastChannel = Symbol.for(\"better-auth:broadcast-channel\");\n\nconst now = () => Math.floor(Date.now() / 1000);\n\nexport interface BroadcastChannel {\n\tpost(message: Record<string, unknown>): void;\n\tsubscribe(listener: BroadcastListener): () => void;\n\tsetup(): () => void;\n}\n\nclass WindowBroadcastChannel implements BroadcastChannel {\n\tlisteners = new Set<BroadcastListener>();\n\tprivate name: string;\n\n\tconstructor(name = \"better-auth.message\") {\n\t\tthis.name = name;\n\t}\n\n\tsubscribe(listener: BroadcastListener) {\n\t\tthis.listeners.add(listener);\n\t\treturn () => {\n\t\t\tthis.listeners.delete(listener);\n\t\t};\n\t}\n\n\tpost(message: Record<string, unknown>) {\n\t\tif (typeof window === \"undefined\") return;\n\t\ttry {\n\t\t\tlocalStorage.setItem(\n\t\t\t\tthis.name,\n\t\t\t\tJSON.stringify({ ...message, timestamp: now() }),\n\t\t\t);\n\t\t} catch {}\n\t}\n\n\tsetup() {\n\t\tif (\n\t\t\ttypeof window === \"undefined\" ||\n\t\t\ttypeof window.addEventListener === \"undefined\"\n\t\t) {\n\t\t\treturn () => {};\n\t\t}\n\n\t\tconst handler = (event: StorageEvent) => {\n\t\t\tif (event.key !== this.name) return;\n\t\t\tconst message: BroadcastMessage = JSON.parse(event.newValue ?? \"{}\");\n\t\t\tif (message?.event !== \"session\" || !message?.data) return;\n\n\t\t\tthis.listeners.forEach((listener) => listener(message));\n\t\t};\n\n\t\twindow.addEventListener(\"storage\", handler);\n\n\t\treturn () => {\n\t\t\twindow.removeEventListener(\"storage\", handler);\n\t\t};\n\t}\n}\n\nexport function getGlobalBroadcastChannel(name = \"better-auth.message\") {\n\tif (!(globalThis as any)[kBroadcastChannel]) {\n\t\t(globalThis as any)[kBroadcastChannel] = new WindowBroadcastChannel(name);\n\t}\n\treturn (globalThis as any)[kBroadcastChannel] as BroadcastChannel;\n}\n", "export type FocusListener = (focused: boolean) => void;\n\nexport const kFocusManager = Symbol.for(\"better-auth:focus-manager\");\n\nexport interface FocusManager {\n\tsetFocused(focused: boolean): void;\n\tsubscribe(listener: FocusListener): () => void;\n\tsetup(): () => void;\n}\n\nclass WindowFocusManager implements FocusManager {\n\tlisteners = new Set<FocusListener>();\n\n\tsubscribe(listener: FocusListener) {\n\t\tthis.listeners.add(listener);\n\t\treturn () => {\n\t\t\tthis.listeners.delete(listener);\n\t\t};\n\t}\n\n\tsetFocused(focused: boolean) {\n\t\tthis.listeners.forEach((listener) => listener(focused));\n\t}\n\n\tsetup() {\n\t\tif (\n\t\t\ttypeof window === \"undefined\" ||\n\t\t\ttypeof document === \"undefined\" ||\n\t\t\ttypeof window.addEventListener === \"undefined\"\n\t\t) {\n\t\t\treturn () => {};\n\t\t}\n\n\t\tconst visibilityHandler = () => {\n\t\t\tif (document.visibilityState === \"visible\") {\n\t\t\t\tthis.setFocused(true);\n\t\t\t}\n\t\t};\n\n\t\tdocument.addEventListener(\"visibilitychange\", visibilityHandler, false);\n\n\t\treturn () => {\n\t\t\tdocument.removeEventListener(\n\t\t\t\t\"visibilitychange\",\n\t\t\t\tvisibilityHandler,\n\t\t\t\tfalse,\n\t\t\t);\n\t\t};\n\t}\n}\n\nexport function getGlobalFocusManager() {\n\tif (!(globalThis as any)[kFocusManager]) {\n\t\t(globalThis as any)[kFocusManager] = new WindowFocusManager();\n\t}\n\treturn (globalThis as any)[kFocusManager] as FocusManager;\n}\n", "export type OnlineListener = (online: boolean) => void;\n\nexport const kOnlineManager = Symbol.for(\"better-auth:online-manager\");\n\nexport interface OnlineManager {\n\tsetOnline(online: boolean): void;\n\tisOnline: boolean;\n\n\tsubscribe(listener: OnlineListener): () => void;\n\tsetup(): () => void;\n}\n\nclass WindowOnlineManager implements OnlineManager {\n\tlisteners = new Set<OnlineListener>();\n\tisOnline = typeof navigator !== \"undefined\" ? navigator.onLine : true;\n\n\tsubscribe(listener: OnlineListener) {\n\t\tthis.listeners.add(listener);\n\t\treturn () => {\n\t\t\tthis.listeners.delete(listener);\n\t\t};\n\t}\n\n\tsetOnline(online: boolean) {\n\t\tthis.isOnline = online;\n\t\tthis.listeners.forEach((listener) => listener(online));\n\t}\n\n\tsetup() {\n\t\tif (\n\t\t\ttypeof window === \"undefined\" ||\n\t\t\ttypeof window.addEventListener === \"undefined\"\n\t\t) {\n\t\t\treturn () => {};\n\t\t}\n\n\t\tconst onOnline = () => this.setOnline(true);\n\t\tconst onOffline = () => this.setOnline(false);\n\n\t\twindow.addEventListener(\"online\", onOnline, false);\n\t\twindow.addEventListener(\"offline\", onOffline, false);\n\n\t\treturn () => {\n\t\t\twindow.removeEventListener(\"online\", onOnline, false);\n\t\t\twindow.removeEventListener(\"offline\", onOffline, false);\n\t\t};\n\t}\n}\n\nexport function getGlobalOnlineManager() {\n\tif (!(globalThis as any)[kOnlineManager]) {\n\t\t(globalThis as any)[kOnlineManager] = new WindowOnlineManager();\n\t}\n\treturn (globalThis as any)[kOnlineManager] as OnlineManager;\n}\n", "import type { BetterAuthClientOptions } from \"@better-auth/core\";\nimport type { Session, User } from \"@better-auth/core/db\";\nimport type { BetterFetch, BetterFetchError } from \"@better-fetch/fetch\";\nimport type { WritableAtom } from \"nanostores\";\nimport { getGlobalBroadcastChannel } from \"./broadcast-channel\";\nimport { getGlobalFocusManager } from \"./focus-manager\";\nimport { getGlobalOnlineManager } from \"./online-manager\";\nimport type { AuthQueryAtom } from \"./query\";\n\nconst now = () => Math.floor(Date.now() / 1000);\n\n/**\n * Rate limit: don't refetch on focus if a session request was made within this many seconds\n */\nconst FOCUS_REFETCH_RATE_LIMIT_SECONDS = 5;\n\nexport interface SessionRefreshOptions {\n\tsessionAtom: AuthQueryAtom<{\n\t\tuser: User;\n\t\tsession: Session;\n\t}>;\n\tsessionSignal: WritableAtom<boolean>;\n\t$fetch: BetterFetch;\n\toptions?: BetterAuthClientOptions | undefined;\n}\n\ninterface SessionRefreshState {\n\tlastSync: number;\n\tlastSessionRequest: number;\n\tcachedSession: any;\n\tpollInterval?: ReturnType<typeof setInterval> | undefined;\n\tunsubscribeBroadcast?: (() => void) | undefined;\n\tunsubscribeFocus?: (() => void) | undefined;\n\tunsubscribeOnline?: (() => void) | undefined;\n}\n\nexport function createSessionRefreshManager(opts: SessionRefreshOptions) {\n\tconst { sessionAtom, sessionSignal, $fetch, options = {} } = opts;\n\n\tconst refetchInterval = options.sessionOptions?.refetchInterval ?? 0;\n\tconst refetchOnWindowFocus =\n\t\toptions.sessionOptions?.refetchOnWindowFocus ?? true;\n\tconst refetchWhenOffline =\n\t\toptions.sessionOptions?.refetchWhenOffline ?? false;\n\n\tconst state: SessionRefreshState = {\n\t\tlastSync: 0,\n\t\tlastSessionRequest: 0,\n\t\tcachedSession: undefined,\n\t};\n\n\tconst shouldRefetch = (): boolean => {\n\t\treturn refetchWhenOffline || getGlobalOnlineManager().isOnline;\n\t};\n\n\tconst triggerRefetch = (\n\t\tevent?:\n\t\t\t| {\n\t\t\t\t\tevent?: \"poll\" | \"visibilitychange\" | \"storage\";\n\t\t\t  }\n\t\t\t| undefined,\n\t) => {\n\t\tif (!shouldRefetch()) return;\n\n\t\tif (event?.event === \"storage\") {\n\t\t\tstate.lastSync = now();\n\t\t\tsessionSignal.set(!sessionSignal.get());\n\t\t\treturn;\n\t\t}\n\n\t\tconst currentSession = sessionAtom.get();\n\n\t\tif (event?.event === \"poll\") {\n\t\t\tstate.lastSessionRequest = now();\n\t\t\t$fetch<{\n\t\t\t\tuser: User;\n\t\t\t\tsession: Session;\n\t\t\t}>(\"/get-session\")\n\t\t\t\t.then((res) => {\n\t\t\t\t\tif (res.error) {\n\t\t\t\t\t\tsessionAtom.set({\n\t\t\t\t\t\t\t...currentSession,\n\t\t\t\t\t\t\tdata: null,\n\t\t\t\t\t\t\terror: res.error as BetterFetchError | null,\n\t\t\t\t\t\t});\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsessionAtom.set({\n\t\t\t\t\t\t\t...currentSession,\n\t\t\t\t\t\t\tdata: res.data,\n\t\t\t\t\t\t\terror: null,\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\tstate.lastSync = now();\n\t\t\t\t\tsessionSignal.set(!sessionSignal.get());\n\t\t\t\t})\n\t\t\t\t.catch(() => {});\n\t\t\treturn;\n\t\t}\n\n\t\t// Rate limit: don't refetch on focus if a session request was made recently\n\t\tif (event?.event === \"visibilitychange\") {\n\t\t\tconst timeSinceLastRequest = now() - state.lastSessionRequest;\n\t\t\tif (timeSinceLastRequest < FOCUS_REFETCH_RATE_LIMIT_SECONDS) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tstate.lastSessionRequest = now();\n\t\t}\n\n\t\tif (\n\t\t\tcurrentSession?.data === null ||\n\t\t\tcurrentSession?.data === undefined ||\n\t\t\tevent?.event === \"visibilitychange\"\n\t\t) {\n\t\t\tstate.lastSync = now();\n\t\t\tsessionSignal.set(!sessionSignal.get());\n\t\t}\n\t};\n\n\tconst broadcastSessionUpdate = (\n\t\ttrigger: \"signout\" | \"getSession\" | \"updateUser\",\n\t) => {\n\t\tgetGlobalBroadcastChannel().post({\n\t\t\tevent: \"session\",\n\t\t\tdata: { trigger },\n\t\t\tclientId: Math.random().toString(36).substring(7),\n\t\t});\n\t};\n\n\tconst setupPolling = () => {\n\t\tif (refetchInterval && refetchInterval > 0) {\n\t\t\tstate.pollInterval = setInterval(() => {\n\t\t\t\tconst currentSession = sessionAtom.get();\n\t\t\t\tif (currentSession?.data) {\n\t\t\t\t\ttriggerRefetch({ event: \"poll\" });\n\t\t\t\t}\n\t\t\t}, refetchInterval * 1000);\n\t\t}\n\t};\n\n\tconst setupBroadcast = () => {\n\t\tstate.unsubscribeBroadcast = getGlobalBroadcastChannel().subscribe(() => {\n\t\t\ttriggerRefetch({ event: \"storage\" });\n\t\t});\n\t};\n\n\tconst setupFocusRefetch = () => {\n\t\tif (!refetchOnWindowFocus) return;\n\n\t\tstate.unsubscribeFocus = getGlobalFocusManager().subscribe(() => {\n\t\t\ttriggerRefetch({ event: \"visibilitychange\" });\n\t\t});\n\t};\n\n\tconst setupOnlineRefetch = () => {\n\t\tstate.unsubscribeOnline = getGlobalOnlineManager().subscribe((online) => {\n\t\t\tif (online) {\n\t\t\t\ttriggerRefetch({ event: \"visibilitychange\" });\n\t\t\t}\n\t\t});\n\t};\n\n\tconst init = () => {\n\t\tsetupPolling();\n\t\tsetupBroadcast();\n\t\tsetupFocusRefetch();\n\t\tsetupOnlineRefetch();\n\n\t\tgetGlobalBroadcastChannel().setup();\n\t\tgetGlobalFocusManager().setup();\n\t\tgetGlobalOnlineManager().setup();\n\t};\n\n\tconst cleanup = () => {\n\t\tif (state.pollInterval) {\n\t\t\tclearInterval(state.pollInterval);\n\t\t\tstate.pollInterval = undefined;\n\t\t}\n\t\tif (state.unsubscribeBroadcast) {\n\t\t\tstate.unsubscribeBroadcast();\n\t\t\tstate.unsubscribeBroadcast = undefined;\n\t\t}\n\t\tif (state.unsubscribeFocus) {\n\t\t\tstate.unsubscribeFocus();\n\t\t\tstate.unsubscribeFocus = undefined;\n\t\t}\n\t\tif (state.unsubscribeOnline) {\n\t\t\tstate.unsubscribeOnline();\n\t\t\tstate.unsubscribeOnline = undefined;\n\t\t}\n\t\tstate.lastSync = 0;\n\t\tstate.lastSessionRequest = 0;\n\t\tstate.cachedSession = undefined;\n\t};\n\n\treturn {\n\t\tinit,\n\t\tcleanup,\n\t\ttriggerRefetch,\n\t\tbroadcastSessionUpdate,\n\t};\n}\n", "import type { BetterAuthClientOptions } from \"@better-auth/core\";\nimport type { BetterFetch } from \"@better-fetch/fetch\";\nimport { atom, onMount } from \"nanostores\";\nimport type { Session, User } from \"../types\";\nimport type { AuthQueryAtom } from \"./query\";\nimport { useAuthQuery } from \"./query\";\nimport { createSessionRefreshManager } from \"./session-refresh\";\n\nexport type SessionAtom = AuthQueryAtom<{\n\tuser: User;\n\tsession: Session;\n}>;\n\nexport function getSessionAtom(\n\t$fetch: BetterFetch,\n\toptions?: BetterAuthClientOptions | undefined,\n) {\n\tconst $signal = atom<boolean>(false);\n\tconst session: SessionAtom = useAuthQuery<{\n\t\tuser: User;\n\t\tsession: Session;\n\t}>($signal, \"/get-session\", $fetch, {\n\t\tmethod: \"GET\",\n\t});\n\n\tonMount(session, () => {\n\t\tconst refreshManager = createSessionRefreshManager({\n\t\t\tsessionAtom: session,\n\t\t\tsessionSignal: $signal,\n\t\t\t$fetch,\n\t\t\toptions,\n\t\t});\n\n\t\trefreshManager.init();\n\n\t\treturn () => {\n\t\t\trefreshManager.cleanup();\n\t\t};\n\t});\n\n\treturn {\n\t\tsession,\n\t\t$sessionSignal: $signal,\n\t};\n}\n", "import type {\n\tBetterAuthClientOptions,\n\tClientAtomListener,\n} from \"@better-auth/core\";\nimport { createFetch } from \"@better-fetch/fetch\";\nimport type { WritableAtom } from \"nanostores\";\nimport { getBaseURL } from \"../utils/url\";\nimport { redirectPlugin } from \"./fetch-plugins\";\nimport { parseJSON } from \"./parser\";\nimport { getSessionAtom } from \"./session-atom\";\n\nexport const getClientConfig = (\n\toptions?: BetterAuthClientOptions | undefined,\n\tloadEnv?: boolean | undefined,\n) => {\n\t/* check if the credentials property is supported. Useful for cf workers */\n\tconst isCredentialsSupported = \"credentials\" in Request.prototype;\n\tconst baseURL =\n\t\tgetBaseURL(options?.baseURL, options?.basePath, undefined, loadEnv) ??\n\t\t\"/api/auth\";\n\tconst pluginsFetchPlugins =\n\t\toptions?.plugins\n\t\t\t?.flatMap((plugin) => plugin.fetchPlugins)\n\t\t\t.filter((pl) => pl !== undefined) || [];\n\tconst lifeCyclePlugin = {\n\t\tid: \"lifecycle-hooks\",\n\t\tname: \"lifecycle-hooks\",\n\t\thooks: {\n\t\t\tonSuccess: options?.fetchOptions?.onSuccess,\n\t\t\tonError: options?.fetchOptions?.onError,\n\t\t\tonRequest: options?.fetchOptions?.onRequest,\n\t\t\tonResponse: options?.fetchOptions?.onResponse,\n\t\t},\n\t};\n\tconst {\n\t\tonSuccess: _onSuccess,\n\t\tonError: _onError,\n\t\tonRequest: _onRequest,\n\t\tonResponse: _onResponse,\n\t\t...restOfFetchOptions\n\t} = options?.fetchOptions || {};\n\tconst $fetch = createFetch({\n\t\tbaseURL,\n\t\t...(isCredentialsSupported ? { credentials: \"include\" } : {}),\n\t\tmethod: \"GET\",\n\t\tjsonParser(text) {\n\t\t\tif (!text) {\n\t\t\t\treturn null as any;\n\t\t\t}\n\t\t\treturn parseJSON(text, {\n\t\t\t\tstrict: false,\n\t\t\t});\n\t\t},\n\t\tcustomFetchImpl: fetch,\n\t\t...restOfFetchOptions,\n\t\tplugins: [\n\t\t\tlifeCyclePlugin,\n\t\t\t...(restOfFetchOptions.plugins || []),\n\t\t\t...(options?.disableDefaultFetchPlugins ? [] : [redirectPlugin]),\n\t\t\t...pluginsFetchPlugins,\n\t\t],\n\t});\n\tconst { $sessionSignal, session } = getSessionAtom($fetch, options);\n\tconst plugins = options?.plugins || [];\n\tlet pluginsActions = {} as Record<string, any>;\n\tlet pluginsAtoms = {\n\t\t$sessionSignal,\n\t\tsession,\n\t} as Record<string, WritableAtom<any>>;\n\tlet pluginPathMethods: Record<string, \"POST\" | \"GET\"> = {\n\t\t\"/sign-out\": \"POST\",\n\t\t\"/revoke-sessions\": \"POST\",\n\t\t\"/revoke-other-sessions\": \"POST\",\n\t\t\"/delete-user\": \"POST\",\n\t};\n\tconst atomListeners: ClientAtomListener[] = [\n\t\t{\n\t\t\tsignal: \"$sessionSignal\",\n\t\t\tmatcher(path) {\n\t\t\t\tconst matchesCommonPaths =\n\t\t\t\t\tpath === \"/sign-out\" ||\n\t\t\t\t\tpath === \"/update-user\" ||\n\t\t\t\t\tpath === \"/sign-up/email\" ||\n\t\t\t\t\tpath === \"/sign-in/email\" ||\n\t\t\t\t\tpath === \"/delete-user\" ||\n\t\t\t\t\tpath === \"/verify-email\" ||\n\t\t\t\t\tpath === \"/revoke-sessions\" ||\n\t\t\t\t\tpath === \"/revoke-session\" ||\n\t\t\t\t\tpath === \"/change-email\";\n\n\t\t\t\treturn matchesCommonPaths;\n\t\t\t},\n\t\t},\n\t];\n\n\tfor (const plugin of plugins) {\n\t\tif (plugin.getAtoms) {\n\t\t\tObject.assign(pluginsAtoms, plugin.getAtoms?.($fetch));\n\t\t}\n\t\tif (plugin.pathMethods) {\n\t\t\tObject.assign(pluginPathMethods, plugin.pathMethods);\n\t\t}\n\t\tif (plugin.atomListeners) {\n\t\t\tatomListeners.push(...plugin.atomListeners);\n\t\t}\n\t}\n\n\tconst $store = {\n\t\tnotify: (\n\t\t\tsignal?: (Omit<string, \"$sessionSignal\"> | \"$sessionSignal\") | undefined,\n\t\t) => {\n\t\t\tpluginsAtoms[signal as keyof typeof pluginsAtoms]!.set(\n\t\t\t\t!pluginsAtoms[signal as keyof typeof pluginsAtoms]!.get(),\n\t\t\t);\n\t\t},\n\t\tlisten: (\n\t\t\tsignal: Omit<string, \"$sessionSignal\"> | \"$sessionSignal\",\n\t\t\tlistener: (value: boolean, oldValue?: boolean | undefined) => void,\n\t\t) => {\n\t\t\tpluginsAtoms[signal as keyof typeof pluginsAtoms]!.subscribe(listener);\n\t\t},\n\t\tatoms: pluginsAtoms,\n\t};\n\n\tfor (const plugin of plugins) {\n\t\tif (plugin.getActions) {\n\t\t\tObject.assign(\n\t\t\t\tpluginsActions,\n\t\t\t\tplugin.getActions?.($fetch, $store, options),\n\t\t\t);\n\t\t}\n\t}\n\treturn {\n\t\tget baseURL() {\n\t\t\treturn baseURL;\n\t\t},\n\t\tpluginsActions,\n\t\tpluginsAtoms,\n\t\tpluginPathMethods,\n\t\tatomListeners,\n\t\t$fetch,\n\t\t$store,\n\t};\n};\n", "import type { Atom } from \"nanostores\";\n\nexport function isAtom(value: unknown): value is Atom<unknown> {\n\treturn (\n\t\ttypeof value === \"object\" &&\n\t\tvalue !== null &&\n\t\t\"get\" in value &&\n\t\ttypeof (value as any).get === \"function\" &&\n\t\t\"lc\" in value &&\n\t\ttypeof (value as any).lc === \"number\"\n\t);\n}\n", "import type {\n\tBetterAuthClientPlugin,\n\tClientAtomListener,\n\tClientFetchOption,\n} from \"@better-auth/core\";\nimport type { BetterFetch } from \"@better-fetch/fetch\";\nimport type { Atom } from \"nanostores\";\nimport { isAtom } from \"../utils/is-atom\";\nimport type { ProxyRequest } from \"./path-to-object\";\n\nfunction getMethod(\n\tpath: string,\n\tknownPathMethods: Record<string, \"POST\" | \"GET\">,\n\targs:\n\t\t| {\n\t\t\t\tfetchOptions?: ClientFetchOption | undefined;\n\t\t\t\tquery?: Record<string, any> | undefined;\n\t\t  }\n\t\t| undefined,\n) {\n\tconst method = knownPathMethods[path];\n\tconst { fetchOptions, query: _query, ...body } = args || {};\n\tif (method) {\n\t\treturn method;\n\t}\n\tif (fetchOptions?.method) {\n\t\treturn fetchOptions.method;\n\t}\n\tif (body && Object.keys(body).length > 0) {\n\t\treturn \"POST\";\n\t}\n\treturn \"GET\";\n}\n\nexport function createDynamicPathProxy<T extends Record<string, any>>(\n\troutes: T,\n\tclient: BetterFetch,\n\tknownPathMethods: Record<string, \"POST\" | \"GET\">,\n\tatoms: Record<string, Atom>,\n\tatomListeners: BetterAuthClientPlugin[\"atomListeners\"],\n): T {\n\tfunction createProxy(path: string[] = []): any {\n\t\treturn new Proxy(function () {}, {\n\t\t\tget(_, prop) {\n\t\t\t\tif (typeof prop !== \"string\") {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t\tif (prop === \"then\" || prop === \"catch\" || prop === \"finally\") {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\t\t\t\tconst fullPath = [...path, prop];\n\t\t\t\tlet current: any = routes;\n\t\t\t\tfor (const segment of fullPath) {\n\t\t\t\t\tif (current && typeof current === \"object\" && segment in current) {\n\t\t\t\t\t\tcurrent = current[segment];\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcurrent = undefined;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (typeof current === \"function\") {\n\t\t\t\t\treturn current;\n\t\t\t\t}\n\t\t\t\tif (isAtom(current)) {\n\t\t\t\t\treturn current;\n\t\t\t\t}\n\t\t\t\treturn createProxy(fullPath);\n\t\t\t},\n\t\t\tapply: async (_, __, args) => {\n\t\t\t\tconst routePath =\n\t\t\t\t\t\"/\" +\n\t\t\t\t\tpath\n\t\t\t\t\t\t.map((segment) =>\n\t\t\t\t\t\t\tsegment.replace(/[A-Z]/g, (letter) => `-${letter.toLowerCase()}`),\n\t\t\t\t\t\t)\n\t\t\t\t\t\t.join(\"/\");\n\t\t\t\tconst arg = (args[0] || {}) as ProxyRequest;\n\t\t\t\tconst fetchOptions = (args[1] || {}) as ClientFetchOption;\n\t\t\t\tconst { query, fetchOptions: argFetchOptions, ...body } = arg;\n\t\t\t\tconst options = {\n\t\t\t\t\t...fetchOptions,\n\t\t\t\t\t...argFetchOptions,\n\t\t\t\t} as ClientFetchOption;\n\t\t\t\tconst method = getMethod(routePath, knownPathMethods, arg);\n\t\t\t\treturn await client(routePath, {\n\t\t\t\t\t...options,\n\t\t\t\t\tbody:\n\t\t\t\t\t\tmethod === \"GET\"\n\t\t\t\t\t\t\t? undefined\n\t\t\t\t\t\t\t: {\n\t\t\t\t\t\t\t\t\t...body,\n\t\t\t\t\t\t\t\t\t...(options?.body || {}),\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\tquery: query || options?.query,\n\t\t\t\t\tmethod,\n\t\t\t\t\tasync onSuccess(context) {\n\t\t\t\t\t\tawait options?.onSuccess?.(context);\n\t\t\t\t\t\tif (!atomListeners || options.disableSignal) return;\n\t\t\t\t\t\t/**\n\t\t\t\t\t\t * We trigger listeners\n\t\t\t\t\t\t */\n\t\t\t\t\t\tconst matches = atomListeners.filter((s) => s.matcher(routePath));\n\t\t\t\t\t\tif (!matches.length) return;\n\n\t\t\t\t\t\tconst visited = new Set<ClientAtomListener[\"signal\"]>();\n\t\t\t\t\t\tfor (const match of matches) {\n\t\t\t\t\t\t\tconst signal = atoms[match.signal as any];\n\t\t\t\t\t\t\tif (!signal) return;\n\t\t\t\t\t\t\tif (visited.has(match.signal)) {\n\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tvisited.add(match.signal);\n\t\t\t\t\t\t\t/**\n\t\t\t\t\t\t\t * To avoid race conditions we set the signal in a setTimeout\n\t\t\t\t\t\t\t */\n\t\t\t\t\t\t\tconst val = signal.get();\n\t\t\t\t\t\t\tsetTimeout(() => {\n\t\t\t\t\t\t\t\t//@ts-expect-error\n\t\t\t\t\t\t\t\tsignal.set(!val);\n\t\t\t\t\t\t\t}, 10);\n\t\t\t\t\t\t}\n\t\t\t\t\t},\n\t\t\t\t});\n\t\t\t},\n\t\t});\n\t}\n\treturn createProxy() as T;\n}\n"],
  "mappings": "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",
  "names": ["url", "value", "value: AuthQueryAtom<T>", "message: BroadcastMessage", "now", "state: SessionRefreshState", "session: SessionAtom", "pluginPathMethods: Record<string, \"POST\" | \"GET\">", "atomListeners: ClientAtomListener[]", "current: any"]
}
