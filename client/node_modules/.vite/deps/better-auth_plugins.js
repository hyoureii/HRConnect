import {
  APIError,
  HIDE_METADATA,
  SignJWT,
  ZodObject,
  ZodOptional,
  ZodType,
  _enum,
  _undefined,
  abytes,
  aexists,
  anumber,
  any,
  aoutput,
  array,
  base64,
  base64Url,
  boolean,
  clean,
  coerce_exports,
  constantTimeEqual,
  createAuthEndpoint,
  createAuthMiddleware,
  createAuthorizationURL,
  createEmailVerificationToken,
  createHMAC,
  createHash,
  createHasher,
  createRemoteJWKSet,
  custom,
  date,
  db_exports,
  decodeJwt,
  deleteSessionCookie,
  email,
  exportJWK,
  generateKeyPair,
  generateRandomString,
  generateState,
  getBaseURL,
  getCurrentAdapter,
  getCurrentAuthContext,
  getDate,
  getEndpoints,
  getIp,
  getOrigin,
  getSession,
  getSessionFromCtx,
  getWebcryptoSubtle,
  handleOAuthUserInfo,
  importJWK,
  jwtVerify,
  literal,
  mergeSchema,
  ms,
  number,
  object,
  oidNist,
  optional,
  optionsMiddleware,
  originCheck,
  parseCookies,
  parseSetCookieHeader,
  parseState,
  parseUserOutput,
  record,
  refreshAccessToken,
  requestOnlySessionMiddleware,
  rotlBH,
  rotlBL,
  rotlSH,
  rotlSL,
  sec,
  serializeSignedCookie,
  sessionMiddleware,
  setCookieCache,
  setSessionCookie,
  setTokenUtil,
  split,
  string,
  stripSecureCookiePrefix,
  swap32IfBE,
  symmetricDecrypt,
  symmetricEncrypt,
  toZodSchema,
  u32,
  union,
  unknown,
  utf8ToBytes,
  validateAuthorizationCode,
  validatePassword
} from "./chunk-PXNVUWBG.js";
import "./chunk-NL6FM5KM.js";
import "./chunk-Z74B6BST.js";
import {
  betterFetch
} from "./chunk-2YLHI72I.js";
import "./chunk-NCEDCEOA.js";
import "./chunk-EGRHWZRV.js";
import {
  defaultRoles
} from "./chunk-CVSYFGLT.js";
import {
  createAccessControl,
  role
} from "./chunk-AW4XI7II.js";
import "./chunk-EGRHWZRV.js";
import {
  BASE_ERROR_CODES,
  BetterAuthError,
  defineErrorCodes,
  env,
  generateId,
  isProduction,
  logger,
  safeJSONParse
} from "./chunk-FX76KL3M.js";
import "./chunk-G3PMV62Z.js";

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/two-factor/client.mjs
var twoFactorClient = (options) => {
  return {
    id: "two-factor",
    $InferServerPlugin: {},
    atomListeners: [{
      matcher: (path) => path.startsWith("/two-factor/"),
      signal: "$sessionSignal"
    }],
    pathMethods: {
      "/two-factor/disable": "POST",
      "/two-factor/enable": "POST",
      "/two-factor/send-otp": "POST",
      "/two-factor/generate-backup-codes": "POST"
    },
    fetchPlugins: [{
      id: "two-factor",
      name: "two-factor",
      hooks: { async onSuccess(context) {
        if (context.data?.twoFactorRedirect) {
          if (options?.onTwoFactorRedirect) await options.onTwoFactorRedirect();
        }
      } }
    }]
  };
};

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/utils/plugin-helper.mjs
var getEndpointResponse = async (ctx) => {
  const returned = ctx.context.returned;
  if (!returned) return null;
  if (returned instanceof Response) {
    if (returned.status !== 200) return null;
    return await returned.clone().json();
  }
  if (returned instanceof APIError) return null;
  return returned;
};

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/admin/error-codes.mjs
var ADMIN_ERROR_CODES = defineErrorCodes({
  FAILED_TO_CREATE_USER: "Failed to create user",
  USER_ALREADY_EXISTS: "User already exists.",
  USER_ALREADY_EXISTS_USE_ANOTHER_EMAIL: "User already exists. Use another email.",
  YOU_CANNOT_BAN_YOURSELF: "You cannot ban yourself",
  YOU_ARE_NOT_ALLOWED_TO_CHANGE_USERS_ROLE: "You are not allowed to change users role",
  YOU_ARE_NOT_ALLOWED_TO_CREATE_USERS: "You are not allowed to create users",
  YOU_ARE_NOT_ALLOWED_TO_LIST_USERS: "You are not allowed to list users",
  YOU_ARE_NOT_ALLOWED_TO_LIST_USERS_SESSIONS: "You are not allowed to list users sessions",
  YOU_ARE_NOT_ALLOWED_TO_BAN_USERS: "You are not allowed to ban users",
  YOU_ARE_NOT_ALLOWED_TO_IMPERSONATE_USERS: "You are not allowed to impersonate users",
  YOU_ARE_NOT_ALLOWED_TO_REVOKE_USERS_SESSIONS: "You are not allowed to revoke users sessions",
  YOU_ARE_NOT_ALLOWED_TO_DELETE_USERS: "You are not allowed to delete users",
  YOU_ARE_NOT_ALLOWED_TO_SET_USERS_PASSWORD: "You are not allowed to set users password",
  BANNED_USER: "You have been banned from this application",
  YOU_ARE_NOT_ALLOWED_TO_GET_USER: "You are not allowed to get user",
  NO_DATA_TO_UPDATE: "No data to update",
  YOU_ARE_NOT_ALLOWED_TO_UPDATE_USERS: "You are not allowed to update users",
  YOU_CANNOT_REMOVE_YOURSELF: "You cannot remove yourself",
  YOU_ARE_NOT_ALLOWED_TO_SET_NON_EXISTENT_VALUE: "You are not allowed to set a non-existent role value",
  YOU_CANNOT_IMPERSONATE_ADMINS: "You cannot impersonate admins",
  INVALID_ROLE_TYPE: "Invalid role type"
});

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/admin/has-permission.mjs
var hasPermission = (input) => {
  if (input.userId && input.options?.adminUserIds?.includes(input.userId)) return true;
  if (!input.permissions && !input.permission) return false;
  const roles = (input.role || input.options?.defaultRole || "user").split(",");
  const acRoles = input.options?.roles || defaultRoles;
  for (const role2 of roles) if (acRoles[role2]?.authorize(input.permission ?? input.permissions)?.success) return true;
  return false;
};

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/admin/routes.mjs
var adminMiddleware = createAuthMiddleware(async (ctx) => {
  const session = await getSessionFromCtx(ctx);
  if (!session) throw new APIError("UNAUTHORIZED");
  return { session };
});
function parseRoles(roles) {
  return Array.isArray(roles) ? roles.join(",") : roles;
}
var setRoleBodySchema = object({
  userId: coerce_exports.string().meta({ description: "The user id" }),
  role: union([string().meta({ description: "The role to set. `admin` or `user` by default" }), array(string().meta({ description: "The roles to set. `admin` or `user` by default" }))]).meta({ description: "The role to set, this can be a string or an array of strings. Eg: `admin` or `[admin, user]`" })
});
var setRole = (opts) => createAuthEndpoint("/admin/set-role", {
  method: "POST",
  body: setRoleBodySchema,
  requireHeaders: true,
  use: [adminMiddleware],
  metadata: {
    openapi: {
      operationId: "setUserRole",
      summary: "Set the role of a user",
      description: "Set the role of a user",
      responses: { 200: {
        description: "User role updated",
        content: { "application/json": { schema: {
          type: "object",
          properties: { user: { $ref: "#/components/schemas/User" } }
        } } }
      } }
    },
    $Infer: { body: {} }
  }
}, async (ctx) => {
  if (!hasPermission({
    userId: ctx.context.session.user.id,
    role: ctx.context.session.user.role,
    options: opts,
    permissions: { user: ["set-role"] }
  })) throw new APIError("FORBIDDEN", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_CHANGE_USERS_ROLE });
  const roles = opts.roles;
  if (roles) {
    const inputRoles = Array.isArray(ctx.body.role) ? ctx.body.role : [ctx.body.role];
    for (const role2 of inputRoles) if (!roles[role2]) throw new APIError("BAD_REQUEST", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_SET_NON_EXISTENT_VALUE });
  }
  const updatedUser = await ctx.context.internalAdapter.updateUser(ctx.body.userId, { role: parseRoles(ctx.body.role) });
  return ctx.json({ user: updatedUser });
});
var getUserQuerySchema = object({ id: string().meta({ description: "The id of the User" }) });
var getUser = (opts) => createAuthEndpoint("/admin/get-user", {
  method: "GET",
  query: getUserQuerySchema,
  use: [adminMiddleware],
  metadata: { openapi: {
    operationId: "getUser",
    summary: "Get an existing user",
    description: "Get an existing user",
    responses: { 200: {
      description: "User",
      content: { "application/json": { schema: {
        type: "object",
        properties: { user: { $ref: "#/components/schemas/User" } }
      } } }
    } }
  } }
}, async (ctx) => {
  const { id } = ctx.query;
  if (!hasPermission({
    userId: ctx.context.session.user.id,
    role: ctx.context.session.user.role,
    options: opts,
    permissions: { user: ["get"] }
  })) throw ctx.error("FORBIDDEN", {
    message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_GET_USER,
    code: "YOU_ARE_NOT_ALLOWED_TO_GET_USER"
  });
  const user = await ctx.context.internalAdapter.findUserById(id);
  if (!user) throw new APIError("NOT_FOUND", { message: BASE_ERROR_CODES.USER_NOT_FOUND });
  return parseUserOutput(ctx.context.options, user);
});
var createUserBodySchema = object({
  email: string().meta({ description: "The email of the user" }),
  password: string().meta({ description: "The password of the user" }),
  name: string().meta({ description: "The name of the user" }),
  role: union([string().meta({ description: "The role of the user" }), array(string().meta({ description: "The roles of user" }))]).optional().meta({ description: `A string or array of strings representing the roles to apply to the new user. Eg: "user"` }),
  data: record(string(), any()).optional().meta({ description: "Extra fields for the user. Including custom additional fields." })
});
var createUser = (opts) => createAuthEndpoint("/admin/create-user", {
  method: "POST",
  body: createUserBodySchema,
  metadata: {
    openapi: {
      operationId: "createUser",
      summary: "Create a new user",
      description: "Create a new user",
      responses: { 200: {
        description: "User created",
        content: { "application/json": { schema: {
          type: "object",
          properties: { user: { $ref: "#/components/schemas/User" } }
        } } }
      } }
    },
    $Infer: { body: {} }
  }
}, async (ctx) => {
  const session = await getSessionFromCtx(ctx);
  if (!session && (ctx.request || ctx.headers)) throw ctx.error("UNAUTHORIZED");
  if (session) {
    if (!hasPermission({
      userId: session.user.id,
      role: session.user.role,
      options: opts,
      permissions: { user: ["create"] }
    })) throw new APIError("FORBIDDEN", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_CREATE_USERS });
  }
  const email2 = ctx.body.email.toLowerCase();
  if (!email().safeParse(email2).success) throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.INVALID_EMAIL });
  if (await ctx.context.internalAdapter.findUserByEmail(email2)) throw new APIError("BAD_REQUEST", { message: ADMIN_ERROR_CODES.USER_ALREADY_EXISTS_USE_ANOTHER_EMAIL });
  const user = await ctx.context.internalAdapter.createUser({
    email: email2,
    name: ctx.body.name,
    role: (ctx.body.role && parseRoles(ctx.body.role)) ?? opts?.defaultRole ?? "user",
    ...ctx.body.data
  });
  if (!user) throw new APIError("INTERNAL_SERVER_ERROR", { message: ADMIN_ERROR_CODES.FAILED_TO_CREATE_USER });
  const hashedPassword = await ctx.context.password.hash(ctx.body.password);
  await ctx.context.internalAdapter.linkAccount({
    accountId: user.id,
    providerId: "credential",
    password: hashedPassword,
    userId: user.id
  });
  return ctx.json({ user });
});
var adminUpdateUserBodySchema = object({
  userId: coerce_exports.string().meta({ description: "The user id" }),
  data: record(any(), any()).meta({ description: "The user data to update" })
});
var adminUpdateUser = (opts) => createAuthEndpoint("/admin/update-user", {
  method: "POST",
  body: adminUpdateUserBodySchema,
  use: [adminMiddleware],
  metadata: { openapi: {
    operationId: "updateUser",
    summary: "Update a user",
    description: "Update a user's details",
    responses: { 200: {
      description: "User updated",
      content: { "application/json": { schema: {
        type: "object",
        properties: { user: { $ref: "#/components/schemas/User" } }
      } } }
    } }
  } }
}, async (ctx) => {
  if (!hasPermission({
    userId: ctx.context.session.user.id,
    role: ctx.context.session.user.role,
    options: opts,
    permissions: { user: ["update"] }
  })) throw ctx.error("FORBIDDEN", {
    message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_UPDATE_USERS,
    code: "YOU_ARE_NOT_ALLOWED_TO_UPDATE_USERS"
  });
  if (Object.keys(ctx.body.data).length === 0) throw new APIError("BAD_REQUEST", { message: ADMIN_ERROR_CODES.NO_DATA_TO_UPDATE });
  if (Object.prototype.hasOwnProperty.call(ctx.body.data, "role")) {
    if (!hasPermission({
      userId: ctx.context.session.user.id,
      role: ctx.context.session.user.role,
      options: opts,
      permissions: { user: ["set-role"] }
    })) throw new APIError("FORBIDDEN", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_CHANGE_USERS_ROLE });
    const roleValue = ctx.body.data.role;
    const inputRoles = Array.isArray(roleValue) ? roleValue : [roleValue];
    for (const role2 of inputRoles) {
      if (typeof role2 !== "string") throw new APIError("BAD_REQUEST", { message: ADMIN_ERROR_CODES.INVALID_ROLE_TYPE });
      if (opts.roles && !opts.roles[role2]) throw new APIError("BAD_REQUEST", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_SET_NON_EXISTENT_VALUE });
    }
    ctx.body.data.role = parseRoles(inputRoles);
  }
  const updatedUser = await ctx.context.internalAdapter.updateUser(ctx.body.userId, ctx.body.data);
  return ctx.json(updatedUser);
});
var listUsersQuerySchema = object({
  searchValue: string().optional().meta({ description: 'The value to search for. Eg: "some name"' }),
  searchField: _enum(["email", "name"]).meta({ description: 'The field to search in, defaults to email. Can be `email` or `name`. Eg: "name"' }).optional(),
  searchOperator: _enum([
    "contains",
    "starts_with",
    "ends_with"
  ]).meta({ description: 'The operator to use for the search. Can be `contains`, `starts_with` or `ends_with`. Eg: "contains"' }).optional(),
  limit: string().meta({ description: "The number of users to return" }).or(number()).optional(),
  offset: string().meta({ description: "The offset to start from" }).or(number()).optional(),
  sortBy: string().meta({ description: "The field to sort by" }).optional(),
  sortDirection: _enum(["asc", "desc"]).meta({ description: "The direction to sort by" }).optional(),
  filterField: string().meta({ description: "The field to filter by" }).optional(),
  filterValue: string().meta({ description: "The value to filter by" }).or(number()).or(boolean()).optional(),
  filterOperator: _enum([
    "eq",
    "ne",
    "lt",
    "lte",
    "gt",
    "gte",
    "contains"
  ]).meta({ description: "The operator to use for the filter" }).optional()
});
var listUsers = (opts) => createAuthEndpoint("/admin/list-users", {
  method: "GET",
  use: [adminMiddleware],
  query: listUsersQuerySchema,
  metadata: { openapi: {
    operationId: "listUsers",
    summary: "List users",
    description: "List users",
    responses: { 200: {
      description: "List of users",
      content: { "application/json": { schema: {
        type: "object",
        properties: {
          users: {
            type: "array",
            items: { $ref: "#/components/schemas/User" }
          },
          total: { type: "number" },
          limit: { type: "number" },
          offset: { type: "number" }
        },
        required: ["users", "total"]
      } } }
    } }
  } }
}, async (ctx) => {
  const session = ctx.context.session;
  if (!hasPermission({
    userId: ctx.context.session.user.id,
    role: session.user.role,
    options: opts,
    permissions: { user: ["list"] }
  })) throw new APIError("FORBIDDEN", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_LIST_USERS });
  const where = [];
  if (ctx.query?.searchValue) where.push({
    field: ctx.query.searchField || "email",
    operator: ctx.query.searchOperator || "contains",
    value: ctx.query.searchValue
  });
  if (ctx.query?.filterValue) where.push({
    field: ctx.query.filterField || "email",
    operator: ctx.query.filterOperator || "eq",
    value: ctx.query.filterValue
  });
  try {
    const users = await ctx.context.internalAdapter.listUsers(Number(ctx.query?.limit) || void 0, Number(ctx.query?.offset) || void 0, ctx.query?.sortBy ? {
      field: ctx.query.sortBy,
      direction: ctx.query.sortDirection || "asc"
    } : void 0, where.length ? where : void 0);
    const total = await ctx.context.internalAdapter.countTotalUsers(where.length ? where : void 0);
    return ctx.json({
      users,
      total,
      limit: Number(ctx.query?.limit) || void 0,
      offset: Number(ctx.query?.offset) || void 0
    });
  } catch {
    return ctx.json({
      users: [],
      total: 0
    });
  }
});
var listUserSessionsBodySchema = object({ userId: coerce_exports.string().meta({ description: "The user id" }) });
var listUserSessions = (opts) => createAuthEndpoint("/admin/list-user-sessions", {
  method: "POST",
  use: [adminMiddleware],
  body: listUserSessionsBodySchema,
  metadata: { openapi: {
    operationId: "listUserSessions",
    summary: "List user sessions",
    description: "List user sessions",
    responses: { 200: {
      description: "List of user sessions",
      content: { "application/json": { schema: {
        type: "object",
        properties: { sessions: {
          type: "array",
          items: { $ref: "#/components/schemas/Session" }
        } }
      } } }
    } }
  } }
}, async (ctx) => {
  const session = ctx.context.session;
  if (!hasPermission({
    userId: ctx.context.session.user.id,
    role: session.user.role,
    options: opts,
    permissions: { session: ["list"] }
  })) throw new APIError("FORBIDDEN", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_LIST_USERS_SESSIONS });
  return { sessions: await ctx.context.internalAdapter.listSessions(ctx.body.userId) };
});
var unbanUserBodySchema = object({ userId: coerce_exports.string().meta({ description: "The user id" }) });
var unbanUser = (opts) => createAuthEndpoint("/admin/unban-user", {
  method: "POST",
  body: unbanUserBodySchema,
  use: [adminMiddleware],
  metadata: { openapi: {
    operationId: "unbanUser",
    summary: "Unban a user",
    description: "Unban a user",
    responses: { 200: {
      description: "User unbanned",
      content: { "application/json": { schema: {
        type: "object",
        properties: { user: { $ref: "#/components/schemas/User" } }
      } } }
    } }
  } }
}, async (ctx) => {
  const session = ctx.context.session;
  if (!hasPermission({
    userId: ctx.context.session.user.id,
    role: session.user.role,
    options: opts,
    permissions: { user: ["ban"] }
  })) throw new APIError("FORBIDDEN", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_BAN_USERS });
  const user = await ctx.context.internalAdapter.updateUser(ctx.body.userId, {
    banned: false,
    banExpires: null,
    banReason: null,
    updatedAt: /* @__PURE__ */ new Date()
  });
  return ctx.json({ user });
});
var banUserBodySchema = object({
  userId: coerce_exports.string().meta({ description: "The user id" }),
  banReason: string().meta({ description: "The reason for the ban" }).optional(),
  banExpiresIn: number().meta({ description: "The number of seconds until the ban expires" }).optional()
});
var banUser = (opts) => createAuthEndpoint("/admin/ban-user", {
  method: "POST",
  body: banUserBodySchema,
  use: [adminMiddleware],
  metadata: { openapi: {
    operationId: "banUser",
    summary: "Ban a user",
    description: "Ban a user",
    responses: { 200: {
      description: "User banned",
      content: { "application/json": { schema: {
        type: "object",
        properties: { user: { $ref: "#/components/schemas/User" } }
      } } }
    } }
  } }
}, async (ctx) => {
  const session = ctx.context.session;
  if (!hasPermission({
    userId: ctx.context.session.user.id,
    role: session.user.role,
    options: opts,
    permissions: { user: ["ban"] }
  })) throw new APIError("FORBIDDEN", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_BAN_USERS });
  if (!await ctx.context.internalAdapter.findUserById(ctx.body.userId)) throw new APIError("NOT_FOUND", { message: BASE_ERROR_CODES.USER_NOT_FOUND });
  if (ctx.body.userId === ctx.context.session.user.id) throw new APIError("BAD_REQUEST", { message: ADMIN_ERROR_CODES.YOU_CANNOT_BAN_YOURSELF });
  const user = await ctx.context.internalAdapter.updateUser(ctx.body.userId, {
    banned: true,
    banReason: ctx.body.banReason || opts?.defaultBanReason || "No reason",
    banExpires: ctx.body.banExpiresIn ? getDate(ctx.body.banExpiresIn, "sec") : opts?.defaultBanExpiresIn ? getDate(opts.defaultBanExpiresIn, "sec") : void 0,
    updatedAt: /* @__PURE__ */ new Date()
  });
  await ctx.context.internalAdapter.deleteSessions(ctx.body.userId);
  return ctx.json({ user });
});
var impersonateUserBodySchema = object({ userId: coerce_exports.string().meta({ description: "The user id" }) });
var impersonateUser = (opts) => createAuthEndpoint("/admin/impersonate-user", {
  method: "POST",
  body: impersonateUserBodySchema,
  use: [adminMiddleware],
  metadata: { openapi: {
    operationId: "impersonateUser",
    summary: "Impersonate a user",
    description: "Impersonate a user",
    responses: { 200: {
      description: "Impersonation session created",
      content: { "application/json": { schema: {
        type: "object",
        properties: {
          session: { $ref: "#/components/schemas/Session" },
          user: { $ref: "#/components/schemas/User" }
        }
      } } }
    } }
  } }
}, async (ctx) => {
  if (!hasPermission({
    userId: ctx.context.session.user.id,
    role: ctx.context.session.user.role,
    options: opts,
    permissions: { user: ["impersonate"] }
  })) throw new APIError("FORBIDDEN", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_IMPERSONATE_USERS });
  const targetUser = await ctx.context.internalAdapter.findUserById(ctx.body.userId);
  if (!targetUser) throw new APIError("NOT_FOUND", { message: "User not found" });
  const adminRoles = (Array.isArray(opts.adminRoles) ? opts.adminRoles : opts.adminRoles?.split(",") || []).map((role2) => role2.trim());
  const targetUserRole = (targetUser.role || opts.defaultRole || "user").split(",");
  if (opts.allowImpersonatingAdmins !== true && (targetUserRole.some((role2) => adminRoles.includes(role2)) || opts.adminUserIds?.includes(targetUser.id))) throw new APIError("FORBIDDEN", { message: ADMIN_ERROR_CODES.YOU_CANNOT_IMPERSONATE_ADMINS });
  const session = await ctx.context.internalAdapter.createSession(targetUser.id, true, {
    impersonatedBy: ctx.context.session.user.id,
    expiresAt: opts?.impersonationSessionDuration ? getDate(opts.impersonationSessionDuration, "sec") : getDate(3600, "sec")
  }, true);
  if (!session) throw new APIError("INTERNAL_SERVER_ERROR", { message: ADMIN_ERROR_CODES.FAILED_TO_CREATE_USER });
  const authCookies = ctx.context.authCookies;
  deleteSessionCookie(ctx);
  const dontRememberMeCookie = await ctx.getSignedCookie(ctx.context.authCookies.dontRememberToken.name, ctx.context.secret);
  const adminCookieProp = ctx.context.createAuthCookie("admin_session");
  await ctx.setSignedCookie(adminCookieProp.name, `${ctx.context.session.session.token}:${dontRememberMeCookie || ""}`, ctx.context.secret, authCookies.sessionToken.options);
  await setSessionCookie(ctx, {
    session,
    user: targetUser
  }, true);
  return ctx.json({
    session,
    user: targetUser
  });
});
var stopImpersonating = () => createAuthEndpoint("/admin/stop-impersonating", {
  method: "POST",
  requireHeaders: true
}, async (ctx) => {
  const session = await getSessionFromCtx(ctx);
  if (!session) throw new APIError("UNAUTHORIZED");
  if (!session.session.impersonatedBy) throw new APIError("BAD_REQUEST", { message: "You are not impersonating anyone" });
  const user = await ctx.context.internalAdapter.findUserById(session.session.impersonatedBy);
  if (!user) throw new APIError("INTERNAL_SERVER_ERROR", { message: "Failed to find user" });
  const adminCookieName = ctx.context.createAuthCookie("admin_session").name;
  const adminCookie = await ctx.getSignedCookie(adminCookieName, ctx.context.secret);
  if (!adminCookie) throw new APIError("INTERNAL_SERVER_ERROR", { message: "Failed to find admin session" });
  const [adminSessionToken, dontRememberMeCookie] = adminCookie?.split(":");
  const adminSession = await ctx.context.internalAdapter.findSession(adminSessionToken);
  if (!adminSession || adminSession.session.userId !== user.id) throw new APIError("INTERNAL_SERVER_ERROR", { message: "Failed to find admin session" });
  await ctx.context.internalAdapter.deleteSession(session.session.token);
  await setSessionCookie(ctx, adminSession, !!dontRememberMeCookie);
  await ctx.setSignedCookie(adminCookieName, "", ctx.context.secret, {
    ...ctx.context.authCookies.sessionToken.options,
    maxAge: 0
  });
  return ctx.json(adminSession);
});
var revokeUserSessionBodySchema = object({ sessionToken: string().meta({ description: "The session token" }) });
var revokeUserSession = (opts) => createAuthEndpoint("/admin/revoke-user-session", {
  method: "POST",
  body: revokeUserSessionBodySchema,
  use: [adminMiddleware],
  metadata: { openapi: {
    operationId: "revokeUserSession",
    summary: "Revoke a user session",
    description: "Revoke a user session",
    responses: { 200: {
      description: "Session revoked",
      content: { "application/json": { schema: {
        type: "object",
        properties: { success: { type: "boolean" } }
      } } }
    } }
  } }
}, async (ctx) => {
  const session = ctx.context.session;
  if (!hasPermission({
    userId: ctx.context.session.user.id,
    role: session.user.role,
    options: opts,
    permissions: { session: ["revoke"] }
  })) throw new APIError("FORBIDDEN", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_REVOKE_USERS_SESSIONS });
  await ctx.context.internalAdapter.deleteSession(ctx.body.sessionToken);
  return ctx.json({ success: true });
});
var revokeUserSessionsBodySchema = object({ userId: coerce_exports.string().meta({ description: "The user id" }) });
var revokeUserSessions = (opts) => createAuthEndpoint("/admin/revoke-user-sessions", {
  method: "POST",
  body: revokeUserSessionsBodySchema,
  use: [adminMiddleware],
  metadata: { openapi: {
    operationId: "revokeUserSessions",
    summary: "Revoke all user sessions",
    description: "Revoke all user sessions",
    responses: { 200: {
      description: "Sessions revoked",
      content: { "application/json": { schema: {
        type: "object",
        properties: { success: { type: "boolean" } }
      } } }
    } }
  } }
}, async (ctx) => {
  const session = ctx.context.session;
  if (!hasPermission({
    userId: ctx.context.session.user.id,
    role: session.user.role,
    options: opts,
    permissions: { session: ["revoke"] }
  })) throw new APIError("FORBIDDEN", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_REVOKE_USERS_SESSIONS });
  await ctx.context.internalAdapter.deleteSessions(ctx.body.userId);
  return ctx.json({ success: true });
});
var removeUserBodySchema = object({ userId: coerce_exports.string().meta({ description: "The user id" }) });
var removeUser = (opts) => createAuthEndpoint("/admin/remove-user", {
  method: "POST",
  body: removeUserBodySchema,
  use: [adminMiddleware],
  metadata: { openapi: {
    operationId: "removeUser",
    summary: "Remove a user",
    description: "Delete a user and all their sessions and accounts. Cannot be undone.",
    responses: { 200: {
      description: "User removed",
      content: { "application/json": { schema: {
        type: "object",
        properties: { success: { type: "boolean" } }
      } } }
    } }
  } }
}, async (ctx) => {
  const session = ctx.context.session;
  if (!hasPermission({
    userId: ctx.context.session.user.id,
    role: session.user.role,
    options: opts,
    permissions: { user: ["delete"] }
  })) throw new APIError("FORBIDDEN", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_DELETE_USERS });
  if (ctx.body.userId === ctx.context.session.user.id) throw new APIError("BAD_REQUEST", { message: ADMIN_ERROR_CODES.YOU_CANNOT_REMOVE_YOURSELF });
  if (!await ctx.context.internalAdapter.findUserById(ctx.body.userId)) throw new APIError("NOT_FOUND", { message: "User not found" });
  await ctx.context.internalAdapter.deleteUser(ctx.body.userId);
  return ctx.json({ success: true });
});
var setUserPasswordBodySchema = object({
  newPassword: string().nonempty("newPassword cannot be empty").meta({ description: "The new password" }),
  userId: coerce_exports.string().nonempty("userId cannot be empty").meta({ description: "The user id" })
});
var setUserPassword = (opts) => createAuthEndpoint("/admin/set-user-password", {
  method: "POST",
  body: setUserPasswordBodySchema,
  use: [adminMiddleware],
  metadata: { openapi: {
    operationId: "setUserPassword",
    summary: "Set a user's password",
    description: "Set a user's password",
    responses: { 200: {
      description: "Password set",
      content: { "application/json": { schema: {
        type: "object",
        properties: { status: { type: "boolean" } }
      } } }
    } }
  } }
}, async (ctx) => {
  if (!hasPermission({
    userId: ctx.context.session.user.id,
    role: ctx.context.session.user.role,
    options: opts,
    permissions: { user: ["set-password"] }
  })) throw new APIError("FORBIDDEN", { message: ADMIN_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_SET_USERS_PASSWORD });
  const { newPassword, userId } = ctx.body;
  const minPasswordLength = ctx.context.password.config.minPasswordLength;
  if (newPassword.length < minPasswordLength) {
    ctx.context.logger.error("Password is too short");
    throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.PASSWORD_TOO_SHORT });
  }
  const maxPasswordLength = ctx.context.password.config.maxPasswordLength;
  if (newPassword.length > maxPasswordLength) {
    ctx.context.logger.error("Password is too long");
    throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.PASSWORD_TOO_LONG });
  }
  const hashedPassword = await ctx.context.password.hash(newPassword);
  await ctx.context.internalAdapter.updatePassword(userId, hashedPassword);
  return ctx.json({ status: true });
});
var userHasPermissionBodySchema = object({
  userId: coerce_exports.string().optional().meta({ description: `The user id. Eg: "user-id"` }),
  role: string().optional().meta({ description: `The role to check permission for. Eg: "admin"` })
}).and(union([object({
  permission: record(string(), array(string())),
  permissions: _undefined()
}), object({
  permission: _undefined(),
  permissions: record(string(), array(string()))
})]));
var userHasPermission = (opts) => {
  return createAuthEndpoint("/admin/has-permission", {
    method: "POST",
    body: userHasPermissionBodySchema,
    metadata: {
      openapi: {
        description: "Check if the user has permission",
        requestBody: { content: { "application/json": { schema: {
          type: "object",
          properties: {
            permission: {
              type: "object",
              description: "The permission to check",
              deprecated: true
            },
            permissions: {
              type: "object",
              description: "The permission to check"
            }
          },
          required: ["permissions"]
        } } } },
        responses: { "200": {
          description: "Success",
          content: { "application/json": { schema: {
            type: "object",
            properties: {
              error: { type: "string" },
              success: { type: "boolean" }
            },
            required: ["success"]
          } } }
        } }
      },
      $Infer: { body: {} }
    }
  }, async (ctx) => {
    if (!ctx.body?.permission && !ctx.body?.permissions) throw new APIError("BAD_REQUEST", { message: "invalid permission check. no permission(s) were passed." });
    const session = await getSessionFromCtx(ctx);
    if (!session && (ctx.request || ctx.headers)) throw new APIError("UNAUTHORIZED");
    if (!session && !ctx.body.userId && !ctx.body.role) throw new APIError("BAD_REQUEST", { message: "user id or role is required" });
    const user = session?.user || (ctx.body.role ? {
      id: ctx.body.userId || "",
      role: ctx.body.role
    } : null) || (ctx.body.userId ? await ctx.context.internalAdapter.findUserById(ctx.body.userId) : null);
    if (!user) throw new APIError("BAD_REQUEST", { message: "user not found" });
    const result = hasPermission({
      userId: user.id,
      role: user.role,
      options: opts,
      permissions: ctx.body.permissions ?? ctx.body.permission
    });
    return ctx.json({
      error: null,
      success: result
    });
  });
};

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/admin/schema.mjs
var schema = {
  user: { fields: {
    role: {
      type: "string",
      required: false,
      input: false
    },
    banned: {
      type: "boolean",
      defaultValue: false,
      required: false,
      input: false
    },
    banReason: {
      type: "string",
      required: false,
      input: false
    },
    banExpires: {
      type: "date",
      required: false,
      input: false
    }
  } },
  session: { fields: { impersonatedBy: {
    type: "string",
    required: false
  } } }
};

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/admin/admin.mjs
var admin = (options) => {
  const opts = {
    ...options || {},
    defaultRole: options?.defaultRole ?? "user",
    adminRoles: options?.adminRoles ?? ["admin"],
    bannedUserMessage: options?.bannedUserMessage ?? "You have been banned from this application. Please contact support if you believe this is an error."
  };
  if (options?.adminRoles) {
    const invalidRoles = (Array.isArray(options.adminRoles) ? options.adminRoles : [...options.adminRoles.split(",")]).filter((role2) => !Object.keys(options?.roles || defaultRoles).map((r) => r.toLowerCase()).includes(role2.toLowerCase()));
    if (invalidRoles.length > 0) throw new BetterAuthError(`Invalid admin roles: ${invalidRoles.join(", ")}. Admin roles must be defined in the 'roles' configuration.`);
  }
  return {
    id: "admin",
    init() {
      return { options: { databaseHooks: {
        user: { create: { async before(user) {
          return { data: {
            role: options?.defaultRole ?? "user",
            ...user
          } };
        } } },
        session: { create: { async before(session, ctx) {
          if (!ctx) return;
          const user = await ctx.context.internalAdapter.findUserById(session.userId);
          if (user.banned) {
            if (user.banExpires && new Date(user.banExpires).getTime() < Date.now()) {
              await ctx.context.internalAdapter.updateUser(session.userId, {
                banned: false,
                banReason: null,
                banExpires: null
              });
              return;
            }
            if (ctx && (ctx.path.startsWith("/callback") || ctx.path.startsWith("/oauth2/callback"))) {
              const redirectURI = ctx.context.options.onAPIError?.errorURL || `${ctx.context.baseURL}/error`;
              throw ctx.redirect(`${redirectURI}?error=banned&error_description=${opts.bannedUserMessage}`);
            }
            throw new APIError("FORBIDDEN", {
              message: opts.bannedUserMessage,
              code: "BANNED_USER"
            });
          }
        } } }
      } } };
    },
    hooks: { after: [{
      matcher(context) {
        return context.path === "/list-sessions";
      },
      handler: createAuthMiddleware(async (ctx) => {
        const response = await getEndpointResponse(ctx);
        if (!response) return;
        const newJson = response.filter((session) => {
          return !session.impersonatedBy;
        });
        return ctx.json(newJson);
      })
    }] },
    endpoints: {
      setRole: setRole(opts),
      getUser: getUser(opts),
      createUser: createUser(opts),
      adminUpdateUser: adminUpdateUser(opts),
      listUsers: listUsers(opts),
      listUserSessions: listUserSessions(opts),
      unbanUser: unbanUser(opts),
      banUser: banUser(opts),
      impersonateUser: impersonateUser(opts),
      stopImpersonating: stopImpersonating(),
      revokeUserSession: revokeUserSession(opts),
      revokeUserSessions: revokeUserSessions(opts),
      removeUser: removeUser(opts),
      setUserPassword: setUserPassword(opts),
      userHasPermission: userHasPermission(opts)
    },
    $ERROR_CODES: ADMIN_ERROR_CODES,
    schema: mergeSchema(schema, opts.schema),
    options
  };
};

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/anonymous/error-codes.mjs
var ANONYMOUS_ERROR_CODES = defineErrorCodes({
  INVALID_EMAIL_FORMAT: "Email was not generated in a valid format",
  FAILED_TO_CREATE_USER: "Failed to create user",
  COULD_NOT_CREATE_SESSION: "Could not create session",
  ANONYMOUS_USERS_CANNOT_SIGN_IN_AGAIN_ANONYMOUSLY: "Anonymous users cannot sign in again anonymously"
});

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/anonymous/schema.mjs
var schema2 = { user: { fields: { isAnonymous: {
  type: "boolean",
  required: false,
  input: false,
  defaultValue: false
} } } };

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/anonymous/index.mjs
async function getAnonUserEmail(options) {
  const customEmail = await options?.generateRandomEmail?.();
  if (customEmail) {
    if (!email().safeParse(customEmail).success) throw new APIError("BAD_REQUEST", { message: ANONYMOUS_ERROR_CODES.INVALID_EMAIL_FORMAT });
    return customEmail;
  }
  const id = generateId();
  if (options?.emailDomainName) return `temp-${id}@${options.emailDomainName}`;
  return `temp@${id}.com`;
}
var anonymous = (options) => {
  return {
    id: "anonymous",
    endpoints: { signInAnonymous: createAuthEndpoint("/sign-in/anonymous", {
      method: "POST",
      metadata: { openapi: {
        description: "Sign in anonymously",
        responses: { 200: {
          description: "Sign in anonymously",
          content: { "application/json": { schema: {
            type: "object",
            properties: {
              user: { $ref: "#/components/schemas/User" },
              session: { $ref: "#/components/schemas/Session" }
            }
          } } }
        } }
      } }
    }, async (ctx) => {
      if ((await getSessionFromCtx(ctx, { disableRefresh: true }))?.user.isAnonymous) throw new APIError("BAD_REQUEST", { message: ANONYMOUS_ERROR_CODES.ANONYMOUS_USERS_CANNOT_SIGN_IN_AGAIN_ANONYMOUSLY });
      const email2 = await getAnonUserEmail(options);
      const name = await options?.generateName?.(ctx) || "Anonymous";
      const newUser = await ctx.context.internalAdapter.createUser({
        email: email2,
        emailVerified: false,
        isAnonymous: true,
        name,
        createdAt: /* @__PURE__ */ new Date(),
        updatedAt: /* @__PURE__ */ new Date()
      });
      if (!newUser) throw ctx.error("INTERNAL_SERVER_ERROR", { message: ANONYMOUS_ERROR_CODES.FAILED_TO_CREATE_USER });
      const session = await ctx.context.internalAdapter.createSession(newUser.id);
      if (!session) return ctx.json(null, {
        status: 400,
        body: { message: ANONYMOUS_ERROR_CODES.COULD_NOT_CREATE_SESSION }
      });
      await setSessionCookie(ctx, {
        session,
        user: newUser
      });
      return ctx.json({
        token: session.token,
        user: {
          id: newUser.id,
          email: newUser.email,
          emailVerified: newUser.emailVerified,
          name: newUser.name,
          createdAt: newUser.createdAt,
          updatedAt: newUser.updatedAt
        }
      });
    }) },
    hooks: { after: [{
      matcher(ctx) {
        return ctx.path?.startsWith("/sign-in") || ctx.path?.startsWith("/sign-up") || ctx.path?.startsWith("/callback") || ctx.path?.startsWith("/oauth2/callback") || ctx.path?.startsWith("/magic-link/verify") || ctx.path?.startsWith("/email-otp/verify-email") || ctx.path?.startsWith("/one-tap/callback") || ctx.path?.startsWith("/passkey/verify-authentication") || ctx.path?.startsWith("/phone-number/verify") || false;
      },
      handler: createAuthMiddleware(async (ctx) => {
        const setCookie = ctx.context.responseHeaders?.get("set-cookie");
        const sessionTokenName = ctx.context.authCookies.sessionToken.name;
        if (!parseSetCookieHeader(setCookie || "").get(sessionTokenName)?.value.split(".")[0]) return;
        const session = await getSessionFromCtx(ctx, { disableRefresh: true });
        if (!session || !session.user.isAnonymous) return;
        if (ctx.path === "/sign-in/anonymous" && !ctx.context.newSession) throw new APIError("BAD_REQUEST", { message: ANONYMOUS_ERROR_CODES.ANONYMOUS_USERS_CANNOT_SIGN_IN_AGAIN_ANONYMOUSLY });
        const newSession = ctx.context.newSession;
        if (!newSession) return;
        if (options?.onLinkAccount) await options?.onLinkAccount?.({
          anonymousUser: session,
          newUser: newSession,
          ctx
        });
        if (!options?.disableDeleteAnonymousUser) await ctx.context.internalAdapter.deleteUser(session.user.id);
      })
    }] },
    options,
    schema: mergeSchema(schema2, options?.schema),
    $ERROR_CODES: ANONYMOUS_ERROR_CODES
  };
};

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/api-key/adapter.mjs
function getStorageKeyByHashedKey(hashedKey) {
  return `api-key:${hashedKey}`;
}
function getStorageKeyById(id) {
  return `api-key:by-id:${id}`;
}
function getStorageKeyByUserId(userId) {
  return `api-key:by-user:${userId}`;
}
function serializeApiKey(apiKey2) {
  return JSON.stringify({
    ...apiKey2,
    createdAt: apiKey2.createdAt.toISOString(),
    updatedAt: apiKey2.updatedAt.toISOString(),
    expiresAt: apiKey2.expiresAt?.toISOString() ?? null,
    lastRefillAt: apiKey2.lastRefillAt?.toISOString() ?? null,
    lastRequest: apiKey2.lastRequest?.toISOString() ?? null
  });
}
function deserializeApiKey(data) {
  if (!data || typeof data !== "string") return null;
  try {
    const parsed = JSON.parse(data);
    return {
      ...parsed,
      createdAt: new Date(parsed.createdAt),
      updatedAt: new Date(parsed.updatedAt),
      expiresAt: parsed.expiresAt ? new Date(parsed.expiresAt) : null,
      lastRefillAt: parsed.lastRefillAt ? new Date(parsed.lastRefillAt) : null,
      lastRequest: parsed.lastRequest ? new Date(parsed.lastRequest) : null
    };
  } catch {
    return null;
  }
}
function getStorageInstance(ctx, opts) {
  if (opts.customStorage) return opts.customStorage;
  return ctx.context.secondaryStorage || null;
}
function calculateTTL(apiKey2) {
  if (apiKey2.expiresAt) {
    const now = Date.now();
    const expiresAt = new Date(apiKey2.expiresAt).getTime();
    const ttlSeconds = Math.floor((expiresAt - now) / 1e3);
    if (ttlSeconds > 0) return ttlSeconds;
  }
}
async function getApiKeyFromStorage(ctx, hashedKey, storage) {
  const key = getStorageKeyByHashedKey(hashedKey);
  return deserializeApiKey(await storage.get(key));
}
async function getApiKeyByIdFromStorage(ctx, id, storage) {
  const key = getStorageKeyById(id);
  return deserializeApiKey(await storage.get(key));
}
async function setApiKeyInStorage(ctx, apiKey2, storage, ttl) {
  const serialized = serializeApiKey(apiKey2);
  const hashedKey = apiKey2.key;
  const id = apiKey2.id;
  await storage.set(getStorageKeyByHashedKey(hashedKey), serialized, ttl);
  await storage.set(getStorageKeyById(id), serialized, ttl);
  const userKey = getStorageKeyByUserId(apiKey2.userId);
  const userListData = await storage.get(userKey);
  let userIds = [];
  if (userListData && typeof userListData === "string") try {
    userIds = JSON.parse(userListData);
  } catch {
    userIds = [];
  }
  else if (Array.isArray(userListData)) userIds = userListData;
  if (!userIds.includes(id)) {
    userIds.push(id);
    await storage.set(userKey, JSON.stringify(userIds));
  }
}
async function deleteApiKeyFromStorage(ctx, apiKey2, storage) {
  const hashedKey = apiKey2.key;
  const id = apiKey2.id;
  const userId = apiKey2.userId;
  await storage.delete(getStorageKeyByHashedKey(hashedKey));
  await storage.delete(getStorageKeyById(id));
  const userKey = getStorageKeyByUserId(userId);
  const userListData = await storage.get(userKey);
  let userIds = [];
  if (userListData && typeof userListData === "string") try {
    userIds = JSON.parse(userListData);
  } catch {
    userIds = [];
  }
  else if (Array.isArray(userListData)) userIds = userListData;
  const filteredIds = userIds.filter((keyId) => keyId !== id);
  if (filteredIds.length === 0) await storage.delete(userKey);
  else await storage.set(userKey, JSON.stringify(filteredIds));
}
async function getApiKey(ctx, hashedKey, opts) {
  const storage = getStorageInstance(ctx, opts);
  if (opts.storage === "database") return await ctx.context.adapter.findOne({
    model: "apikey",
    where: [{
      field: "key",
      value: hashedKey
    }]
  });
  if (opts.storage === "secondary-storage" && opts.fallbackToDatabase) {
    if (storage) {
      const cached = await getApiKeyFromStorage(ctx, hashedKey, storage);
      if (cached) return cached;
    }
    const dbKey = await ctx.context.adapter.findOne({
      model: "apikey",
      where: [{
        field: "key",
        value: hashedKey
      }]
    });
    if (dbKey && storage) await setApiKeyInStorage(ctx, dbKey, storage, calculateTTL(dbKey));
    return dbKey;
  }
  if (opts.storage === "secondary-storage") {
    if (!storage) return null;
    return await getApiKeyFromStorage(ctx, hashedKey, storage);
  }
  return await ctx.context.adapter.findOne({
    model: "apikey",
    where: [{
      field: "key",
      value: hashedKey
    }]
  });
}
async function getApiKeyById(ctx, id, opts) {
  const storage = getStorageInstance(ctx, opts);
  if (opts.storage === "database") return await ctx.context.adapter.findOne({
    model: "apikey",
    where: [{
      field: "id",
      value: id
    }]
  });
  if (opts.storage === "secondary-storage" && opts.fallbackToDatabase) {
    if (storage) {
      const cached = await getApiKeyByIdFromStorage(ctx, id, storage);
      if (cached) return cached;
    }
    const dbKey = await ctx.context.adapter.findOne({
      model: "apikey",
      where: [{
        field: "id",
        value: id
      }]
    });
    if (dbKey && storage) await setApiKeyInStorage(ctx, dbKey, storage, calculateTTL(dbKey));
    return dbKey;
  }
  if (opts.storage === "secondary-storage") {
    if (!storage) return null;
    return await getApiKeyByIdFromStorage(ctx, id, storage);
  }
  return await ctx.context.adapter.findOne({
    model: "apikey",
    where: [{
      field: "id",
      value: id
    }]
  });
}
async function setApiKey(ctx, apiKey2, opts) {
  const storage = getStorageInstance(ctx, opts);
  const ttl = calculateTTL(apiKey2);
  if (opts.storage === "database") return;
  if (opts.storage === "secondary-storage") {
    if (!storage) throw new Error("Secondary storage is required when storage mode is 'secondary-storage'");
    await setApiKeyInStorage(ctx, apiKey2, storage, ttl);
    return;
  }
}
async function deleteApiKey(ctx, apiKey2, opts) {
  const storage = getStorageInstance(ctx, opts);
  if (opts.storage === "database") return;
  if (opts.storage === "secondary-storage") {
    if (!storage) throw new Error("Secondary storage is required when storage mode is 'secondary-storage'");
    await deleteApiKeyFromStorage(ctx, apiKey2, storage);
    return;
  }
}
async function listApiKeys(ctx, userId, opts) {
  const storage = getStorageInstance(ctx, opts);
  if (opts.storage === "database") return await ctx.context.adapter.findMany({
    model: "apikey",
    where: [{
      field: "userId",
      value: userId
    }]
  });
  if (opts.storage === "secondary-storage" && opts.fallbackToDatabase) {
    const userKey = getStorageKeyByUserId(userId);
    if (storage) {
      const userListData = await storage.get(userKey);
      let userIds = [];
      if (userListData && typeof userListData === "string") try {
        userIds = JSON.parse(userListData);
      } catch {
        userIds = [];
      }
      else if (Array.isArray(userListData)) userIds = userListData;
      if (userIds.length > 0) {
        const apiKeys = [];
        for (const id of userIds) {
          const apiKey2 = await getApiKeyByIdFromStorage(ctx, id, storage);
          if (apiKey2) apiKeys.push(apiKey2);
        }
        return apiKeys;
      }
    }
    const dbKeys = await ctx.context.adapter.findMany({
      model: "apikey",
      where: [{
        field: "userId",
        value: userId
      }]
    });
    if (storage && dbKeys.length > 0) {
      const userIds = [];
      for (const apiKey2 of dbKeys) {
        await setApiKeyInStorage(ctx, apiKey2, storage, calculateTTL(apiKey2));
        userIds.push(apiKey2.id);
      }
      await storage.set(userKey, JSON.stringify(userIds));
    }
    return dbKeys;
  }
  if (opts.storage === "secondary-storage") {
    if (!storage) return [];
    const userKey = getStorageKeyByUserId(userId);
    const userListData = await storage.get(userKey);
    let userIds = [];
    if (userListData && typeof userListData === "string") try {
      userIds = JSON.parse(userListData);
    } catch {
      return [];
    }
    else if (Array.isArray(userListData)) userIds = userListData;
    else return [];
    const apiKeys = [];
    for (const id of userIds) {
      const apiKey2 = await getApiKeyByIdFromStorage(ctx, id, storage);
      if (apiKey2) apiKeys.push(apiKey2);
    }
    return apiKeys;
  }
  return await ctx.context.adapter.findMany({
    model: "apikey",
    where: [{
      field: "userId",
      value: userId
    }]
  });
}

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/api-key/rate-limit.mjs
function isRateLimited(apiKey2, opts) {
  const now = /* @__PURE__ */ new Date();
  const lastRequest = apiKey2.lastRequest;
  const rateLimitTimeWindow = apiKey2.rateLimitTimeWindow;
  const rateLimitMax = apiKey2.rateLimitMax;
  let requestCount = apiKey2.requestCount;
  if (opts.rateLimit.enabled === false) return {
    success: true,
    message: null,
    update: { lastRequest: now },
    tryAgainIn: null
  };
  if (apiKey2.rateLimitEnabled === false) return {
    success: true,
    message: null,
    update: { lastRequest: now },
    tryAgainIn: null
  };
  if (rateLimitTimeWindow === null || rateLimitMax === null) return {
    success: true,
    message: null,
    update: null,
    tryAgainIn: null
  };
  if (lastRequest === null) return {
    success: true,
    message: null,
    update: {
      lastRequest: now,
      requestCount: 1
    },
    tryAgainIn: null
  };
  const timeSinceLastRequest = now.getTime() - new Date(lastRequest).getTime();
  if (timeSinceLastRequest > rateLimitTimeWindow) return {
    success: true,
    message: null,
    update: {
      lastRequest: now,
      requestCount: 1
    },
    tryAgainIn: null
  };
  if (requestCount >= rateLimitMax) return {
    success: false,
    message: ERROR_CODES.RATE_LIMIT_EXCEEDED,
    update: null,
    tryAgainIn: Math.ceil(rateLimitTimeWindow - timeSinceLastRequest)
  };
  requestCount++;
  return {
    success: true,
    message: null,
    tryAgainIn: null,
    update: {
      lastRequest: now,
      requestCount
    }
  };
}

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/api-key/routes/verify-api-key.mjs
async function validateApiKey({ hashedKey, ctx, opts, schema: schema9, permissions }) {
  const apiKey2 = await getApiKey(ctx, hashedKey, opts);
  if (!apiKey2) throw new APIError("UNAUTHORIZED", { message: ERROR_CODES.INVALID_API_KEY });
  if (apiKey2.enabled === false) throw new APIError("UNAUTHORIZED", {
    message: ERROR_CODES.KEY_DISABLED,
    code: "KEY_DISABLED"
  });
  if (apiKey2.expiresAt) {
    if (Date.now() > new Date(apiKey2.expiresAt).getTime()) {
      const deleteExpiredKey = async () => {
        if (opts.storage === "secondary-storage" && opts.fallbackToDatabase) {
          await deleteApiKey(ctx, apiKey2, opts);
          await ctx.context.adapter.delete({
            model: API_KEY_TABLE_NAME,
            where: [{
              field: "id",
              value: apiKey2.id
            }]
          });
        } else if (opts.storage === "secondary-storage") await deleteApiKey(ctx, apiKey2, opts);
        else await ctx.context.adapter.delete({
          model: API_KEY_TABLE_NAME,
          where: [{
            field: "id",
            value: apiKey2.id
          }]
        });
      };
      if (opts.deferUpdates) ctx.context.runInBackground(deleteExpiredKey().catch((error) => {
        ctx.context.logger.error("Deferred update failed:", error);
      }));
      else await deleteExpiredKey();
      throw new APIError("UNAUTHORIZED", {
        message: ERROR_CODES.KEY_EXPIRED,
        code: "KEY_EXPIRED"
      });
    }
  }
  if (permissions) {
    const apiKeyPermissions = apiKey2.permissions ? safeJSONParse(apiKey2.permissions) : null;
    if (!apiKeyPermissions) throw new APIError("UNAUTHORIZED", {
      message: ERROR_CODES.KEY_NOT_FOUND,
      code: "KEY_NOT_FOUND"
    });
    if (!role(apiKeyPermissions).authorize(permissions).success) throw new APIError("UNAUTHORIZED", {
      message: ERROR_CODES.KEY_NOT_FOUND,
      code: "KEY_NOT_FOUND"
    });
  }
  let remaining = apiKey2.remaining;
  let lastRefillAt = apiKey2.lastRefillAt;
  if (apiKey2.remaining === 0 && apiKey2.refillAmount === null) {
    const deleteExhaustedKey = async () => {
      if (opts.storage === "secondary-storage" && opts.fallbackToDatabase) {
        await deleteApiKey(ctx, apiKey2, opts);
        await ctx.context.adapter.delete({
          model: API_KEY_TABLE_NAME,
          where: [{
            field: "id",
            value: apiKey2.id
          }]
        });
      } else if (opts.storage === "secondary-storage") await deleteApiKey(ctx, apiKey2, opts);
      else await ctx.context.adapter.delete({
        model: API_KEY_TABLE_NAME,
        where: [{
          field: "id",
          value: apiKey2.id
        }]
      });
    };
    if (opts.deferUpdates) ctx.context.runInBackground(deleteExhaustedKey().catch((error) => {
      ctx.context.logger.error("Deferred update failed:", error);
    }));
    else await deleteExhaustedKey();
    throw new APIError("TOO_MANY_REQUESTS", {
      message: ERROR_CODES.USAGE_EXCEEDED,
      code: "USAGE_EXCEEDED"
    });
  } else if (remaining !== null) {
    let now = Date.now();
    const refillInterval = apiKey2.refillInterval;
    const refillAmount = apiKey2.refillAmount;
    let lastTime = new Date(lastRefillAt ?? apiKey2.createdAt).getTime();
    if (refillInterval && refillAmount) {
      if (now - lastTime > refillInterval) {
        remaining = refillAmount;
        lastRefillAt = /* @__PURE__ */ new Date();
      }
    }
    if (remaining === 0) throw new APIError("TOO_MANY_REQUESTS", {
      message: ERROR_CODES.USAGE_EXCEEDED,
      code: "USAGE_EXCEEDED"
    });
    else remaining--;
  }
  const { message, success, update, tryAgainIn } = isRateLimited(apiKey2, opts);
  if (success === false) throw new APIError("UNAUTHORIZED", {
    message: message ?? void 0,
    code: "RATE_LIMITED",
    details: { tryAgainIn }
  });
  const updated = {
    ...apiKey2,
    ...update,
    remaining,
    lastRefillAt,
    updatedAt: /* @__PURE__ */ new Date()
  };
  const performUpdate = async () => {
    if (opts.storage === "database") return ctx.context.adapter.update({
      model: API_KEY_TABLE_NAME,
      where: [{
        field: "id",
        value: apiKey2.id
      }],
      update: {
        ...updated,
        id: void 0
      }
    });
    else if (opts.storage === "secondary-storage" && opts.fallbackToDatabase) {
      const dbUpdated = await ctx.context.adapter.update({
        model: API_KEY_TABLE_NAME,
        where: [{
          field: "id",
          value: apiKey2.id
        }],
        update: {
          ...updated,
          id: void 0
        }
      });
      if (dbUpdated) await setApiKey(ctx, dbUpdated, opts);
      return dbUpdated;
    } else {
      await setApiKey(ctx, updated, opts);
      return updated;
    }
  };
  let newApiKey = null;
  if (opts.deferUpdates) {
    ctx.context.runInBackground(performUpdate().then(() => {
    }).catch((error) => {
      ctx.context.logger.error("Failed to update API key:", error);
    }));
    newApiKey = updated;
  } else {
    newApiKey = await performUpdate();
    if (!newApiKey) throw new APIError("INTERNAL_SERVER_ERROR", {
      message: ERROR_CODES.FAILED_TO_UPDATE_API_KEY,
      code: "INTERNAL_SERVER_ERROR"
    });
  }
  return newApiKey;
}
var verifyApiKeyBodySchema = object({
  key: string().meta({ description: "The key to verify" }),
  permissions: record(string(), array(string())).meta({ description: "The permissions to verify." }).optional()
});
function verifyApiKey({ opts, schema: schema9, deleteAllExpiredApiKeys: deleteAllExpiredApiKeys2 }) {
  return createAuthEndpoint({
    method: "POST",
    body: verifyApiKeyBodySchema
  }, async (ctx) => {
    const { key } = ctx.body;
    if (key.length < opts.defaultKeyLength) return ctx.json({
      valid: false,
      error: {
        message: ERROR_CODES.INVALID_API_KEY,
        code: "KEY_NOT_FOUND"
      },
      key: null
    });
    if (opts.customAPIKeyValidator) {
      if (!await opts.customAPIKeyValidator({
        ctx,
        key
      })) return ctx.json({
        valid: false,
        error: {
          message: ERROR_CODES.INVALID_API_KEY,
          code: "KEY_NOT_FOUND"
        },
        key: null
      });
    }
    const hashed = opts.disableKeyHashing ? key : await defaultKeyHasher(key);
    let apiKey2 = null;
    try {
      apiKey2 = await validateApiKey({
        hashedKey: hashed,
        permissions: ctx.body.permissions,
        ctx,
        opts,
        schema: schema9
      });
      if (opts.deferUpdates) ctx.context.runInBackground(deleteAllExpiredApiKeys2(ctx.context).catch((err) => {
        ctx.context.logger.error("Failed to delete expired API keys:", err);
      }));
    } catch (error) {
      if (error instanceof APIError) return ctx.json({
        valid: false,
        error: {
          message: error.body?.message,
          code: error.body?.code
        },
        key: null
      });
      return ctx.json({
        valid: false,
        error: {
          message: ERROR_CODES.INVALID_API_KEY,
          code: "INVALID_API_KEY"
        },
        key: null
      });
    }
    const { key: _, ...returningApiKey } = apiKey2 ?? {
      key: 1,
      permissions: void 0
    };
    if ("metadata" in returningApiKey) returningApiKey.metadata = schema9.apikey.fields.metadata.transform.output(returningApiKey.metadata);
    returningApiKey.permissions = returningApiKey.permissions ? safeJSONParse(returningApiKey.permissions) : null;
    return ctx.json({
      valid: true,
      error: null,
      key: apiKey2 === null ? null : returningApiKey
    });
  });
}

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/api-key/routes/create-api-key.mjs
var createApiKeyBodySchema = object({
  name: string().meta({ description: "Name of the Api Key" }).optional(),
  expiresIn: number().meta({ description: "Expiration time of the Api Key in seconds" }).min(1).optional().nullable().default(null),
  userId: coerce_exports.string().meta({ description: 'User Id of the user that the Api Key belongs to. server-only. Eg: "user-id"' }).optional(),
  prefix: string().meta({ description: "Prefix of the Api Key" }).regex(/^[a-zA-Z0-9_-]+$/, { message: "Invalid prefix format, must be alphanumeric and contain only underscores and hyphens." }).optional(),
  remaining: number().meta({ description: "Remaining number of requests. Server side only" }).min(0).optional().nullable().default(null),
  metadata: any().optional(),
  refillAmount: number().meta({ description: "Amount to refill the remaining count of the Api Key. server-only. Eg: 100" }).min(1).optional(),
  refillInterval: number().meta({ description: "Interval to refill the Api Key in milliseconds. server-only. Eg: 1000" }).optional(),
  rateLimitTimeWindow: number().meta({ description: "The duration in milliseconds where each request is counted. Once the `maxRequests` is reached, the request will be rejected until the `timeWindow` has passed, at which point the `timeWindow` will be reset. server-only. Eg: 1000" }).optional(),
  rateLimitMax: number().meta({ description: "Maximum amount of requests allowed within a window. Once the `maxRequests` is reached, the request will be rejected until the `timeWindow` has passed, at which point the `timeWindow` will be reset. server-only. Eg: 100" }).optional(),
  rateLimitEnabled: boolean().meta({ description: "Whether the key has rate limiting enabled. server-only. Eg: true" }).optional(),
  permissions: record(string(), array(string())).meta({ description: "Permissions of the Api Key." }).optional()
});
function createApiKey({ keyGenerator, opts, schema: schema9, deleteAllExpiredApiKeys: deleteAllExpiredApiKeys2 }) {
  return createAuthEndpoint("/api-key/create", {
    method: "POST",
    body: createApiKeyBodySchema,
    metadata: { openapi: {
      description: "Create a new API key for a user",
      responses: { "200": {
        description: "API key created successfully",
        content: { "application/json": { schema: {
          type: "object",
          properties: {
            id: {
              type: "string",
              description: "Unique identifier of the API key"
            },
            createdAt: {
              type: "string",
              format: "date-time",
              description: "Creation timestamp"
            },
            updatedAt: {
              type: "string",
              format: "date-time",
              description: "Last update timestamp"
            },
            name: {
              type: "string",
              nullable: true,
              description: "Name of the API key"
            },
            prefix: {
              type: "string",
              nullable: true,
              description: "Prefix of the API key"
            },
            start: {
              type: "string",
              nullable: true,
              description: "Starting characters of the key (if configured)"
            },
            key: {
              type: "string",
              description: "The full API key (only returned on creation)"
            },
            enabled: {
              type: "boolean",
              description: "Whether the key is enabled"
            },
            expiresAt: {
              type: "string",
              format: "date-time",
              nullable: true,
              description: "Expiration timestamp"
            },
            userId: {
              type: "string",
              description: "ID of the user owning the key"
            },
            lastRefillAt: {
              type: "string",
              format: "date-time",
              nullable: true,
              description: "Last refill timestamp"
            },
            lastRequest: {
              type: "string",
              format: "date-time",
              nullable: true,
              description: "Last request timestamp"
            },
            metadata: {
              type: "object",
              nullable: true,
              additionalProperties: true,
              description: "Metadata associated with the key"
            },
            rateLimitMax: {
              type: "number",
              nullable: true,
              description: "Maximum requests in time window"
            },
            rateLimitTimeWindow: {
              type: "number",
              nullable: true,
              description: "Rate limit time window in milliseconds"
            },
            remaining: {
              type: "number",
              nullable: true,
              description: "Remaining requests"
            },
            refillAmount: {
              type: "number",
              nullable: true,
              description: "Amount to refill"
            },
            refillInterval: {
              type: "number",
              nullable: true,
              description: "Refill interval in milliseconds"
            },
            rateLimitEnabled: {
              type: "boolean",
              description: "Whether rate limiting is enabled"
            },
            requestCount: {
              type: "number",
              description: "Current request count in window"
            },
            permissions: {
              type: "object",
              nullable: true,
              additionalProperties: {
                type: "array",
                items: { type: "string" }
              },
              description: "Permissions associated with the key"
            }
          },
          required: [
            "id",
            "createdAt",
            "updatedAt",
            "key",
            "enabled",
            "userId",
            "rateLimitEnabled",
            "requestCount"
          ]
        } } }
      } }
    } }
  }, async (ctx) => {
    const { name, expiresIn, prefix, remaining, metadata, refillAmount, refillInterval, permissions, rateLimitMax, rateLimitTimeWindow, rateLimitEnabled } = ctx.body;
    const session = await getSessionFromCtx(ctx);
    const authRequired = ctx.request || ctx.headers;
    const user = authRequired && !session ? null : session?.user || { id: ctx.body.userId };
    if (!user?.id) throw new APIError("UNAUTHORIZED", { message: ERROR_CODES.UNAUTHORIZED_SESSION });
    if (session && ctx.body.userId && session?.user.id !== ctx.body.userId) throw new APIError("UNAUTHORIZED", { message: ERROR_CODES.UNAUTHORIZED_SESSION });
    if (authRequired) {
      if (refillAmount !== void 0 || refillInterval !== void 0 || rateLimitMax !== void 0 || rateLimitTimeWindow !== void 0 || rateLimitEnabled !== void 0 || permissions !== void 0 || remaining !== null) throw new APIError("BAD_REQUEST", { message: ERROR_CODES.SERVER_ONLY_PROPERTY });
    }
    if (metadata) {
      if (opts.enableMetadata === false) throw new APIError("BAD_REQUEST", { message: ERROR_CODES.METADATA_DISABLED });
      if (typeof metadata !== "object") throw new APIError("BAD_REQUEST", { message: ERROR_CODES.INVALID_METADATA_TYPE });
    }
    if (refillAmount && !refillInterval) throw new APIError("BAD_REQUEST", { message: ERROR_CODES.REFILL_AMOUNT_AND_INTERVAL_REQUIRED });
    if (refillInterval && !refillAmount) throw new APIError("BAD_REQUEST", { message: ERROR_CODES.REFILL_INTERVAL_AND_AMOUNT_REQUIRED });
    if (expiresIn) {
      if (opts.keyExpiration.disableCustomExpiresTime === true) throw new APIError("BAD_REQUEST", { message: ERROR_CODES.KEY_DISABLED_EXPIRATION });
      const expiresIn_in_days = expiresIn / (3600 * 24);
      if (opts.keyExpiration.minExpiresIn > expiresIn_in_days) throw new APIError("BAD_REQUEST", { message: ERROR_CODES.EXPIRES_IN_IS_TOO_SMALL });
      else if (opts.keyExpiration.maxExpiresIn < expiresIn_in_days) throw new APIError("BAD_REQUEST", { message: ERROR_CODES.EXPIRES_IN_IS_TOO_LARGE });
    }
    if (prefix) {
      if (prefix.length < opts.minimumPrefixLength) throw new APIError("BAD_REQUEST", { message: ERROR_CODES.INVALID_PREFIX_LENGTH });
      if (prefix.length > opts.maximumPrefixLength) throw new APIError("BAD_REQUEST", { message: ERROR_CODES.INVALID_PREFIX_LENGTH });
    }
    if (name) {
      if (name.length < opts.minimumNameLength) throw new APIError("BAD_REQUEST", { message: ERROR_CODES.INVALID_NAME_LENGTH });
      if (name.length > opts.maximumNameLength) throw new APIError("BAD_REQUEST", { message: ERROR_CODES.INVALID_NAME_LENGTH });
    } else if (opts.requireName) throw new APIError("BAD_REQUEST", { message: ERROR_CODES.NAME_REQUIRED });
    deleteAllExpiredApiKeys2(ctx.context);
    const key = await keyGenerator({
      length: opts.defaultKeyLength,
      prefix: prefix || opts.defaultPrefix
    });
    const hashed = opts.disableKeyHashing ? key : await defaultKeyHasher(key);
    let start = null;
    if (opts.startingCharactersConfig.shouldStore) start = key.substring(0, opts.startingCharactersConfig.charactersLength);
    const defaultPermissions = opts.permissions?.defaultPermissions ? typeof opts.permissions.defaultPermissions === "function" ? await opts.permissions.defaultPermissions(user.id, ctx) : opts.permissions.defaultPermissions : void 0;
    const permissionsToApply = permissions ? JSON.stringify(permissions) : defaultPermissions ? JSON.stringify(defaultPermissions) : void 0;
    let data = {
      createdAt: /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date(),
      name: name ?? null,
      prefix: prefix ?? opts.defaultPrefix ?? null,
      start,
      key: hashed,
      enabled: true,
      expiresAt: expiresIn ? getDate(expiresIn, "sec") : opts.keyExpiration.defaultExpiresIn ? getDate(opts.keyExpiration.defaultExpiresIn, "sec") : null,
      userId: user.id,
      lastRefillAt: null,
      lastRequest: null,
      metadata: null,
      rateLimitMax: rateLimitMax ?? opts.rateLimit.maxRequests ?? null,
      rateLimitTimeWindow: rateLimitTimeWindow ?? opts.rateLimit.timeWindow ?? null,
      remaining: remaining === null ? remaining : remaining ?? refillAmount ?? null,
      refillAmount: refillAmount ?? null,
      refillInterval: refillInterval ?? null,
      rateLimitEnabled: rateLimitEnabled === void 0 ? opts.rateLimit.enabled ?? true : rateLimitEnabled,
      requestCount: 0,
      permissions: permissionsToApply
    };
    if (metadata) data.metadata = schema9.apikey.fields.metadata.transform.input(metadata);
    let apiKey2;
    if (opts.storage === "secondary-storage" && opts.fallbackToDatabase) {
      apiKey2 = await ctx.context.adapter.create({
        model: API_KEY_TABLE_NAME,
        data
      });
      await setApiKey(ctx, apiKey2, opts);
    } else if (opts.storage === "secondary-storage") {
      const id = ctx.context.generateId({ model: API_KEY_TABLE_NAME }) ?? generateId();
      apiKey2 = {
        ...data,
        id
      };
      await setApiKey(ctx, apiKey2, opts);
    } else apiKey2 = await ctx.context.adapter.create({
      model: API_KEY_TABLE_NAME,
      data
    });
    return ctx.json({
      ...apiKey2,
      key,
      metadata: metadata ?? null,
      permissions: apiKey2.permissions ? safeJSONParse(apiKey2.permissions) : null
    });
  });
}

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/api-key/routes/delete-all-expired-api-keys.mjs
function deleteAllExpiredApiKeysEndpoint({ deleteAllExpiredApiKeys: deleteAllExpiredApiKeys2 }) {
  return createAuthEndpoint({ method: "POST" }, async (ctx) => {
    try {
      await deleteAllExpiredApiKeys2(ctx.context, true);
    } catch (error) {
      ctx.context.logger.error("[API KEY PLUGIN] Failed to delete expired API keys:", error);
      return ctx.json({
        success: false,
        error
      });
    }
    return ctx.json({
      success: true,
      error: null
    });
  });
}

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/api-key/routes/delete-api-key.mjs
var deleteApiKeyBodySchema = object({ keyId: string().meta({ description: "The id of the Api Key" }) });
function deleteApiKey$1({ opts, schema: schema9, deleteAllExpiredApiKeys: deleteAllExpiredApiKeys2 }) {
  return createAuthEndpoint("/api-key/delete", {
    method: "POST",
    body: deleteApiKeyBodySchema,
    use: [sessionMiddleware],
    metadata: { openapi: {
      description: "Delete an existing API key",
      requestBody: { content: { "application/json": { schema: {
        type: "object",
        properties: { keyId: {
          type: "string",
          description: "The id of the API key to delete"
        } },
        required: ["keyId"]
      } } } },
      responses: { "200": {
        description: "API key deleted successfully",
        content: { "application/json": { schema: {
          type: "object",
          properties: { success: {
            type: "boolean",
            description: "Indicates if the API key was successfully deleted"
          } },
          required: ["success"]
        } } }
      } }
    } }
  }, async (ctx) => {
    const { keyId } = ctx.body;
    const session = ctx.context.session;
    if (session.user.banned === true) throw new APIError("UNAUTHORIZED", { message: ERROR_CODES.USER_BANNED });
    let apiKey2 = null;
    apiKey2 = await getApiKeyById(ctx, keyId, opts);
    if (!apiKey2 || apiKey2.userId !== session.user.id) throw new APIError("NOT_FOUND", { message: ERROR_CODES.KEY_NOT_FOUND });
    try {
      if (opts.storage === "secondary-storage" && opts.fallbackToDatabase) {
        await deleteApiKey(ctx, apiKey2, opts);
        await ctx.context.adapter.delete({
          model: API_KEY_TABLE_NAME,
          where: [{
            field: "id",
            value: apiKey2.id
          }]
        });
      } else if (opts.storage === "database") await ctx.context.adapter.delete({
        model: API_KEY_TABLE_NAME,
        where: [{
          field: "id",
          value: apiKey2.id
        }]
      });
      else await deleteApiKey(ctx, apiKey2, opts);
    } catch (error) {
      throw new APIError("INTERNAL_SERVER_ERROR", { message: error?.message });
    }
    deleteAllExpiredApiKeys2(ctx.context);
    return ctx.json({ success: true });
  });
}

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/api-key/routes/get-api-key.mjs
var getApiKeyQuerySchema = object({ id: string().meta({ description: "The id of the Api Key" }) });
function getApiKey2({ opts, schema: schema9, deleteAllExpiredApiKeys: deleteAllExpiredApiKeys2 }) {
  return createAuthEndpoint("/api-key/get", {
    method: "GET",
    query: getApiKeyQuerySchema,
    use: [sessionMiddleware],
    metadata: { openapi: {
      description: "Retrieve an existing API key by ID",
      responses: { "200": {
        description: "API key retrieved successfully",
        content: { "application/json": { schema: {
          type: "object",
          properties: {
            id: {
              type: "string",
              description: "ID"
            },
            name: {
              type: "string",
              nullable: true,
              description: "The name of the key"
            },
            start: {
              type: "string",
              nullable: true,
              description: "Shows the first few characters of the API key, including the prefix. This allows you to show those few characters in the UI to make it easier for users to identify the API key."
            },
            prefix: {
              type: "string",
              nullable: true,
              description: "The API Key prefix. Stored as plain text."
            },
            userId: {
              type: "string",
              description: "The owner of the user id"
            },
            refillInterval: {
              type: "number",
              nullable: true,
              description: "The interval in milliseconds between refills of the `remaining` count. Example: 3600000 // refill every hour (3600000ms = 1h)"
            },
            refillAmount: {
              type: "number",
              nullable: true,
              description: "The amount to refill"
            },
            lastRefillAt: {
              type: "string",
              format: "date-time",
              nullable: true,
              description: "The last refill date"
            },
            enabled: {
              type: "boolean",
              description: "Sets if key is enabled or disabled",
              default: true
            },
            rateLimitEnabled: {
              type: "boolean",
              description: "Whether the key has rate limiting enabled"
            },
            rateLimitTimeWindow: {
              type: "number",
              nullable: true,
              description: "The duration in milliseconds"
            },
            rateLimitMax: {
              type: "number",
              nullable: true,
              description: "Maximum amount of requests allowed within a window"
            },
            requestCount: {
              type: "number",
              description: "The number of requests made within the rate limit time window"
            },
            remaining: {
              type: "number",
              nullable: true,
              description: "Remaining requests (every time api key is used this should updated and should be updated on refill as well)"
            },
            lastRequest: {
              type: "string",
              format: "date-time",
              nullable: true,
              description: "When last request occurred"
            },
            expiresAt: {
              type: "string",
              format: "date-time",
              nullable: true,
              description: "Expiry date of a key"
            },
            createdAt: {
              type: "string",
              format: "date-time",
              description: "created at"
            },
            updatedAt: {
              type: "string",
              format: "date-time",
              description: "updated at"
            },
            metadata: {
              type: "object",
              nullable: true,
              additionalProperties: true,
              description: "Extra metadata about the apiKey"
            },
            permissions: {
              type: "string",
              nullable: true,
              description: "Permissions for the api key (stored as JSON string)"
            }
          },
          required: [
            "id",
            "userId",
            "enabled",
            "rateLimitEnabled",
            "requestCount",
            "createdAt",
            "updatedAt"
          ]
        } } }
      } }
    } }
  }, async (ctx) => {
    const { id } = ctx.query;
    const session = ctx.context.session;
    let apiKey2 = null;
    apiKey2 = await getApiKeyById(ctx, id, opts);
    if (apiKey2 && apiKey2.userId !== session.user.id) apiKey2 = null;
    if (!apiKey2) throw new APIError("NOT_FOUND", { message: ERROR_CODES.KEY_NOT_FOUND });
    deleteAllExpiredApiKeys2(ctx.context);
    apiKey2.metadata = schema9.apikey.fields.metadata.transform.output(apiKey2.metadata);
    const { key: _key, ...returningApiKey } = apiKey2;
    return ctx.json({
      ...returningApiKey,
      permissions: returningApiKey.permissions ? safeJSONParse(returningApiKey.permissions) : null
    });
  });
}

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/api-key/routes/list-api-keys.mjs
function listApiKeys$1({ opts, schema: schema9, deleteAllExpiredApiKeys: deleteAllExpiredApiKeys2 }) {
  return createAuthEndpoint("/api-key/list", {
    method: "GET",
    use: [sessionMiddleware],
    metadata: { openapi: {
      description: "List all API keys for the authenticated user",
      responses: { "200": {
        description: "API keys retrieved successfully",
        content: { "application/json": { schema: {
          type: "array",
          items: {
            type: "object",
            properties: {
              id: {
                type: "string",
                description: "ID"
              },
              name: {
                type: "string",
                nullable: true,
                description: "The name of the key"
              },
              start: {
                type: "string",
                nullable: true,
                description: "Shows the first few characters of the API key, including the prefix. This allows you to show those few characters in the UI to make it easier for users to identify the API key."
              },
              prefix: {
                type: "string",
                nullable: true,
                description: "The API Key prefix. Stored as plain text."
              },
              userId: {
                type: "string",
                description: "The owner of the user id"
              },
              refillInterval: {
                type: "number",
                nullable: true,
                description: "The interval in milliseconds between refills of the `remaining` count. Example: 3600000 // refill every hour (3600000ms = 1h)"
              },
              refillAmount: {
                type: "number",
                nullable: true,
                description: "The amount to refill"
              },
              lastRefillAt: {
                type: "string",
                format: "date-time",
                nullable: true,
                description: "The last refill date"
              },
              enabled: {
                type: "boolean",
                description: "Sets if key is enabled or disabled",
                default: true
              },
              rateLimitEnabled: {
                type: "boolean",
                description: "Whether the key has rate limiting enabled"
              },
              rateLimitTimeWindow: {
                type: "number",
                nullable: true,
                description: "The duration in milliseconds"
              },
              rateLimitMax: {
                type: "number",
                nullable: true,
                description: "Maximum amount of requests allowed within a window"
              },
              requestCount: {
                type: "number",
                description: "The number of requests made within the rate limit time window"
              },
              remaining: {
                type: "number",
                nullable: true,
                description: "Remaining requests (every time api key is used this should updated and should be updated on refill as well)"
              },
              lastRequest: {
                type: "string",
                format: "date-time",
                nullable: true,
                description: "When last request occurred"
              },
              expiresAt: {
                type: "string",
                format: "date-time",
                nullable: true,
                description: "Expiry date of a key"
              },
              createdAt: {
                type: "string",
                format: "date-time",
                description: "created at"
              },
              updatedAt: {
                type: "string",
                format: "date-time",
                description: "updated at"
              },
              metadata: {
                type: "object",
                nullable: true,
                additionalProperties: true,
                description: "Extra metadata about the apiKey"
              },
              permissions: {
                type: "string",
                nullable: true,
                description: "Permissions for the api key (stored as JSON string)"
              }
            },
            required: [
              "id",
              "userId",
              "enabled",
              "rateLimitEnabled",
              "requestCount",
              "createdAt",
              "updatedAt"
            ]
          }
        } } }
      } }
    } }
  }, async (ctx) => {
    const session = ctx.context.session;
    let apiKeys;
    apiKeys = await listApiKeys(ctx, session.user.id, opts);
    deleteAllExpiredApiKeys2(ctx.context);
    apiKeys = apiKeys.map((apiKey2) => {
      return {
        ...apiKey2,
        metadata: schema9.apikey.fields.metadata.transform.output(apiKey2.metadata)
      };
    });
    let returningApiKey = apiKeys.map((x) => {
      const { key: _key, ...returningApiKey$1 } = x;
      return {
        ...returningApiKey$1,
        permissions: returningApiKey$1.permissions ? safeJSONParse(returningApiKey$1.permissions) : null
      };
    });
    return ctx.json(returningApiKey);
  });
}

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/api-key/routes/update-api-key.mjs
var updateApiKeyBodySchema = object({
  keyId: string().meta({ description: "The id of the Api Key" }),
  userId: coerce_exports.string().meta({ description: 'The id of the user which the api key belongs to. server-only. Eg: "some-user-id"' }).optional(),
  name: string().meta({ description: "The name of the key" }).optional(),
  enabled: boolean().meta({ description: "Whether the Api Key is enabled or not" }).optional(),
  remaining: number().meta({ description: "The number of remaining requests" }).min(1).optional(),
  refillAmount: number().meta({ description: "The refill amount" }).optional(),
  refillInterval: number().meta({ description: "The refill interval" }).optional(),
  metadata: any().optional(),
  expiresIn: number().meta({ description: "Expiration time of the Api Key in seconds" }).min(1).optional().nullable(),
  rateLimitEnabled: boolean().meta({ description: "Whether the key has rate limiting enabled." }).optional(),
  rateLimitTimeWindow: number().meta({ description: "The duration in milliseconds where each request is counted. server-only. Eg: 1000" }).optional(),
  rateLimitMax: number().meta({ description: "Maximum amount of requests allowed within a window. Once the `maxRequests` is reached, the request will be rejected until the `timeWindow` has passed, at which point the `timeWindow` will be reset. server-only. Eg: 100" }).optional(),
  permissions: record(string(), array(string())).meta({ description: "Update the permissions on the API Key. server-only." }).optional().nullable()
});
function updateApiKey({ opts, schema: schema9, deleteAllExpiredApiKeys: deleteAllExpiredApiKeys2 }) {
  return createAuthEndpoint("/api-key/update", {
    method: "POST",
    body: updateApiKeyBodySchema,
    metadata: { openapi: {
      description: "Update an existing API key by ID",
      responses: { "200": {
        description: "API key updated successfully",
        content: { "application/json": { schema: {
          type: "object",
          properties: {
            id: {
              type: "string",
              description: "ID"
            },
            name: {
              type: "string",
              nullable: true,
              description: "The name of the key"
            },
            start: {
              type: "string",
              nullable: true,
              description: "Shows the first few characters of the API key, including the prefix. This allows you to show those few characters in the UI to make it easier for users to identify the API key."
            },
            prefix: {
              type: "string",
              nullable: true,
              description: "The API Key prefix. Stored as plain text."
            },
            userId: {
              type: "string",
              description: "The owner of the user id"
            },
            refillInterval: {
              type: "number",
              nullable: true,
              description: "The interval in milliseconds between refills of the `remaining` count. Example: 3600000 // refill every hour (3600000ms = 1h)"
            },
            refillAmount: {
              type: "number",
              nullable: true,
              description: "The amount to refill"
            },
            lastRefillAt: {
              type: "string",
              format: "date-time",
              nullable: true,
              description: "The last refill date"
            },
            enabled: {
              type: "boolean",
              description: "Sets if key is enabled or disabled",
              default: true
            },
            rateLimitEnabled: {
              type: "boolean",
              description: "Whether the key has rate limiting enabled"
            },
            rateLimitTimeWindow: {
              type: "number",
              nullable: true,
              description: "The duration in milliseconds"
            },
            rateLimitMax: {
              type: "number",
              nullable: true,
              description: "Maximum amount of requests allowed within a window"
            },
            requestCount: {
              type: "number",
              description: "The number of requests made within the rate limit time window"
            },
            remaining: {
              type: "number",
              nullable: true,
              description: "Remaining requests (every time api key is used this should updated and should be updated on refill as well)"
            },
            lastRequest: {
              type: "string",
              format: "date-time",
              nullable: true,
              description: "When last request occurred"
            },
            expiresAt: {
              type: "string",
              format: "date-time",
              nullable: true,
              description: "Expiry date of a key"
            },
            createdAt: {
              type: "string",
              format: "date-time",
              description: "created at"
            },
            updatedAt: {
              type: "string",
              format: "date-time",
              description: "updated at"
            },
            metadata: {
              type: "object",
              nullable: true,
              additionalProperties: true,
              description: "Extra metadata about the apiKey"
            },
            permissions: {
              type: "string",
              nullable: true,
              description: "Permissions for the api key (stored as JSON string)"
            }
          },
          required: [
            "id",
            "userId",
            "enabled",
            "rateLimitEnabled",
            "requestCount",
            "createdAt",
            "updatedAt"
          ]
        } } }
      } }
    } }
  }, async (ctx) => {
    const { keyId, expiresIn, enabled, metadata, refillAmount, refillInterval, remaining, name, permissions, rateLimitEnabled, rateLimitTimeWindow, rateLimitMax } = ctx.body;
    const session = await getSessionFromCtx(ctx);
    const authRequired = ctx.request || ctx.headers;
    const user = authRequired && !session ? null : session?.user || { id: ctx.body.userId };
    if (!user?.id) throw new APIError("UNAUTHORIZED", { message: ERROR_CODES.UNAUTHORIZED_SESSION });
    if (session && ctx.body.userId && session?.user.id !== ctx.body.userId) throw new APIError("UNAUTHORIZED", { message: ERROR_CODES.UNAUTHORIZED_SESSION });
    if (authRequired) {
      if (refillAmount !== void 0 || refillInterval !== void 0 || rateLimitMax !== void 0 || rateLimitTimeWindow !== void 0 || rateLimitEnabled !== void 0 || remaining !== void 0 || permissions !== void 0) throw new APIError("BAD_REQUEST", { message: ERROR_CODES.SERVER_ONLY_PROPERTY });
    }
    let apiKey2 = null;
    apiKey2 = await getApiKeyById(ctx, keyId, opts);
    if (apiKey2 && apiKey2.userId !== user.id) apiKey2 = null;
    if (!apiKey2) throw new APIError("NOT_FOUND", { message: ERROR_CODES.KEY_NOT_FOUND });
    let newValues = {};
    if (name !== void 0) {
      if (name.length < opts.minimumNameLength) throw new APIError("BAD_REQUEST", { message: ERROR_CODES.INVALID_NAME_LENGTH });
      else if (name.length > opts.maximumNameLength) throw new APIError("BAD_REQUEST", { message: ERROR_CODES.INVALID_NAME_LENGTH });
      newValues.name = name;
    }
    if (enabled !== void 0) newValues.enabled = enabled;
    if (expiresIn !== void 0) {
      if (opts.keyExpiration.disableCustomExpiresTime === true) throw new APIError("BAD_REQUEST", { message: ERROR_CODES.KEY_DISABLED_EXPIRATION });
      if (expiresIn !== null) {
        const expiresIn_in_days = expiresIn / (3600 * 24);
        if (expiresIn_in_days < opts.keyExpiration.minExpiresIn) throw new APIError("BAD_REQUEST", { message: ERROR_CODES.EXPIRES_IN_IS_TOO_SMALL });
        else if (expiresIn_in_days > opts.keyExpiration.maxExpiresIn) throw new APIError("BAD_REQUEST", { message: ERROR_CODES.EXPIRES_IN_IS_TOO_LARGE });
      }
      newValues.expiresAt = expiresIn ? getDate(expiresIn, "sec") : null;
    }
    if (metadata !== void 0 && opts.enableMetadata === true) {
      if (typeof metadata !== "object") throw new APIError("BAD_REQUEST", { message: ERROR_CODES.INVALID_METADATA_TYPE });
      newValues.metadata = schema9.apikey.fields.metadata.transform.input(metadata);
    }
    if (remaining !== void 0) newValues.remaining = remaining;
    if (refillAmount !== void 0 || refillInterval !== void 0) {
      if (refillAmount !== void 0 && refillInterval === void 0) throw new APIError("BAD_REQUEST", { message: ERROR_CODES.REFILL_AMOUNT_AND_INTERVAL_REQUIRED });
      else if (refillInterval !== void 0 && refillAmount === void 0) throw new APIError("BAD_REQUEST", { message: ERROR_CODES.REFILL_INTERVAL_AND_AMOUNT_REQUIRED });
      newValues.refillAmount = refillAmount;
      newValues.refillInterval = refillInterval;
    }
    if (rateLimitEnabled !== void 0) newValues.rateLimitEnabled = rateLimitEnabled;
    if (rateLimitTimeWindow !== void 0) newValues.rateLimitTimeWindow = rateLimitTimeWindow;
    if (rateLimitMax !== void 0) newValues.rateLimitMax = rateLimitMax;
    if (permissions !== void 0) newValues.permissions = JSON.stringify(permissions);
    if (Object.keys(newValues).length === 0) throw new APIError("BAD_REQUEST", { message: ERROR_CODES.NO_VALUES_TO_UPDATE });
    let newApiKey = apiKey2;
    try {
      if (opts.storage === "secondary-storage" && opts.fallbackToDatabase) {
        const dbUpdated = await ctx.context.adapter.update({
          model: API_KEY_TABLE_NAME,
          where: [{
            field: "id",
            value: apiKey2.id
          }],
          update: newValues
        });
        if (dbUpdated) {
          await setApiKey(ctx, dbUpdated, opts);
          newApiKey = dbUpdated;
        }
      } else if (opts.storage === "database") {
        const result = await ctx.context.adapter.update({
          model: API_KEY_TABLE_NAME,
          where: [{
            field: "id",
            value: apiKey2.id
          }],
          update: newValues
        });
        if (result) newApiKey = result;
      } else {
        const updated = {
          ...apiKey2,
          ...newValues,
          updatedAt: /* @__PURE__ */ new Date()
        };
        await setApiKey(ctx, updated, opts);
        newApiKey = updated;
      }
    } catch (error) {
      throw new APIError("INTERNAL_SERVER_ERROR", { message: error?.message });
    }
    deleteAllExpiredApiKeys2(ctx.context);
    newApiKey.metadata = schema9.apikey.fields.metadata.transform.output(newApiKey.metadata);
    const { key: _key, ...returningApiKey } = newApiKey;
    return ctx.json({
      ...returningApiKey,
      permissions: returningApiKey.permissions ? safeJSONParse(returningApiKey.permissions) : null
    });
  });
}

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/api-key/routes/index.mjs
var lastChecked = null;
async function deleteAllExpiredApiKeys(ctx, byPassLastCheckTime = false) {
  if (lastChecked && !byPassLastCheckTime) {
    if ((/* @__PURE__ */ new Date()).getTime() - lastChecked.getTime() < 1e4) return;
  }
  lastChecked = /* @__PURE__ */ new Date();
  await ctx.adapter.deleteMany({
    model: API_KEY_TABLE_NAME,
    where: [{
      field: "expiresAt",
      operator: "lt",
      value: /* @__PURE__ */ new Date()
    }, {
      field: "expiresAt",
      operator: "ne",
      value: null
    }]
  }).catch((error) => {
    ctx.logger.error(`Failed to delete expired API keys:`, error);
  });
}
function createApiKeyRoutes({ keyGenerator, opts, schema: schema9 }) {
  return {
    createApiKey: createApiKey({
      keyGenerator,
      opts,
      schema: schema9,
      deleteAllExpiredApiKeys
    }),
    verifyApiKey: verifyApiKey({
      opts,
      schema: schema9,
      deleteAllExpiredApiKeys
    }),
    getApiKey: getApiKey2({
      opts,
      schema: schema9,
      deleteAllExpiredApiKeys
    }),
    updateApiKey: updateApiKey({
      opts,
      schema: schema9,
      deleteAllExpiredApiKeys
    }),
    deleteApiKey: deleteApiKey$1({
      opts,
      schema: schema9,
      deleteAllExpiredApiKeys
    }),
    listApiKeys: listApiKeys$1({
      opts,
      schema: schema9,
      deleteAllExpiredApiKeys
    }),
    deleteAllExpiredApiKeys: deleteAllExpiredApiKeysEndpoint({ deleteAllExpiredApiKeys })
  };
}

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/client/parser.mjs
var PROTO_POLLUTION_PATTERNS = {
  proto: /"(?:_|\\u0{2}5[Ff]){2}(?:p|\\u0{2}70)(?:r|\\u0{2}72)(?:o|\\u0{2}6[Ff])(?:t|\\u0{2}74)(?:o|\\u0{2}6[Ff])(?:_|\\u0{2}5[Ff]){2}"\s*:/,
  constructor: /"(?:c|\\u0063)(?:o|\\u006[Ff])(?:n|\\u006[Ee])(?:s|\\u0073)(?:t|\\u0074)(?:r|\\u0072)(?:u|\\u0075)(?:c|\\u0063)(?:t|\\u0074)(?:o|\\u006[Ff])(?:r|\\u0072)"\s*:/,
  protoShort: /"__proto__"\s*:/,
  constructorShort: /"constructor"\s*:/
};
var JSON_SIGNATURE = /^\s*["[{]|^\s*-?\d{1,16}(\.\d{1,17})?([Ee][+-]?\d+)?\s*$/;
var SPECIAL_VALUES = {
  true: true,
  false: false,
  null: null,
  undefined: void 0,
  nan: NaN,
  infinity: Number.POSITIVE_INFINITY,
  "-infinity": Number.NEGATIVE_INFINITY
};
var ISO_DATE_REGEX = /^(\d{4})-(\d{2})-(\d{2})T(\d{2}):(\d{2}):(\d{2})(?:\.(\d{1,7}))?(?:Z|([+-])(\d{2}):(\d{2}))$/;
function isValidDate(date2) {
  return date2 instanceof Date && !isNaN(date2.getTime());
}
function parseISODate(value) {
  const match = ISO_DATE_REGEX.exec(value);
  if (!match) return null;
  const [, year, month, day, hour, minute, second, ms2, offsetSign, offsetHour, offsetMinute] = match;
  let date2 = new Date(Date.UTC(parseInt(year, 10), parseInt(month, 10) - 1, parseInt(day, 10), parseInt(hour, 10), parseInt(minute, 10), parseInt(second, 10), ms2 ? parseInt(ms2.padEnd(3, "0"), 10) : 0));
  if (offsetSign) {
    const offset = (parseInt(offsetHour, 10) * 60 + parseInt(offsetMinute, 10)) * (offsetSign === "+" ? -1 : 1);
    date2.setUTCMinutes(date2.getUTCMinutes() + offset);
  }
  return isValidDate(date2) ? date2 : null;
}
function betterJSONParse(value, options = {}) {
  const { strict = false, warnings = false, reviver, parseDates = true } = options;
  if (typeof value !== "string") return value;
  const trimmed = value.trim();
  if (trimmed.length > 0 && trimmed[0] === '"' && trimmed.endsWith('"') && !trimmed.slice(1, -1).includes('"')) return trimmed.slice(1, -1);
  const lowerValue = trimmed.toLowerCase();
  if (lowerValue.length <= 9 && lowerValue in SPECIAL_VALUES) return SPECIAL_VALUES[lowerValue];
  if (!JSON_SIGNATURE.test(trimmed)) {
    if (strict) throw new SyntaxError("[better-json] Invalid JSON");
    return value;
  }
  if (Object.entries(PROTO_POLLUTION_PATTERNS).some(([key, pattern]) => {
    const matches = pattern.test(trimmed);
    if (matches && warnings) console.warn(`[better-json] Detected potential prototype pollution attempt using ${key} pattern`);
    return matches;
  }) && strict) throw new Error("[better-json] Potential prototype pollution attempt detected");
  try {
    const secureReviver = (key, value$1) => {
      if (key === "__proto__" || key === "constructor" && value$1 && typeof value$1 === "object" && "prototype" in value$1) {
        if (warnings) console.warn(`[better-json] Dropping "${key}" key to prevent prototype pollution`);
        return;
      }
      if (parseDates && typeof value$1 === "string") {
        const date2 = parseISODate(value$1);
        if (date2) return date2;
      }
      return reviver ? reviver(key, value$1) : value$1;
    };
    return JSON.parse(trimmed, secureReviver);
  } catch (error) {
    if (strict) throw error;
    return value;
  }
}
function parseJSON(value, options = { strict: true }) {
  return betterJSONParse(value, options);
}

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/api-key/schema.mjs
var apiKeySchema = ({ timeWindow, rateLimitMax }) => ({ apikey: { fields: {
  name: {
    type: "string",
    required: false,
    input: false
  },
  start: {
    type: "string",
    required: false,
    input: false
  },
  prefix: {
    type: "string",
    required: false,
    input: false
  },
  key: {
    type: "string",
    required: true,
    input: false,
    index: true
  },
  userId: {
    type: "string",
    references: {
      model: "user",
      field: "id",
      onDelete: "cascade"
    },
    required: true,
    input: false,
    index: true
  },
  refillInterval: {
    type: "number",
    required: false,
    input: false
  },
  refillAmount: {
    type: "number",
    required: false,
    input: false
  },
  lastRefillAt: {
    type: "date",
    required: false,
    input: false
  },
  enabled: {
    type: "boolean",
    required: false,
    input: false,
    defaultValue: true
  },
  rateLimitEnabled: {
    type: "boolean",
    required: false,
    input: false,
    defaultValue: true
  },
  rateLimitTimeWindow: {
    type: "number",
    required: false,
    input: false,
    defaultValue: timeWindow
  },
  rateLimitMax: {
    type: "number",
    required: false,
    input: false,
    defaultValue: rateLimitMax
  },
  requestCount: {
    type: "number",
    required: false,
    input: false,
    defaultValue: 0
  },
  remaining: {
    type: "number",
    required: false,
    input: false
  },
  lastRequest: {
    type: "date",
    required: false,
    input: false
  },
  expiresAt: {
    type: "date",
    required: false,
    input: false
  },
  createdAt: {
    type: "date",
    required: true,
    input: false
  },
  updatedAt: {
    type: "date",
    required: true,
    input: false
  },
  permissions: {
    type: "string",
    required: false,
    input: false
  },
  metadata: {
    type: "string",
    required: false,
    input: true,
    transform: {
      input(value) {
        return JSON.stringify(value);
      },
      output(value) {
        if (!value) return null;
        return parseJSON(value);
      }
    }
  }
} } });

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/api-key/index.mjs
var defaultKeyHasher = async (key) => {
  const hash = await createHash("SHA-256").digest(new TextEncoder().encode(key));
  return base64Url.encode(new Uint8Array(hash), { padding: false });
};
var ERROR_CODES = defineErrorCodes({
  INVALID_METADATA_TYPE: "metadata must be an object or undefined",
  REFILL_AMOUNT_AND_INTERVAL_REQUIRED: "refillAmount is required when refillInterval is provided",
  REFILL_INTERVAL_AND_AMOUNT_REQUIRED: "refillInterval is required when refillAmount is provided",
  USER_BANNED: "User is banned",
  UNAUTHORIZED_SESSION: "Unauthorized or invalid session",
  KEY_NOT_FOUND: "API Key not found",
  KEY_DISABLED: "API Key is disabled",
  KEY_EXPIRED: "API Key has expired",
  USAGE_EXCEEDED: "API Key has reached its usage limit",
  KEY_NOT_RECOVERABLE: "API Key is not recoverable",
  EXPIRES_IN_IS_TOO_SMALL: "The expiresIn is smaller than the predefined minimum value.",
  EXPIRES_IN_IS_TOO_LARGE: "The expiresIn is larger than the predefined maximum value.",
  INVALID_REMAINING: "The remaining count is either too large or too small.",
  INVALID_PREFIX_LENGTH: "The prefix length is either too large or too small.",
  INVALID_NAME_LENGTH: "The name length is either too large or too small.",
  METADATA_DISABLED: "Metadata is disabled.",
  RATE_LIMIT_EXCEEDED: "Rate limit exceeded.",
  NO_VALUES_TO_UPDATE: "No values to update.",
  KEY_DISABLED_EXPIRATION: "Custom key expiration values are disabled.",
  INVALID_API_KEY: "Invalid API key.",
  INVALID_USER_ID_FROM_API_KEY: "The user id from the API key is invalid.",
  INVALID_API_KEY_GETTER_RETURN_TYPE: "API Key getter returned an invalid key type. Expected string.",
  SERVER_ONLY_PROPERTY: "The property you're trying to set can only be set from the server auth instance only.",
  FAILED_TO_UPDATE_API_KEY: "Failed to update API key",
  NAME_REQUIRED: "API Key name is required."
});
var API_KEY_TABLE_NAME = "apikey";
var apiKey = (options) => {
  const opts = {
    ...options,
    apiKeyHeaders: options?.apiKeyHeaders ?? "x-api-key",
    defaultKeyLength: options?.defaultKeyLength || 64,
    maximumPrefixLength: options?.maximumPrefixLength ?? 32,
    minimumPrefixLength: options?.minimumPrefixLength ?? 1,
    maximumNameLength: options?.maximumNameLength ?? 32,
    minimumNameLength: options?.minimumNameLength ?? 1,
    enableMetadata: options?.enableMetadata ?? false,
    disableKeyHashing: options?.disableKeyHashing ?? false,
    requireName: options?.requireName ?? false,
    storage: options?.storage ?? "database",
    rateLimit: {
      enabled: options?.rateLimit?.enabled === void 0 ? true : options?.rateLimit?.enabled,
      timeWindow: options?.rateLimit?.timeWindow ?? 1e3 * 60 * 60 * 24,
      maxRequests: options?.rateLimit?.maxRequests ?? 10
    },
    keyExpiration: {
      defaultExpiresIn: options?.keyExpiration?.defaultExpiresIn ?? null,
      disableCustomExpiresTime: options?.keyExpiration?.disableCustomExpiresTime ?? false,
      maxExpiresIn: options?.keyExpiration?.maxExpiresIn ?? 365,
      minExpiresIn: options?.keyExpiration?.minExpiresIn ?? 1
    },
    startingCharactersConfig: {
      shouldStore: options?.startingCharactersConfig?.shouldStore ?? true,
      charactersLength: options?.startingCharactersConfig?.charactersLength ?? 6
    },
    enableSessionForAPIKeys: options?.enableSessionForAPIKeys ?? false,
    fallbackToDatabase: options?.fallbackToDatabase ?? false,
    customStorage: options?.customStorage,
    deferUpdates: options?.deferUpdates ?? false
  };
  const schema9 = mergeSchema(apiKeySchema({
    rateLimitMax: opts.rateLimit.maxRequests,
    timeWindow: opts.rateLimit.timeWindow
  }), opts.schema);
  const getter = opts.customAPIKeyGetter || ((ctx) => {
    if (Array.isArray(opts.apiKeyHeaders)) for (const header of opts.apiKeyHeaders) {
      const value = ctx.headers?.get(header);
      if (value) return value;
    }
    else return ctx.headers?.get(opts.apiKeyHeaders);
  });
  const routes = createApiKeyRoutes({
    keyGenerator: opts.customKeyGenerator || (async (options$1) => {
      const key = generateRandomString(options$1.length, "a-z", "A-Z");
      return `${options$1.prefix || ""}${key}`;
    }),
    opts,
    schema: schema9
  });
  return {
    id: "api-key",
    $ERROR_CODES: ERROR_CODES,
    hooks: { before: [{
      matcher: (ctx) => !!getter(ctx) && opts.enableSessionForAPIKeys,
      handler: createAuthMiddleware(async (ctx) => {
        const key = getter(ctx);
        if (typeof key !== "string") throw new APIError("BAD_REQUEST", { message: ERROR_CODES.INVALID_API_KEY_GETTER_RETURN_TYPE });
        if (key.length < opts.defaultKeyLength) throw new APIError("FORBIDDEN", { message: ERROR_CODES.INVALID_API_KEY });
        if (opts.customAPIKeyValidator) {
          if (!await opts.customAPIKeyValidator({
            ctx,
            key
          })) throw new APIError("FORBIDDEN", { message: ERROR_CODES.INVALID_API_KEY });
        }
        const apiKey$1 = await validateApiKey({
          hashedKey: opts.disableKeyHashing ? key : await defaultKeyHasher(key),
          ctx,
          opts,
          schema: schema9
        });
        const cleanupTask = deleteAllExpiredApiKeys(ctx.context).catch((err) => {
          ctx.context.logger.error("Failed to delete expired API keys:", err);
        });
        if (opts.deferUpdates) ctx.context.runInBackground(cleanupTask);
        const user = await ctx.context.internalAdapter.findUserById(apiKey$1.userId);
        if (!user) throw new APIError("UNAUTHORIZED", { message: ERROR_CODES.INVALID_USER_ID_FROM_API_KEY });
        const session = {
          user,
          session: {
            id: apiKey$1.id,
            token: key,
            userId: apiKey$1.userId,
            userAgent: ctx.request?.headers.get("user-agent") ?? null,
            ipAddress: ctx.request ? getIp(ctx.request, ctx.context.options) : null,
            createdAt: /* @__PURE__ */ new Date(),
            updatedAt: /* @__PURE__ */ new Date(),
            expiresAt: apiKey$1.expiresAt || getDate(ctx.context.options.session?.expiresIn || 3600 * 24 * 7, "ms")
          }
        };
        ctx.context.session = session;
        if (ctx.path === "/get-session") return session;
        else return { context: ctx };
      })
    }] },
    endpoints: {
      createApiKey: routes.createApiKey,
      verifyApiKey: routes.verifyApiKey,
      getApiKey: routes.getApiKey,
      updateApiKey: routes.updateApiKey,
      deleteApiKey: routes.deleteApiKey,
      listApiKeys: routes.listApiKeys,
      deleteAllExpiredApiKeys: routes.deleteAllExpiredApiKeys
    },
    schema: schema9,
    options
  };
};

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/bearer/index.mjs
var bearer = (options) => {
  return {
    id: "bearer",
    hooks: {
      before: [{
        matcher(context) {
          return Boolean(context.request?.headers.get("authorization") || context.headers?.get("authorization"));
        },
        handler: createAuthMiddleware(async (c) => {
          const token = c.request?.headers.get("authorization")?.replace("Bearer ", "") || c.headers?.get("Authorization")?.replace("Bearer ", "");
          if (!token) return;
          let signedToken = "";
          if (token.includes(".")) signedToken = token.replace("=", "");
          else {
            if (options?.requireSignature) return;
            signedToken = (await serializeSignedCookie("", token, c.context.secret)).replace("=", "");
          }
          try {
            const decodedToken = decodeURIComponent(signedToken);
            if (!await createHMAC("SHA-256", "base64urlnopad").verify(c.context.secret, decodedToken.split(".")[0], decodedToken.split(".")[1])) return;
          } catch {
            return;
          }
          const existingHeaders = c.request?.headers || c.headers;
          const headers = new Headers({ ...Object.fromEntries(existingHeaders?.entries()) });
          headers.append("cookie", `${c.context.authCookies.sessionToken.name}=${signedToken}`);
          return { context: { headers } };
        })
      }],
      after: [{
        matcher(context) {
          return true;
        },
        handler: createAuthMiddleware(async (ctx) => {
          const setCookie = ctx.context.responseHeaders?.get("set-cookie");
          if (!setCookie) return;
          const parsedCookies = parseSetCookieHeader(setCookie);
          const cookieName = ctx.context.authCookies.sessionToken.name;
          const sessionCookie = parsedCookies.get(cookieName);
          if (!sessionCookie || !sessionCookie.value || sessionCookie["max-age"] === 0) return;
          const token = sessionCookie.value;
          const exposedHeaders = ctx.context.responseHeaders?.get("access-control-expose-headers") || "";
          const headersSet = new Set(exposedHeaders.split(",").map((header) => header.trim()).filter(Boolean));
          headersSet.add("set-auth-token");
          ctx.setHeader("set-auth-token", token);
          ctx.setHeader("Access-Control-Expose-Headers", Array.from(headersSet).join(", "));
        })
      }]
    },
    options
  };
};

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/utils/middleware-response.mjs
var middlewareResponse = ({ message, status }) => ({ response: new Response(JSON.stringify({ message }), { status }) });

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/captcha/constants.mjs
var defaultEndpoints = [
  "/sign-up/email",
  "/sign-in/email",
  "/request-password-reset"
];
var Providers = {
  CLOUDFLARE_TURNSTILE: "cloudflare-turnstile",
  GOOGLE_RECAPTCHA: "google-recaptcha",
  HCAPTCHA: "hcaptcha",
  CAPTCHAFOX: "captchafox"
};
var siteVerifyMap = {
  [Providers.CLOUDFLARE_TURNSTILE]: "https://challenges.cloudflare.com/turnstile/v0/siteverify",
  [Providers.GOOGLE_RECAPTCHA]: "https://www.google.com/recaptcha/api/siteverify",
  [Providers.HCAPTCHA]: "https://api.hcaptcha.com/siteverify",
  [Providers.CAPTCHAFOX]: "https://api.captchafox.com/siteverify"
};

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/captcha/error-codes.mjs
var EXTERNAL_ERROR_CODES = defineErrorCodes({
  VERIFICATION_FAILED: "Captcha verification failed",
  MISSING_RESPONSE: "Missing CAPTCHA response",
  UNKNOWN_ERROR: "Something went wrong"
});
var INTERNAL_ERROR_CODES = defineErrorCodes({
  MISSING_SECRET_KEY: "Missing secret key",
  SERVICE_UNAVAILABLE: "CAPTCHA service unavailable"
});

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/captcha/utils.mjs
var encodeToURLParams = (obj) => {
  if (typeof obj !== "object" || obj === null || Array.isArray(obj)) throw new Error("Input must be a non-null object.");
  const params = new URLSearchParams();
  for (const [key, value] of Object.entries(obj)) if (value !== void 0 && value !== null) params.append(key, String(value));
  return params.toString();
};

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/captcha/verify-handlers/captchafox.mjs
var captchaFox = async ({ siteVerifyURL, captchaResponse, secretKey, siteKey, remoteIP }) => {
  const response = await betterFetch(siteVerifyURL, {
    method: "POST",
    headers: { "Content-Type": "application/x-www-form-urlencoded" },
    body: encodeToURLParams({
      secret: secretKey,
      response: captchaResponse,
      ...siteKey && { sitekey: siteKey },
      ...remoteIP && { remoteIp: remoteIP }
    })
  });
  if (!response.data || response.error) throw new Error(INTERNAL_ERROR_CODES.SERVICE_UNAVAILABLE);
  if (!response.data.success) return middlewareResponse({
    message: EXTERNAL_ERROR_CODES.VERIFICATION_FAILED,
    status: 403
  });
};

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/captcha/verify-handlers/cloudflare-turnstile.mjs
var cloudflareTurnstile = async ({ siteVerifyURL, captchaResponse, secretKey, remoteIP }) => {
  const response = await betterFetch(siteVerifyURL, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      secret: secretKey,
      response: captchaResponse,
      ...remoteIP && { remoteip: remoteIP }
    })
  });
  if (!response.data || response.error) throw new Error(INTERNAL_ERROR_CODES.SERVICE_UNAVAILABLE);
  if (!response.data.success) return middlewareResponse({
    message: EXTERNAL_ERROR_CODES.VERIFICATION_FAILED,
    status: 403
  });
};

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/captcha/verify-handlers/google-recaptcha.mjs
var isV3 = (response) => {
  return "score" in response && typeof response.score === "number";
};
var googleRecaptcha = async ({ siteVerifyURL, captchaResponse, secretKey, minScore = 0.5, remoteIP }) => {
  const response = await betterFetch(siteVerifyURL, {
    method: "POST",
    headers: { "Content-Type": "application/x-www-form-urlencoded" },
    body: encodeToURLParams({
      secret: secretKey,
      response: captchaResponse,
      ...remoteIP && { remoteip: remoteIP }
    })
  });
  if (!response.data || response.error) throw new Error(INTERNAL_ERROR_CODES.SERVICE_UNAVAILABLE);
  if (!response.data.success || isV3(response.data) && response.data.score < minScore) return middlewareResponse({
    message: EXTERNAL_ERROR_CODES.VERIFICATION_FAILED,
    status: 403
  });
};

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/captcha/verify-handlers/h-captcha.mjs
var hCaptcha = async ({ siteVerifyURL, captchaResponse, secretKey, siteKey, remoteIP }) => {
  const response = await betterFetch(siteVerifyURL, {
    method: "POST",
    headers: { "Content-Type": "application/x-www-form-urlencoded" },
    body: encodeToURLParams({
      secret: secretKey,
      response: captchaResponse,
      ...siteKey && { sitekey: siteKey },
      ...remoteIP && { remoteip: remoteIP }
    })
  });
  if (!response.data || response.error) throw new Error(INTERNAL_ERROR_CODES.SERVICE_UNAVAILABLE);
  if (!response.data.success) return middlewareResponse({
    message: EXTERNAL_ERROR_CODES.VERIFICATION_FAILED,
    status: 403
  });
};

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/captcha/index.mjs
var captcha = (options) => ({
  id: "captcha",
  onRequest: async (request, ctx) => {
    try {
      if (!(options.endpoints?.length ? options.endpoints : defaultEndpoints).some((endpoint) => request.url.includes(endpoint))) return void 0;
      if (!options.secretKey) throw new Error(INTERNAL_ERROR_CODES.MISSING_SECRET_KEY);
      const captchaResponse = request.headers.get("x-captcha-response");
      const remoteUserIP = getIp(request, ctx.options) ?? void 0;
      if (!captchaResponse) return middlewareResponse({
        message: EXTERNAL_ERROR_CODES.MISSING_RESPONSE,
        status: 400
      });
      const handlerParams = {
        siteVerifyURL: options.siteVerifyURLOverride || siteVerifyMap[options.provider],
        captchaResponse,
        secretKey: options.secretKey,
        remoteIP: remoteUserIP
      };
      if (options.provider === Providers.CLOUDFLARE_TURNSTILE) return await cloudflareTurnstile(handlerParams);
      if (options.provider === Providers.GOOGLE_RECAPTCHA) return await googleRecaptcha({
        ...handlerParams,
        minScore: options.minScore
      });
      if (options.provider === Providers.HCAPTCHA) return await hCaptcha({
        ...handlerParams,
        siteKey: options.siteKey
      });
      if (options.provider === Providers.CAPTCHAFOX) return await captchaFox({
        ...handlerParams,
        siteKey: options.siteKey
      });
    } catch (_error) {
      const errorMessage = _error instanceof Error ? _error.message : void 0;
      ctx.logger.error(errorMessage ?? "Unknown error", {
        endpoint: request.url,
        message: _error
      });
      return middlewareResponse({
        message: EXTERNAL_ERROR_CODES.UNKNOWN_ERROR,
        status: 500
      });
    }
  },
  options
});

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/custom-session/index.mjs
var getSessionQuerySchema = optional(object({
  disableCookieCache: boolean().meta({ description: "Disable cookie cache and fetch session from database" }).or(string().transform((v) => v === "true")).optional(),
  disableRefresh: boolean().meta({ description: "Disable session refresh. Useful for checking session status, without updating the session" }).optional()
}));
var customSession = (fn, options, pluginOptions) => {
  return {
    id: "custom-session",
    hooks: { after: [{
      matcher: (ctx) => ctx.path === "/multi-session/list-device-sessions" && (pluginOptions?.shouldMutateListDeviceSessionsEndpoint ?? false),
      handler: createAuthMiddleware(async (ctx) => {
        const response = await getEndpointResponse(ctx);
        if (!response) return;
        const newResponse = await Promise.all(response.map(async (v) => await fn(v, ctx)));
        return ctx.json(newResponse);
      })
    }] },
    endpoints: { getSession: createAuthEndpoint("/get-session", {
      method: "GET",
      query: getSessionQuerySchema,
      metadata: {
        CUSTOM_SESSION: true,
        openapi: {
          description: "Get custom session data",
          responses: { "200": {
            description: "Success",
            content: { "application/json": { schema: {
              type: "array",
              nullable: true,
              items: { $ref: "#/components/schemas/Session" }
            } } }
          } }
        }
      },
      requireHeaders: true
    }, async (ctx) => {
      const session = await getSession()({
        ...ctx,
        asResponse: false,
        headers: ctx.headers,
        returnHeaders: true
      }).catch((e) => {
        return null;
      });
      if (!session?.response) return ctx.json(null);
      const fnResult = await fn(session.response, ctx);
      const setCookie = session.headers.get("set-cookie");
      if (setCookie) {
        ctx.setHeader("set-cookie", setCookie);
        session.headers.delete("set-cookie");
      }
      session.headers.forEach((value, key) => {
        ctx.setHeader(key, value);
      });
      return ctx.json(fnResult);
    }) },
    $Infer: { Session: {} },
    options: pluginOptions
  };
};

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/device-authorization/error-codes.mjs
var DEVICE_AUTHORIZATION_ERROR_CODES = defineErrorCodes({
  INVALID_DEVICE_CODE: "Invalid device code",
  EXPIRED_DEVICE_CODE: "Device code has expired",
  EXPIRED_USER_CODE: "User code has expired",
  AUTHORIZATION_PENDING: "Authorization pending",
  ACCESS_DENIED: "Access denied",
  INVALID_USER_CODE: "Invalid user code",
  DEVICE_CODE_ALREADY_PROCESSED: "Device code already processed",
  POLLING_TOO_FREQUENTLY: "Polling too frequently",
  USER_NOT_FOUND: "User not found",
  FAILED_TO_CREATE_SESSION: "Failed to create session",
  INVALID_DEVICE_CODE_STATUS: "Invalid device code status",
  AUTHENTICATION_REQUIRED: "Authentication required"
});

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/device-authorization/routes.mjs
var defaultCharset = "ABCDEFGHJKLMNPQRSTUVWXYZ23456789";
var deviceCodeBodySchema = object({
  client_id: string().meta({ description: "The client ID of the application" }),
  scope: string().meta({ description: "Space-separated list of scopes" }).optional()
});
var deviceCodeErrorSchema = object({
  error: _enum(["invalid_request", "invalid_client"]).meta({ description: "Error code" }),
  error_description: string().meta({ description: "Detailed error description" })
});
var deviceCode = (opts) => {
  const generateDeviceCode = async () => {
    if (opts.generateDeviceCode) return opts.generateDeviceCode();
    return defaultGenerateDeviceCode(opts.deviceCodeLength);
  };
  const generateUserCode = async () => {
    if (opts.generateUserCode) return opts.generateUserCode();
    return defaultGenerateUserCode(opts.userCodeLength);
  };
  return createAuthEndpoint("/device/code", {
    method: "POST",
    body: deviceCodeBodySchema,
    error: deviceCodeErrorSchema,
    metadata: { openapi: {
      description: `Request a device and user code

Follow [rfc8628#section-3.2](https://datatracker.ietf.org/doc/html/rfc8628#section-3.2)`,
      responses: {
        200: {
          description: "Success",
          content: { "application/json": { schema: {
            type: "object",
            properties: {
              device_code: {
                type: "string",
                description: "The device verification code"
              },
              user_code: {
                type: "string",
                description: "The user code to display"
              },
              verification_uri: {
                type: "string",
                format: "uri",
                description: "The URL for user verification. Defaults to /device if not configured."
              },
              verification_uri_complete: {
                type: "string",
                format: "uri",
                description: "The complete URL with user code as query parameter."
              },
              expires_in: {
                type: "number",
                description: "Lifetime in seconds of the device code"
              },
              interval: {
                type: "number",
                description: "Minimum polling interval in seconds"
              }
            }
          } } }
        },
        400: {
          description: "Error response",
          content: { "application/json": { schema: {
            type: "object",
            properties: {
              error: {
                type: "string",
                enum: ["invalid_request", "invalid_client"]
              },
              error_description: { type: "string" }
            }
          } } }
        }
      }
    } }
  }, async (ctx) => {
    if (opts.validateClient) {
      if (!await opts.validateClient(ctx.body.client_id)) throw new APIError("BAD_REQUEST", {
        error: "invalid_client",
        error_description: "Invalid client ID"
      });
    }
    if (opts.onDeviceAuthRequest) await opts.onDeviceAuthRequest(ctx.body.client_id, ctx.body.scope);
    const deviceCode$1 = await generateDeviceCode();
    const userCode = await generateUserCode();
    const expiresIn = ms(opts.expiresIn);
    const expiresAt = new Date(Date.now() + expiresIn);
    await ctx.context.adapter.create({
      model: "deviceCode",
      data: {
        deviceCode: deviceCode$1,
        userCode,
        expiresAt,
        status: "pending",
        pollingInterval: ms(opts.interval),
        clientId: ctx.body.client_id,
        scope: ctx.body.scope
      }
    });
    const { verificationUri, verificationUriComplete } = buildVerificationUris(opts.verificationUri, ctx.context.baseURL, userCode);
    return ctx.json({
      device_code: deviceCode$1,
      user_code: userCode,
      verification_uri: verificationUri,
      verification_uri_complete: verificationUriComplete,
      expires_in: Math.floor(expiresIn / 1e3),
      interval: Math.floor(ms(opts.interval) / 1e3)
    }, { headers: { "Cache-Control": "no-store" } });
  });
};
var deviceTokenBodySchema = object({
  grant_type: literal("urn:ietf:params:oauth:grant-type:device_code").meta({ description: "The grant type for device flow" }),
  device_code: string().meta({ description: "The device verification code" }),
  client_id: string().meta({ description: "The client ID of the application" })
});
var deviceTokenErrorSchema = object({
  error: _enum([
    "authorization_pending",
    "slow_down",
    "expired_token",
    "access_denied",
    "invalid_request",
    "invalid_grant"
  ]).meta({ description: "Error code" }),
  error_description: string().meta({ description: "Detailed error description" })
});
var deviceToken = (opts) => createAuthEndpoint("/device/token", {
  method: "POST",
  body: deviceTokenBodySchema,
  error: deviceTokenErrorSchema,
  metadata: { openapi: {
    description: `Exchange device code for access token

Follow [rfc8628#section-3.4](https://datatracker.ietf.org/doc/html/rfc8628#section-3.4)`,
    responses: {
      200: {
        description: "Success",
        content: { "application/json": { schema: {
          type: "object",
          properties: {
            session: { $ref: "#/components/schemas/Session" },
            user: { $ref: "#/components/schemas/User" }
          }
        } } }
      },
      400: {
        description: "Error response",
        content: { "application/json": { schema: {
          type: "object",
          properties: {
            error: {
              type: "string",
              enum: [
                "authorization_pending",
                "slow_down",
                "expired_token",
                "access_denied",
                "invalid_request",
                "invalid_grant"
              ]
            },
            error_description: { type: "string" }
          }
        } } }
      }
    }
  } }
}, async (ctx) => {
  const { device_code, client_id } = ctx.body;
  if (opts.validateClient) {
    if (!await opts.validateClient(client_id)) throw new APIError("BAD_REQUEST", {
      error: "invalid_grant",
      error_description: "Invalid client ID"
    });
  }
  const deviceCodeRecord = await ctx.context.adapter.findOne({
    model: "deviceCode",
    where: [{
      field: "deviceCode",
      value: device_code
    }]
  });
  if (!deviceCodeRecord) throw new APIError("BAD_REQUEST", {
    error: "invalid_grant",
    error_description: DEVICE_AUTHORIZATION_ERROR_CODES.INVALID_DEVICE_CODE
  });
  if (deviceCodeRecord.clientId && deviceCodeRecord.clientId !== client_id) throw new APIError("BAD_REQUEST", {
    error: "invalid_grant",
    error_description: "Client ID mismatch"
  });
  if (deviceCodeRecord.lastPolledAt && deviceCodeRecord.pollingInterval) {
    if (Date.now() - new Date(deviceCodeRecord.lastPolledAt).getTime() < deviceCodeRecord.pollingInterval) throw new APIError("BAD_REQUEST", {
      error: "slow_down",
      error_description: DEVICE_AUTHORIZATION_ERROR_CODES.POLLING_TOO_FREQUENTLY
    });
  }
  await ctx.context.adapter.update({
    model: "deviceCode",
    where: [{
      field: "id",
      value: deviceCodeRecord.id
    }],
    update: { lastPolledAt: /* @__PURE__ */ new Date() }
  });
  if (deviceCodeRecord.expiresAt < /* @__PURE__ */ new Date()) {
    await ctx.context.adapter.delete({
      model: "deviceCode",
      where: [{
        field: "id",
        value: deviceCodeRecord.id
      }]
    });
    throw new APIError("BAD_REQUEST", {
      error: "expired_token",
      error_description: DEVICE_AUTHORIZATION_ERROR_CODES.EXPIRED_DEVICE_CODE
    });
  }
  if (deviceCodeRecord.status === "pending") throw new APIError("BAD_REQUEST", {
    error: "authorization_pending",
    error_description: DEVICE_AUTHORIZATION_ERROR_CODES.AUTHORIZATION_PENDING
  });
  if (deviceCodeRecord.status === "denied") {
    await ctx.context.adapter.delete({
      model: "deviceCode",
      where: [{
        field: "id",
        value: deviceCodeRecord.id
      }]
    });
    throw new APIError("BAD_REQUEST", {
      error: "access_denied",
      error_description: DEVICE_AUTHORIZATION_ERROR_CODES.ACCESS_DENIED
    });
  }
  if (deviceCodeRecord.status === "approved" && deviceCodeRecord.userId) {
    const user = await ctx.context.internalAdapter.findUserById(deviceCodeRecord.userId);
    if (!user) throw new APIError("INTERNAL_SERVER_ERROR", {
      error: "server_error",
      error_description: DEVICE_AUTHORIZATION_ERROR_CODES.USER_NOT_FOUND
    });
    const session = await ctx.context.internalAdapter.createSession(user.id);
    if (!session) throw new APIError("INTERNAL_SERVER_ERROR", {
      error: "server_error",
      error_description: DEVICE_AUTHORIZATION_ERROR_CODES.FAILED_TO_CREATE_SESSION
    });
    ctx.context.setNewSession({
      session,
      user
    });
    if (ctx.context.options.secondaryStorage) await ctx.context.secondaryStorage?.set(session.token, JSON.stringify({
      user,
      session
    }), Math.floor((new Date(session.expiresAt).getTime() - Date.now()) / 1e3));
    await ctx.context.adapter.delete({
      model: "deviceCode",
      where: [{
        field: "id",
        value: deviceCodeRecord.id
      }]
    });
    return ctx.json({
      access_token: session.token,
      token_type: "Bearer",
      expires_in: Math.floor((new Date(session.expiresAt).getTime() - Date.now()) / 1e3),
      scope: deviceCodeRecord.scope || ""
    }, { headers: {
      "Cache-Control": "no-store",
      Pragma: "no-cache"
    } });
  }
  throw new APIError("INTERNAL_SERVER_ERROR", {
    error: "server_error",
    error_description: DEVICE_AUTHORIZATION_ERROR_CODES.INVALID_DEVICE_CODE_STATUS
  });
});
var deviceVerify = createAuthEndpoint("/device", {
  method: "GET",
  query: object({ user_code: string().meta({ description: "The user code to verify" }) }),
  error: object({
    error: _enum(["invalid_request"]).meta({ description: "Error code" }),
    error_description: string().meta({ description: "Detailed error description" })
  }),
  metadata: { openapi: {
    description: "Verify user code and get device authorization status",
    responses: { 200: {
      description: "Device authorization status",
      content: { "application/json": { schema: {
        type: "object",
        properties: {
          user_code: {
            type: "string",
            description: "The user code to verify"
          },
          status: {
            type: "string",
            enum: [
              "pending",
              "approved",
              "denied"
            ],
            description: "Current status of the device authorization"
          }
        }
      } } }
    } }
  } }
}, async (ctx) => {
  const { user_code } = ctx.query;
  const cleanUserCode = user_code.replace(/-/g, "");
  const deviceCodeRecord = await ctx.context.adapter.findOne({
    model: "deviceCode",
    where: [{
      field: "userCode",
      value: cleanUserCode
    }]
  });
  if (!deviceCodeRecord) throw new APIError("BAD_REQUEST", {
    error: "invalid_request",
    error_description: DEVICE_AUTHORIZATION_ERROR_CODES.INVALID_USER_CODE
  });
  if (deviceCodeRecord.expiresAt < /* @__PURE__ */ new Date()) throw new APIError("BAD_REQUEST", {
    error: "expired_token",
    error_description: DEVICE_AUTHORIZATION_ERROR_CODES.EXPIRED_USER_CODE
  });
  return ctx.json({
    user_code,
    status: deviceCodeRecord.status
  });
});
var deviceApprove = createAuthEndpoint("/device/approve", {
  method: "POST",
  body: object({ userCode: string().meta({ description: "The user code to approve" }) }),
  error: object({
    error: _enum([
      "invalid_request",
      "expired_token",
      "device_code_already_processed"
    ]).meta({ description: "Error code" }),
    error_description: string().meta({ description: "Detailed error description" })
  }),
  requireHeaders: true,
  metadata: { openapi: {
    description: "Approve device authorization",
    responses: { 200: {
      description: "Success",
      content: { "application/json": { schema: {
        type: "object",
        properties: { success: { type: "boolean" } }
      } } }
    } }
  } }
}, async (ctx) => {
  const session = await getSessionFromCtx(ctx);
  if (!session) throw new APIError("UNAUTHORIZED", {
    error: "unauthorized",
    error_description: DEVICE_AUTHORIZATION_ERROR_CODES.AUTHENTICATION_REQUIRED
  });
  const { userCode } = ctx.body;
  const cleanUserCode = userCode.replace(/-/g, "");
  const deviceCodeRecord = await ctx.context.adapter.findOne({
    model: "deviceCode",
    where: [{
      field: "userCode",
      value: cleanUserCode
    }]
  });
  if (!deviceCodeRecord) throw new APIError("BAD_REQUEST", {
    error: "invalid_request",
    error_description: DEVICE_AUTHORIZATION_ERROR_CODES.INVALID_USER_CODE
  });
  if (deviceCodeRecord.expiresAt < /* @__PURE__ */ new Date()) throw new APIError("BAD_REQUEST", {
    error: "expired_token",
    error_description: DEVICE_AUTHORIZATION_ERROR_CODES.EXPIRED_USER_CODE
  });
  if (deviceCodeRecord.status !== "pending") throw new APIError("BAD_REQUEST", {
    error: "invalid_request",
    error_description: DEVICE_AUTHORIZATION_ERROR_CODES.DEVICE_CODE_ALREADY_PROCESSED
  });
  await ctx.context.adapter.update({
    model: "deviceCode",
    where: [{
      field: "id",
      value: deviceCodeRecord.id
    }],
    update: {
      status: "approved",
      userId: session.user.id
    }
  });
  return ctx.json({ success: true });
});
var deviceDeny = createAuthEndpoint("/device/deny", {
  method: "POST",
  body: object({ userCode: string().meta({ description: "The user code to deny" }) }),
  error: object({
    error: _enum(["invalid_request", "expired_token"]).meta({ description: "Error code" }),
    error_description: string().meta({ description: "Detailed error description" })
  }),
  metadata: { openapi: {
    description: "Deny device authorization",
    responses: { 200: {
      description: "Success",
      content: { "application/json": { schema: {
        type: "object",
        properties: { success: { type: "boolean" } }
      } } }
    } }
  } }
}, async (ctx) => {
  const { userCode } = ctx.body;
  const cleanUserCode = userCode.replace(/-/g, "");
  const deviceCodeRecord = await ctx.context.adapter.findOne({
    model: "deviceCode",
    where: [{
      field: "userCode",
      value: cleanUserCode
    }]
  });
  if (!deviceCodeRecord) throw new APIError("BAD_REQUEST", {
    error: "invalid_request",
    error_description: DEVICE_AUTHORIZATION_ERROR_CODES.INVALID_USER_CODE
  });
  if (deviceCodeRecord.expiresAt < /* @__PURE__ */ new Date()) throw new APIError("BAD_REQUEST", {
    error: "expired_token",
    error_description: DEVICE_AUTHORIZATION_ERROR_CODES.EXPIRED_USER_CODE
  });
  if (deviceCodeRecord.status !== "pending") throw new APIError("BAD_REQUEST", {
    error: "invalid_request",
    error_description: DEVICE_AUTHORIZATION_ERROR_CODES.DEVICE_CODE_ALREADY_PROCESSED
  });
  await ctx.context.adapter.update({
    model: "deviceCode",
    where: [{
      field: "id",
      value: deviceCodeRecord.id
    }],
    update: { status: "denied" }
  });
  return ctx.json({ success: true });
});
var buildVerificationUris = (verificationUri, baseURL, userCode) => {
  const uri = verificationUri || "/device";
  let verificationUrl;
  try {
    verificationUrl = new URL(uri);
  } catch {
    verificationUrl = new URL(uri, baseURL);
  }
  const verificationUriCompleteUrl = new URL(verificationUrl);
  verificationUriCompleteUrl.searchParams.set("user_code", userCode);
  return {
    verificationUri: verificationUrl.toString(),
    verificationUriComplete: verificationUriCompleteUrl.toString()
  };
};
var defaultGenerateDeviceCode = (length) => {
  return generateRandomString(length, "a-z", "A-Z", "0-9");
};
var defaultGenerateUserCode = (length) => {
  const chars = new Uint8Array(length);
  return Array.from(crypto.getRandomValues(chars)).map((byte) => defaultCharset[byte % 32]).join("");
};

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/device-authorization/schema.mjs
var schema3 = { deviceCode: { fields: {
  deviceCode: {
    type: "string",
    required: true
  },
  userCode: {
    type: "string",
    required: true
  },
  userId: {
    type: "string",
    required: false
  },
  expiresAt: {
    type: "date",
    required: true
  },
  status: {
    type: "string",
    required: true
  },
  lastPolledAt: {
    type: "date",
    required: false
  },
  pollingInterval: {
    type: "number",
    required: false
  },
  clientId: {
    type: "string",
    required: false
  },
  scope: {
    type: "string",
    required: false
  }
} } };
object({
  id: string(),
  deviceCode: string(),
  userCode: string(),
  userId: string().optional(),
  expiresAt: date(),
  status: string(),
  lastPolledAt: date().optional(),
  pollingInterval: number().optional(),
  clientId: string().optional(),
  scope: string().optional()
});

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/device-authorization/index.mjs
var timeStringSchema = custom((val) => {
  if (typeof val !== "string") return false;
  try {
    ms(val);
    return true;
  } catch {
    return false;
  }
}, { message: "Invalid time string format. Use formats like '30m', '5s', '1h', etc." });
var deviceAuthorizationOptionsSchema = object({
  expiresIn: timeStringSchema.default("30m").describe("Time in seconds until the device code expires. Use formats like '30m', '5s', '1h', etc."),
  interval: timeStringSchema.default("5s").describe("Time in seconds between polling attempts. Use formats like '30m', '5s', '1h', etc."),
  deviceCodeLength: number().int().positive().default(40).describe("Length of the device code to be generated. Default is 40 characters."),
  userCodeLength: number().int().positive().default(8).describe("Length of the user code to be generated. Default is 8 characters."),
  generateDeviceCode: custom((val) => typeof val === "function", { message: "generateDeviceCode must be a function that returns a string or a promise that resolves to a string." }).optional().describe("Function to generate a device code. If not provided, a default random string generator will be used."),
  generateUserCode: custom((val) => typeof val === "function", { message: "generateUserCode must be a function that returns a string or a promise that resolves to a string." }).optional().describe("Function to generate a user code. If not provided, a default random string generator will be used."),
  validateClient: custom((val) => typeof val === "function", { message: "validateClient must be a function that returns a boolean or a promise that resolves to a boolean." }).optional().describe("Function to validate the client ID. If not provided, no validation will be performed."),
  onDeviceAuthRequest: custom((val) => typeof val === "function", { message: "onDeviceAuthRequest must be a function that returns void or a promise that resolves to void." }).optional().describe("Function to handle device authorization requests. If not provided, no additional actions will be taken."),
  verificationUri: string().optional().describe("The URI where users verify their device code. Can be an absolute URL (https://example.com/device) or relative path (/custom-path). This will be returned as verification_uri in the device code response. If not provided, defaults to /device."),
  schema: custom(() => true)
});
var deviceAuthorization = (options = {}) => {
  const opts = deviceAuthorizationOptionsSchema.parse(options);
  return {
    id: "device-authorization",
    schema: mergeSchema(schema3, options?.schema),
    endpoints: {
      deviceCode: deviceCode(opts),
      deviceToken: deviceToken(opts),
      deviceVerify,
      deviceApprove,
      deviceDeny
    },
    $ERROR_CODES: DEVICE_AUTHORIZATION_ERROR_CODES,
    options
  };
};

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/email-otp/utils.mjs
var defaultKeyHasher2 = async (otp) => {
  const hash = await createHash("SHA-256").digest(new TextEncoder().encode(otp));
  return base64Url.encode(new Uint8Array(hash), { padding: false });
};
function splitAtLastColon(input) {
  const idx = input.lastIndexOf(":");
  if (idx === -1) return [input, ""];
  return [input.slice(0, idx), input.slice(idx + 1)];
}

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/email-otp/otp-token.mjs
async function storeOTP(ctx, opts, otp) {
  if (opts.storeOTP === "encrypted") return await symmetricEncrypt({
    key: ctx.context.secret,
    data: otp
  });
  if (opts.storeOTP === "hashed") return await defaultKeyHasher2(otp);
  if (typeof opts.storeOTP === "object" && "hash" in opts.storeOTP) return await opts.storeOTP.hash(otp);
  if (typeof opts.storeOTP === "object" && "encrypt" in opts.storeOTP) return await opts.storeOTP.encrypt(otp);
  return otp;
}
async function verifyStoredOTP(ctx, opts, storedOtp, otp) {
  if (opts.storeOTP === "encrypted") return constantTimeEqual(await symmetricDecrypt({
    key: ctx.context.secret,
    data: storedOtp
  }), otp);
  if (opts.storeOTP === "hashed") return constantTimeEqual(await defaultKeyHasher2(otp), storedOtp);
  if (typeof opts.storeOTP === "object" && "hash" in opts.storeOTP) return constantTimeEqual(await opts.storeOTP.hash(otp), storedOtp);
  if (typeof opts.storeOTP === "object" && "decrypt" in opts.storeOTP) return constantTimeEqual(await opts.storeOTP.decrypt(storedOtp), otp);
  return constantTimeEqual(otp, storedOtp);
}

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/email-otp/routes.mjs
var types = [
  "email-verification",
  "sign-in",
  "forget-password"
];
var ERROR_CODES2 = defineErrorCodes({
  OTP_EXPIRED: "OTP expired",
  INVALID_OTP: "Invalid OTP",
  TOO_MANY_ATTEMPTS: "Too many attempts"
});
var sendVerificationOTPBodySchema = object({
  email: string({}).meta({ description: "Email address to send the OTP" }),
  type: _enum(types).meta({ description: "Type of the OTP" })
});
var sendVerificationOTP = (opts) => createAuthEndpoint("/email-otp/send-verification-otp", {
  method: "POST",
  body: sendVerificationOTPBodySchema,
  metadata: { openapi: {
    operationId: "sendEmailVerificationOTP",
    description: "Send a verification OTP to an email",
    responses: { 200: {
      description: "Success",
      content: { "application/json": { schema: {
        type: "object",
        properties: { success: { type: "boolean" } }
      } } }
    } }
  } }
}, async (ctx) => {
  if (!opts?.sendVerificationOTP) {
    ctx.context.logger.error("send email verification is not implemented");
    throw new APIError("BAD_REQUEST", { message: "send email verification is not implemented" });
  }
  const email2 = ctx.body.email.toLowerCase();
  if (!email().safeParse(email2).success) throw ctx.error("BAD_REQUEST", { message: BASE_ERROR_CODES.INVALID_EMAIL });
  let otp = opts.generateOTP({
    email: email2,
    type: ctx.body.type
  }, ctx) || defaultOTPGenerator(opts);
  let storedOTP = await storeOTP(ctx, opts, otp);
  await ctx.context.internalAdapter.createVerificationValue({
    value: `${storedOTP}:0`,
    identifier: `${ctx.body.type}-otp-${email2}`,
    expiresAt: getDate(opts.expiresIn, "sec")
  }).catch(async (error) => {
    await ctx.context.internalAdapter.deleteVerificationByIdentifier(`${ctx.body.type}-otp-${email2}`);
    await ctx.context.internalAdapter.createVerificationValue({
      value: `${storedOTP}:0`,
      identifier: `${ctx.body.type}-otp-${email2}`,
      expiresAt: getDate(opts.expiresIn, "sec")
    });
  });
  if (!await ctx.context.internalAdapter.findUserByEmail(email2)) if (ctx.body.type === "sign-in" && !opts.disableSignUp) {
  } else {
    await ctx.context.internalAdapter.deleteVerificationByIdentifier(`${ctx.body.type}-otp-${email2}`);
    return ctx.json({ success: true });
  }
  await ctx.context.runInBackgroundOrAwait(opts.sendVerificationOTP({
    email: email2,
    otp,
    type: ctx.body.type
  }, ctx));
  return ctx.json({ success: true });
});
var createVerificationOTPBodySchema = object({
  email: string({}).meta({ description: "Email address to send the OTP" }),
  type: _enum(types).meta({
    required: true,
    description: "Type of the OTP"
  })
});
var createVerificationOTP = (opts) => createAuthEndpoint({
  method: "POST",
  body: createVerificationOTPBodySchema,
  metadata: { openapi: {
    operationId: "createEmailVerificationOTP",
    description: "Create a verification OTP for an email",
    responses: { 200: {
      description: "Success",
      content: { "application/json": { schema: { type: "string" } } }
    } }
  } }
}, async (ctx) => {
  const email2 = ctx.body.email.toLowerCase();
  const otp = opts.generateOTP({
    email: email2,
    type: ctx.body.type
  }, ctx) || defaultOTPGenerator(opts);
  let storedOTP = await storeOTP(ctx, opts, otp);
  await ctx.context.internalAdapter.createVerificationValue({
    value: `${storedOTP}:0`,
    identifier: `${ctx.body.type}-otp-${email2}`,
    expiresAt: getDate(opts.expiresIn, "sec")
  });
  return otp;
});
var getVerificationOTPBodySchema = object({
  email: string({}).meta({ description: "Email address the OTP was sent to" }),
  type: _enum(types).meta({
    required: true,
    description: "Type of the OTP"
  })
});
var getVerificationOTP = (opts) => createAuthEndpoint({
  method: "GET",
  query: getVerificationOTPBodySchema,
  metadata: { openapi: {
    operationId: "getEmailVerificationOTP",
    description: "Get a verification OTP for an email",
    responses: { "200": {
      description: "OTP retrieved successfully or not found/expired",
      content: { "application/json": { schema: {
        type: "object",
        properties: { otp: {
          type: "string",
          nullable: true,
          description: "The stored OTP, or null if not found or expired"
        } },
        required: ["otp"]
      } } }
    } }
  } }
}, async (ctx) => {
  const email2 = ctx.query.email.toLowerCase();
  const verificationValue = await ctx.context.internalAdapter.findVerificationValue(`${ctx.query.type}-otp-${email2}`);
  if (!verificationValue || verificationValue.expiresAt < /* @__PURE__ */ new Date()) return ctx.json({ otp: null });
  if (opts.storeOTP === "hashed" || typeof opts.storeOTP === "object" && "hash" in opts.storeOTP) throw new APIError("BAD_REQUEST", { message: "OTP is hashed, cannot return the plain text OTP" });
  let [storedOtp, _attempts] = splitAtLastColon(verificationValue.value);
  let otp = storedOtp;
  if (opts.storeOTP === "encrypted") otp = await symmetricDecrypt({
    key: ctx.context.secret,
    data: storedOtp
  });
  if (typeof opts.storeOTP === "object" && "decrypt" in opts.storeOTP) otp = await opts.storeOTP.decrypt(storedOtp);
  return ctx.json({ otp });
});
var checkVerificationOTPBodySchema = object({
  email: string().meta({ description: "Email address the OTP was sent to" }),
  type: _enum(types).meta({
    required: true,
    description: "Type of the OTP"
  }),
  otp: string().meta({
    required: true,
    description: "OTP to verify"
  })
});
var checkVerificationOTP = (opts) => createAuthEndpoint("/email-otp/check-verification-otp", {
  method: "POST",
  body: checkVerificationOTPBodySchema,
  metadata: { openapi: {
    operationId: "verifyEmailWithOTP",
    description: "Verify an email with an OTP",
    responses: { 200: {
      description: "Success",
      content: { "application/json": { schema: {
        type: "object",
        properties: { success: { type: "boolean" } }
      } } }
    } }
  } }
}, async (ctx) => {
  const email2 = ctx.body.email.toLowerCase();
  if (!email().safeParse(email2).success) throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.INVALID_EMAIL });
  if (!await ctx.context.internalAdapter.findUserByEmail(email2)) throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.USER_NOT_FOUND });
  const verificationValue = await ctx.context.internalAdapter.findVerificationValue(`${ctx.body.type}-otp-${email2}`);
  if (!verificationValue) throw new APIError("BAD_REQUEST", { message: ERROR_CODES2.INVALID_OTP });
  if (verificationValue.expiresAt < /* @__PURE__ */ new Date()) {
    await ctx.context.internalAdapter.deleteVerificationValue(verificationValue.id);
    throw new APIError("BAD_REQUEST", { message: ERROR_CODES2.OTP_EXPIRED });
  }
  const [otpValue, attempts] = splitAtLastColon(verificationValue.value);
  const allowedAttempts = opts?.allowedAttempts || 3;
  if (attempts && parseInt(attempts) >= allowedAttempts) {
    await ctx.context.internalAdapter.deleteVerificationValue(verificationValue.id);
    throw new APIError("FORBIDDEN", { message: ERROR_CODES2.TOO_MANY_ATTEMPTS });
  }
  if (!await verifyStoredOTP(ctx, opts, otpValue, ctx.body.otp)) {
    await ctx.context.internalAdapter.updateVerificationValue(verificationValue.id, { value: `${otpValue}:${parseInt(attempts || "0") + 1}` });
    throw new APIError("BAD_REQUEST", { message: ERROR_CODES2.INVALID_OTP });
  }
  return ctx.json({ success: true });
});
var verifyEmailOTPBodySchema = object({
  email: string({}).meta({ description: "Email address to verify" }),
  otp: string().meta({
    required: true,
    description: "OTP to verify"
  })
});
var verifyEmailOTP = (opts) => createAuthEndpoint("/email-otp/verify-email", {
  method: "POST",
  body: verifyEmailOTPBodySchema,
  metadata: { openapi: {
    description: "Verify email with OTP",
    responses: { 200: {
      description: "Success",
      content: { "application/json": { schema: {
        type: "object",
        properties: {
          status: {
            type: "boolean",
            description: "Indicates if the verification was successful",
            enum: [true]
          },
          token: {
            type: "string",
            nullable: true,
            description: "Session token if autoSignInAfterVerification is enabled, otherwise null"
          },
          user: { $ref: "#/components/schemas/User" }
        },
        required: [
          "status",
          "token",
          "user"
        ]
      } } }
    } }
  } }
}, async (ctx) => {
  const email2 = ctx.body.email.toLowerCase();
  if (!email().safeParse(email2).success) throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.INVALID_EMAIL });
  const verificationValue = await ctx.context.internalAdapter.findVerificationValue(`email-verification-otp-${email2}`);
  if (!verificationValue) throw new APIError("BAD_REQUEST", { message: ERROR_CODES2.INVALID_OTP });
  if (verificationValue.expiresAt < /* @__PURE__ */ new Date()) throw new APIError("BAD_REQUEST", { message: ERROR_CODES2.OTP_EXPIRED });
  const [otpValue, attempts] = splitAtLastColon(verificationValue.value);
  const allowedAttempts = opts?.allowedAttempts || 3;
  if (attempts && parseInt(attempts) >= allowedAttempts) {
    await ctx.context.internalAdapter.deleteVerificationValue(verificationValue.id);
    throw new APIError("FORBIDDEN", { message: ERROR_CODES2.TOO_MANY_ATTEMPTS });
  }
  if (!await verifyStoredOTP(ctx, opts, otpValue, ctx.body.otp)) {
    await ctx.context.internalAdapter.updateVerificationValue(verificationValue.id, { value: `${otpValue}:${parseInt(attempts || "0") + 1}` });
    throw new APIError("BAD_REQUEST", { message: ERROR_CODES2.INVALID_OTP });
  }
  await ctx.context.internalAdapter.deleteVerificationValue(verificationValue.id);
  const user = await ctx.context.internalAdapter.findUserByEmail(email2);
  if (!user)
    throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.USER_NOT_FOUND });
  const updatedUser = await ctx.context.internalAdapter.updateUser(user.user.id, {
    email: email2,
    emailVerified: true
  });
  await ctx.context.options.emailVerification?.onEmailVerification?.(updatedUser, ctx.request);
  if (ctx.context.options.emailVerification?.autoSignInAfterVerification) {
    const session = await ctx.context.internalAdapter.createSession(updatedUser.id);
    await setSessionCookie(ctx, {
      session,
      user: updatedUser
    });
    return ctx.json({
      status: true,
      token: session.token,
      user: {
        id: updatedUser.id,
        email: updatedUser.email,
        emailVerified: updatedUser.emailVerified,
        name: updatedUser.name,
        image: updatedUser.image,
        createdAt: updatedUser.createdAt,
        updatedAt: updatedUser.updatedAt
      }
    });
  }
  const currentSession = await getSessionFromCtx(ctx);
  if (currentSession && updatedUser.emailVerified) {
    const dontRememberMeCookie = await ctx.getSignedCookie(ctx.context.authCookies.dontRememberToken.name, ctx.context.secret);
    await setCookieCache(ctx, {
      session: currentSession.session,
      user: {
        ...currentSession.user,
        emailVerified: true
      }
    }, !!dontRememberMeCookie);
  }
  return ctx.json({
    status: true,
    token: null,
    user: {
      id: updatedUser.id,
      email: updatedUser.email,
      emailVerified: updatedUser.emailVerified,
      name: updatedUser.name,
      image: updatedUser.image,
      createdAt: updatedUser.createdAt,
      updatedAt: updatedUser.updatedAt
    }
  });
});
var signInEmailOTPBodySchema = object({
  email: string({}).meta({ description: "Email address to sign in" }),
  otp: string().meta({
    required: true,
    description: "OTP sent to the email"
  })
});
var signInEmailOTP = (opts) => createAuthEndpoint("/sign-in/email-otp", {
  method: "POST",
  body: signInEmailOTPBodySchema,
  metadata: { openapi: {
    operationId: "signInWithEmailOTP",
    description: "Sign in with email and OTP",
    responses: { 200: {
      description: "Success",
      content: { "application/json": { schema: {
        type: "object",
        properties: {
          token: {
            type: "string",
            description: "Session token for the authenticated session"
          },
          user: { $ref: "#/components/schemas/User" }
        },
        required: ["token", "user"]
      } } }
    } }
  } }
}, async (ctx) => {
  const email2 = ctx.body.email.toLowerCase();
  const verificationValue = await ctx.context.internalAdapter.findVerificationValue(`sign-in-otp-${email2}`);
  if (!verificationValue) throw new APIError("BAD_REQUEST", { message: ERROR_CODES2.INVALID_OTP });
  if (verificationValue.expiresAt < /* @__PURE__ */ new Date()) throw new APIError("BAD_REQUEST", { message: ERROR_CODES2.OTP_EXPIRED });
  const [otpValue, attempts] = splitAtLastColon(verificationValue.value);
  const allowedAttempts = opts?.allowedAttempts || 3;
  if (attempts && parseInt(attempts) >= allowedAttempts) {
    await ctx.context.internalAdapter.deleteVerificationValue(verificationValue.id);
    throw new APIError("FORBIDDEN", { message: ERROR_CODES2.TOO_MANY_ATTEMPTS });
  }
  if (!await verifyStoredOTP(ctx, opts, otpValue, ctx.body.otp)) {
    await ctx.context.internalAdapter.updateVerificationValue(verificationValue.id, { value: `${otpValue}:${parseInt(attempts || "0") + 1}` });
    throw new APIError("BAD_REQUEST", { message: ERROR_CODES2.INVALID_OTP });
  }
  await ctx.context.internalAdapter.deleteVerificationValue(verificationValue.id);
  const user = await ctx.context.internalAdapter.findUserByEmail(email2);
  if (!user) {
    if (opts.disableSignUp) throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.USER_NOT_FOUND });
    const newUser = await ctx.context.internalAdapter.createUser({
      email: email2,
      emailVerified: true,
      name: ""
    });
    const session$1 = await ctx.context.internalAdapter.createSession(newUser.id);
    await setSessionCookie(ctx, {
      session: session$1,
      user: newUser
    });
    return ctx.json({
      token: session$1.token,
      user: {
        id: newUser.id,
        email: newUser.email,
        emailVerified: newUser.emailVerified,
        name: newUser.name,
        image: newUser.image,
        createdAt: newUser.createdAt,
        updatedAt: newUser.updatedAt
      }
    });
  }
  if (!user.user.emailVerified) await ctx.context.internalAdapter.updateUser(user.user.id, { emailVerified: true });
  const session = await ctx.context.internalAdapter.createSession(user.user.id);
  await setSessionCookie(ctx, {
    session,
    user: user.user
  });
  return ctx.json({
    token: session.token,
    user: {
      id: user.user.id,
      email: user.user.email,
      emailVerified: user.user.emailVerified,
      name: user.user.name,
      image: user.user.image,
      createdAt: user.user.createdAt,
      updatedAt: user.user.updatedAt
    }
  });
});
var forgetPasswordEmailOTPBodySchema = object({ email: string().meta({ description: "Email address to send the OTP" }) });
var forgetPasswordEmailOTP = (opts) => createAuthEndpoint("/forget-password/email-otp", {
  method: "POST",
  body: forgetPasswordEmailOTPBodySchema,
  metadata: { openapi: {
    operationId: "forgetPasswordWithEmailOTP",
    description: "Forget password with email and OTP",
    responses: { 200: {
      description: "Success",
      content: { "application/json": { schema: {
        type: "object",
        properties: { success: {
          type: "boolean",
          description: "Indicates if the OTP was sent successfully"
        } }
      } } }
    } }
  } }
}, async (ctx) => {
  const email2 = ctx.body.email;
  const otp = opts.generateOTP({
    email: email2,
    type: "forget-password"
  }, ctx) || defaultOTPGenerator(opts);
  let storedOTP = await storeOTP(ctx, opts, otp);
  await ctx.context.internalAdapter.createVerificationValue({
    value: `${storedOTP}:0`,
    identifier: `forget-password-otp-${email2}`,
    expiresAt: getDate(opts.expiresIn, "sec")
  });
  if (!await ctx.context.internalAdapter.findUserByEmail(email2)) {
    await ctx.context.internalAdapter.deleteVerificationByIdentifier(`forget-password-otp-${email2}`);
    return ctx.json({ success: true });
  }
  await ctx.context.runInBackgroundOrAwait(opts.sendVerificationOTP({
    email: email2,
    otp,
    type: "forget-password"
  }, ctx));
  return ctx.json({ success: true });
});
var resetPasswordEmailOTPBodySchema = object({
  email: string().meta({ description: "Email address to reset the password" }),
  otp: string().meta({ description: "OTP sent to the email" }),
  password: string().meta({ description: "New password" })
});
var resetPasswordEmailOTP = (opts) => createAuthEndpoint("/email-otp/reset-password", {
  method: "POST",
  body: resetPasswordEmailOTPBodySchema,
  metadata: { openapi: {
    operationId: "resetPasswordWithEmailOTP",
    description: "Reset password with email and OTP",
    responses: { 200: {
      description: "Success",
      contnt: { "application/json": { schema: {
        type: "object",
        properties: { success: { type: "boolean" } }
      } } }
    } }
  } }
}, async (ctx) => {
  const email2 = ctx.body.email;
  const verificationValue = await ctx.context.internalAdapter.findVerificationValue(`forget-password-otp-${email2}`);
  if (!verificationValue) throw new APIError("BAD_REQUEST", { message: ERROR_CODES2.INVALID_OTP });
  if (verificationValue.expiresAt < /* @__PURE__ */ new Date()) {
    await ctx.context.internalAdapter.deleteVerificationValue(verificationValue.id);
    throw new APIError("BAD_REQUEST", { message: ERROR_CODES2.OTP_EXPIRED });
  }
  const [otpValue, attempts] = splitAtLastColon(verificationValue.value);
  const allowedAttempts = opts?.allowedAttempts || 3;
  if (attempts && parseInt(attempts) >= allowedAttempts) {
    await ctx.context.internalAdapter.deleteVerificationValue(verificationValue.id);
    throw new APIError("FORBIDDEN", { message: ERROR_CODES2.TOO_MANY_ATTEMPTS });
  }
  if (!await verifyStoredOTP(ctx, opts, otpValue, ctx.body.otp)) {
    await ctx.context.internalAdapter.updateVerificationValue(verificationValue.id, { value: `${otpValue}:${parseInt(attempts || "0") + 1}` });
    throw new APIError("BAD_REQUEST", { message: ERROR_CODES2.INVALID_OTP });
  }
  await ctx.context.internalAdapter.deleteVerificationValue(verificationValue.id);
  const user = await ctx.context.internalAdapter.findUserByEmail(email2, { includeAccounts: true });
  if (!user) throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.USER_NOT_FOUND });
  const minPasswordLength = ctx.context.password.config.minPasswordLength;
  if (ctx.body.password.length < minPasswordLength) throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.PASSWORD_TOO_SHORT });
  const maxPasswordLength = ctx.context.password.config.maxPasswordLength;
  if (ctx.body.password.length > maxPasswordLength) throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.PASSWORD_TOO_LONG });
  const passwordHash = await ctx.context.password.hash(ctx.body.password);
  if (!user.accounts?.find((account) => account.providerId === "credential")) await ctx.context.internalAdapter.createAccount({
    userId: user.user.id,
    providerId: "credential",
    accountId: user.user.id,
    password: passwordHash
  });
  else await ctx.context.internalAdapter.updatePassword(user.user.id, passwordHash);
  if (ctx.context.options.emailAndPassword?.onPasswordReset) await ctx.context.options.emailAndPassword.onPasswordReset({ user: user.user }, ctx.request);
  if (!user.user.emailVerified) await ctx.context.internalAdapter.updateUser(user.user.id, { emailVerified: true });
  if (ctx.context.options.emailAndPassword?.revokeSessionsOnPasswordReset) await ctx.context.internalAdapter.deleteSessions(user.user.id);
  return ctx.json({ success: true });
});
var defaultOTPGenerator = (options) => generateRandomString(options.otpLength ?? 6, "0-9");

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/email-otp/index.mjs
var defaultOTPGenerator2 = (options) => generateRandomString(options.otpLength ?? 6, "0-9");
var emailOTP = (options) => {
  const opts = {
    expiresIn: 300,
    generateOTP: () => defaultOTPGenerator2(options),
    storeOTP: "plain",
    ...options
  };
  const sendVerificationOTPAction = sendVerificationOTP(opts);
  return {
    id: "email-otp",
    init(ctx) {
      if (!opts.overrideDefaultEmailVerification) return;
      return { options: { emailVerification: { async sendVerificationEmail(data, request) {
        await ctx.runInBackgroundOrAwait(sendVerificationOTPAction({
          context: ctx,
          request,
          body: {
            email: data.user.email,
            type: "email-verification"
          },
          ctx
        }));
      } } } };
    },
    endpoints: {
      sendVerificationOTP: sendVerificationOTPAction,
      createVerificationOTP: createVerificationOTP(opts),
      getVerificationOTP: getVerificationOTP(opts),
      checkVerificationOTP: checkVerificationOTP(opts),
      verifyEmailOTP: verifyEmailOTP(opts),
      signInEmailOTP: signInEmailOTP(opts),
      forgetPasswordEmailOTP: forgetPasswordEmailOTP(opts),
      resetPasswordEmailOTP: resetPasswordEmailOTP(opts)
    },
    hooks: { after: [{
      matcher(context) {
        return !!(context.path?.startsWith("/sign-up") && opts.sendVerificationOnSignUp && !opts.overrideDefaultEmailVerification);
      },
      handler: createAuthMiddleware(async (ctx) => {
        const email2 = (await getEndpointResponse(ctx))?.user.email;
        if (email2) {
          const otp = opts.generateOTP({
            email: email2,
            type: ctx.body.type
          }, ctx) || defaultOTPGenerator2(opts);
          let storedOTP = await storeOTP(ctx, opts, otp);
          await ctx.context.internalAdapter.createVerificationValue({
            value: `${storedOTP}:0`,
            identifier: `email-verification-otp-${email2}`,
            expiresAt: getDate(opts.expiresIn, "sec")
          });
          await ctx.context.runInBackgroundOrAwait(options.sendVerificationOTP({
            email: email2,
            otp,
            type: "email-verification"
          }, ctx));
        }
      })
    }] },
    $ERROR_CODES: ERROR_CODES2,
    rateLimit: [
      {
        pathMatcher(path) {
          return path === "/email-otp/send-verification-otp";
        },
        window: 60,
        max: 3
      },
      {
        pathMatcher(path) {
          return path === "/email-otp/check-verification-otp";
        },
        window: 60,
        max: 3
      },
      {
        pathMatcher(path) {
          return path === "/email-otp/verify-email";
        },
        window: 60,
        max: 3
      },
      {
        pathMatcher(path) {
          return path === "/sign-in/email-otp";
        },
        window: 60,
        max: 3
      }
    ],
    options
  };
};

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/generic-oauth/providers/auth0.mjs
function auth0(options) {
  const defaultScopes = [
    "openid",
    "profile",
    "email"
  ];
  const domain = options.domain.replace(/^https?:\/\//, "");
  const discoveryUrl = `https://${domain}/.well-known/openid-configuration`;
  const getUserInfo2 = async (tokens) => {
    const { data: profile, error } = await betterFetch(`https://${domain}/userinfo`, { headers: { Authorization: `Bearer ${tokens.accessToken}` } });
    if (error || !profile) return null;
    return {
      id: profile.sub,
      name: profile.name ?? profile.nickname ?? void 0,
      email: profile.email ?? void 0,
      image: profile.picture,
      emailVerified: profile.email_verified ?? false
    };
  };
  return {
    providerId: "auth0",
    discoveryUrl,
    clientId: options.clientId,
    clientSecret: options.clientSecret,
    scopes: options.scopes ?? defaultScopes,
    redirectURI: options.redirectURI,
    pkce: options.pkce,
    disableImplicitSignUp: options.disableImplicitSignUp,
    disableSignUp: options.disableSignUp,
    overrideUserInfo: options.overrideUserInfo,
    getUserInfo: getUserInfo2
  };
}

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/generic-oauth/providers/hubspot.mjs
function hubspot(options) {
  const defaultScopes = ["oauth"];
  const getUserInfo2 = async (tokens) => {
    const { data: profile, error } = await betterFetch(`https://api.hubapi.com/oauth/v1/access-tokens/${tokens.accessToken}`, { headers: { "Content-Type": "application/json" } });
    if (error || !profile) return null;
    const id = profile.user_id ?? profile.signed_access_token?.userId;
    if (!id) return null;
    return {
      id,
      name: profile.user,
      email: profile.user,
      image: void 0,
      emailVerified: false
    };
  };
  return {
    providerId: "hubspot",
    authorizationUrl: "https://app.hubspot.com/oauth/authorize",
    tokenUrl: "https://api.hubapi.com/oauth/v1/token",
    clientId: options.clientId,
    clientSecret: options.clientSecret,
    scopes: options.scopes ?? defaultScopes,
    redirectURI: options.redirectURI,
    authentication: "post",
    pkce: options.pkce,
    disableImplicitSignUp: options.disableImplicitSignUp,
    disableSignUp: options.disableSignUp,
    overrideUserInfo: options.overrideUserInfo,
    getUserInfo: getUserInfo2
  };
}

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/generic-oauth/providers/keycloak.mjs
function keycloak(options) {
  const defaultScopes = [
    "openid",
    "profile",
    "email"
  ];
  const issuer = options.issuer.replace(/\/$/, "");
  const discoveryUrl = `${issuer}/.well-known/openid-configuration`;
  const getUserInfo2 = async (tokens) => {
    const { data: profile, error } = await betterFetch(`${issuer}/protocol/openid-connect/userinfo`, { headers: { Authorization: `Bearer ${tokens.accessToken}` } });
    if (error || !profile) return null;
    return {
      id: profile.sub,
      name: profile.name ?? profile.preferred_username ?? void 0,
      email: profile.email ?? void 0,
      image: profile.picture,
      emailVerified: profile.email_verified ?? false
    };
  };
  return {
    providerId: "keycloak",
    discoveryUrl,
    clientId: options.clientId,
    clientSecret: options.clientSecret,
    scopes: options.scopes ?? defaultScopes,
    redirectURI: options.redirectURI,
    pkce: options.pkce,
    disableImplicitSignUp: options.disableImplicitSignUp,
    disableSignUp: options.disableSignUp,
    overrideUserInfo: options.overrideUserInfo,
    getUserInfo: getUserInfo2
  };
}

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/generic-oauth/providers/line.mjs
function line(options) {
  const defaultScopes = [
    "openid",
    "profile",
    "email"
  ];
  const authorizationUrl = "https://access.line.me/oauth2/v2.1/authorize";
  const tokenUrl = "https://api.line.me/oauth2/v2.1/token";
  const userInfoUrl = "https://api.line.me/oauth2/v2.1/userinfo";
  const getUserInfo2 = async (tokens) => {
    let profile = null;
    if (tokens.idToken) try {
      profile = decodeJwt(tokens.idToken);
    } catch {
    }
    if (!profile) {
      const { data, error } = await betterFetch(userInfoUrl, { headers: { Authorization: `Bearer ${tokens.accessToken}` } });
      if (error || !data) return null;
      profile = data;
    }
    if (!profile) return null;
    return {
      id: profile.sub,
      name: profile.name,
      email: profile.email,
      image: profile.picture,
      emailVerified: false
    };
  };
  return {
    providerId: options.providerId ?? "line",
    authorizationUrl,
    tokenUrl,
    userInfoUrl,
    clientId: options.clientId,
    clientSecret: options.clientSecret,
    scopes: options.scopes ?? defaultScopes,
    redirectURI: options.redirectURI,
    pkce: options.pkce,
    disableImplicitSignUp: options.disableImplicitSignUp,
    disableSignUp: options.disableSignUp,
    overrideUserInfo: options.overrideUserInfo,
    getUserInfo: getUserInfo2
  };
}

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/generic-oauth/providers/microsoft-entra-id.mjs
function microsoftEntraId(options) {
  const defaultScopes = [
    "openid",
    "profile",
    "email"
  ];
  const tenantId = options.tenantId;
  const authorizationUrl = `https://login.microsoftonline.com/${tenantId}/oauth2/v2.0/authorize`;
  const tokenUrl = `https://login.microsoftonline.com/${tenantId}/oauth2/v2.0/token`;
  const userInfoUrl = "https://graph.microsoft.com/oidc/userinfo";
  const getUserInfo2 = async (tokens) => {
    const { data: profile, error } = await betterFetch(userInfoUrl, { headers: { Authorization: `Bearer ${tokens.accessToken}` } });
    if (error || !profile) return null;
    return {
      id: profile.sub,
      name: profile.name ?? (`${profile.given_name ?? ""} ${profile.family_name ?? ""}`.trim() || void 0),
      email: profile.email ?? profile.preferred_username ?? void 0,
      image: profile.picture,
      emailVerified: profile.email_verified ?? false
    };
  };
  return {
    providerId: "microsoft-entra-id",
    authorizationUrl,
    tokenUrl,
    userInfoUrl,
    clientId: options.clientId,
    clientSecret: options.clientSecret,
    scopes: options.scopes ?? defaultScopes,
    redirectURI: options.redirectURI,
    pkce: options.pkce,
    disableImplicitSignUp: options.disableImplicitSignUp,
    disableSignUp: options.disableSignUp,
    overrideUserInfo: options.overrideUserInfo,
    getUserInfo: getUserInfo2
  };
}

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/generic-oauth/providers/okta.mjs
function okta(options) {
  const defaultScopes = [
    "openid",
    "profile",
    "email"
  ];
  const issuer = options.issuer.replace(/\/$/, "");
  const discoveryUrl = `${issuer}/.well-known/openid-configuration`;
  const getUserInfo2 = async (tokens) => {
    const { data: profile, error } = await betterFetch(`${issuer}/v1/userinfo`, { headers: { Authorization: `Bearer ${tokens.accessToken}` } });
    if (error || !profile) return null;
    return {
      id: profile.sub,
      name: profile.name ?? profile.preferred_username ?? void 0,
      email: profile.email ?? void 0,
      image: profile.picture,
      emailVerified: profile.email_verified ?? false
    };
  };
  return {
    providerId: "okta",
    discoveryUrl,
    clientId: options.clientId,
    clientSecret: options.clientSecret,
    scopes: options.scopes ?? defaultScopes,
    redirectURI: options.redirectURI,
    pkce: options.pkce,
    disableImplicitSignUp: options.disableImplicitSignUp,
    disableSignUp: options.disableSignUp,
    overrideUserInfo: options.overrideUserInfo,
    getUserInfo: getUserInfo2
  };
}

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/generic-oauth/providers/patreon.mjs
function patreon(options) {
  const defaultScopes = ["identity[email]"];
  const getUserInfo2 = async (tokens) => {
    const { data: profile, error } = await betterFetch("https://www.patreon.com/api/oauth2/v2/identity?fields[user]=email,full_name,image_url,is_email_verified", {
      method: "GET",
      headers: { Authorization: `Bearer ${tokens.accessToken}` }
    });
    if (error || !profile) return null;
    return {
      id: profile.data.id,
      name: profile.data.attributes.full_name,
      email: profile.data.attributes.email,
      image: profile.data.attributes.image_url,
      emailVerified: profile.data.attributes.is_email_verified
    };
  };
  return {
    providerId: "patreon",
    authorizationUrl: "https://www.patreon.com/oauth2/authorize",
    tokenUrl: "https://www.patreon.com/api/oauth2/token",
    clientId: options.clientId,
    clientSecret: options.clientSecret,
    scopes: options.scopes ?? defaultScopes,
    redirectURI: options.redirectURI,
    pkce: options.pkce,
    disableImplicitSignUp: options.disableImplicitSignUp,
    disableSignUp: options.disableSignUp,
    overrideUserInfo: options.overrideUserInfo,
    getUserInfo: getUserInfo2
  };
}

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/generic-oauth/providers/slack.mjs
function slack(options) {
  const defaultScopes = [
    "openid",
    "profile",
    "email"
  ];
  const getUserInfo2 = async (tokens) => {
    const { data: profile, error } = await betterFetch("https://slack.com/api/openid.connect.userInfo", { headers: { Authorization: `Bearer ${tokens.accessToken}` } });
    if (error || !profile) return null;
    return {
      id: profile["https://slack.com/user_id"] ?? profile.sub,
      name: profile.name,
      email: profile.email,
      image: profile.picture ?? profile["https://slack.com/user_image_512"],
      emailVerified: profile.email_verified ?? false
    };
  };
  return {
    providerId: "slack",
    authorizationUrl: "https://slack.com/openid/connect/authorize",
    tokenUrl: "https://slack.com/api/openid.connect.token",
    userInfoUrl: "https://slack.com/api/openid.connect.userInfo",
    clientId: options.clientId,
    clientSecret: options.clientSecret,
    scopes: options.scopes ?? defaultScopes,
    redirectURI: options.redirectURI,
    pkce: options.pkce,
    disableImplicitSignUp: options.disableImplicitSignUp,
    disableSignUp: options.disableSignUp,
    overrideUserInfo: options.overrideUserInfo,
    getUserInfo: getUserInfo2
  };
}

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/generic-oauth/error-codes.mjs
var GENERIC_OAUTH_ERROR_CODES = defineErrorCodes({
  INVALID_OAUTH_CONFIGURATION: "Invalid OAuth configuration",
  TOKEN_URL_NOT_FOUND: "Invalid OAuth configuration. Token URL not found.",
  PROVIDER_CONFIG_NOT_FOUND: "No config found for provider",
  PROVIDER_ID_REQUIRED: "Provider ID is required",
  INVALID_OAUTH_CONFIG: "Invalid OAuth configuration.",
  SESSION_REQUIRED: "Session is required"
});

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/generic-oauth/routes.mjs
var signInWithOAuth2BodySchema = object({
  providerId: string().meta({ description: "The provider ID for the OAuth provider" }),
  callbackURL: string().meta({ description: "The URL to redirect to after sign in" }).optional(),
  errorCallbackURL: string().meta({ description: "The URL to redirect to if an error occurs" }).optional(),
  newUserCallbackURL: string().meta({ description: 'The URL to redirect to after login if the user is new. Eg: "/welcome"' }).optional(),
  disableRedirect: boolean().meta({ description: "Disable redirect" }).optional(),
  scopes: array(string()).meta({ description: "Scopes to be passed to the provider authorization request." }).optional(),
  requestSignUp: boolean().meta({ description: "Explicitly request sign-up. Useful when disableImplicitSignUp is true for this provider. Eg: false" }).optional(),
  additionalData: record(string(), any()).optional()
});
var signInWithOAuth2 = (options) => createAuthEndpoint("/sign-in/oauth2", {
  method: "POST",
  body: signInWithOAuth2BodySchema,
  metadata: { openapi: {
    description: "Sign in with OAuth2",
    responses: { 200: {
      description: "Sign in with OAuth2",
      content: { "application/json": { schema: {
        type: "object",
        properties: {
          url: { type: "string" },
          redirect: { type: "boolean" }
        }
      } } }
    } }
  } }
}, async (ctx) => {
  const { providerId } = ctx.body;
  const config = options.config.find((c) => c.providerId === providerId);
  if (!config) throw new APIError("BAD_REQUEST", { message: `${GENERIC_OAUTH_ERROR_CODES.PROVIDER_CONFIG_NOT_FOUND} ${providerId}` });
  const { discoveryUrl, authorizationUrl, tokenUrl, clientId, clientSecret, scopes, redirectURI, responseType, pkce, prompt, accessType, authorizationUrlParams, responseMode } = config;
  let finalAuthUrl = authorizationUrl;
  let finalTokenUrl = tokenUrl;
  if (discoveryUrl) {
    const discovery = await betterFetch(discoveryUrl, {
      method: "GET",
      headers: config.discoveryHeaders,
      onError(context) {
        ctx.context.logger.error(context.error.message, context.error, { discoveryUrl });
      }
    });
    if (discovery.data) {
      finalAuthUrl = discovery.data.authorization_endpoint;
      finalTokenUrl = discovery.data.token_endpoint;
    }
  }
  if (!finalAuthUrl || !finalTokenUrl) throw new APIError("BAD_REQUEST", { message: GENERIC_OAUTH_ERROR_CODES.INVALID_OAUTH_CONFIGURATION });
  if (authorizationUrlParams) {
    const withAdditionalParams = new URL(finalAuthUrl);
    for (const [paramName, paramValue] of Object.entries(authorizationUrlParams)) withAdditionalParams.searchParams.set(paramName, paramValue);
    finalAuthUrl = withAdditionalParams.toString();
  }
  const additionalParams = typeof authorizationUrlParams === "function" ? authorizationUrlParams(ctx) : authorizationUrlParams;
  const { state, codeVerifier } = await generateState(ctx, void 0, ctx.body.additionalData);
  const authUrl = await createAuthorizationURL({
    id: providerId,
    options: {
      clientId,
      clientSecret,
      redirectURI
    },
    authorizationEndpoint: finalAuthUrl,
    state,
    codeVerifier: pkce ? codeVerifier : void 0,
    scopes: ctx.body.scopes ? [...ctx.body.scopes, ...scopes || []] : scopes || [],
    redirectURI: `${ctx.context.baseURL}/oauth2/callback/${providerId}`,
    prompt,
    accessType,
    responseType,
    responseMode,
    additionalParams
  });
  return ctx.json({
    url: authUrl.toString(),
    redirect: !ctx.body.disableRedirect
  });
});
var OAuth2CallbackQuerySchema = object({
  code: string().meta({ description: "The OAuth2 code" }).optional(),
  error: string().meta({ description: "The error message, if any" }).optional(),
  error_description: string().meta({ description: "The error description, if any" }).optional(),
  state: string().meta({ description: "The state parameter from the OAuth2 request" }).optional()
});
var oAuth2Callback = (options) => createAuthEndpoint("/oauth2/callback/:providerId", {
  method: "GET",
  query: OAuth2CallbackQuerySchema,
  metadata: {
    ...HIDE_METADATA,
    allowedMediaTypes: ["application/x-www-form-urlencoded", "application/json"],
    openapi: {
      description: "OAuth2 callback",
      responses: { 200: {
        description: "OAuth2 callback",
        content: { "application/json": { schema: {
          type: "object",
          properties: { url: { type: "string" } }
        } } }
      } }
    }
  }
}, async (ctx) => {
  const defaultErrorURL = ctx.context.options.onAPIError?.errorURL || `${ctx.context.baseURL}/error`;
  if (ctx.query.error || !ctx.query.code) throw ctx.redirect(`${defaultErrorURL}?error=${ctx.query.error || "oAuth_code_missing"}&error_description=${ctx.query.error_description}`);
  const providerId = ctx.params?.providerId;
  if (!providerId) throw new APIError("BAD_REQUEST", { message: GENERIC_OAUTH_ERROR_CODES.PROVIDER_ID_REQUIRED });
  const providerConfig = options.config.find((p) => p.providerId === providerId);
  if (!providerConfig) throw new APIError("BAD_REQUEST", { message: `${GENERIC_OAUTH_ERROR_CODES.PROVIDER_CONFIG_NOT_FOUND} ${providerId}` });
  let tokens = void 0;
  const { callbackURL, codeVerifier, errorURL, requestSignUp, newUserURL, link } = await parseState(ctx);
  const code = ctx.query.code;
  function redirectOnError(error) {
    const defaultErrorURL$1 = ctx.context.options.onAPIError?.errorURL || `${ctx.context.baseURL}/error`;
    let url = errorURL || defaultErrorURL$1;
    if (url.includes("?")) url = `${url}&error=${error}`;
    else url = `${url}?error=${error}`;
    throw ctx.redirect(url);
  }
  let finalTokenUrl = providerConfig.tokenUrl;
  let finalUserInfoUrl = providerConfig.userInfoUrl;
  if (providerConfig.discoveryUrl) {
    const discovery = await betterFetch(providerConfig.discoveryUrl, {
      method: "GET",
      headers: providerConfig.discoveryHeaders
    });
    if (discovery.data) {
      finalTokenUrl = discovery.data.token_endpoint;
      finalUserInfoUrl = discovery.data.userinfo_endpoint;
    }
  }
  try {
    if (providerConfig.getToken) tokens = await providerConfig.getToken({
      code,
      redirectURI: `${ctx.context.baseURL}/oauth2/callback/${providerConfig.providerId}`,
      codeVerifier: providerConfig.pkce ? codeVerifier : void 0
    });
    else {
      if (!finalTokenUrl) throw new APIError("BAD_REQUEST", { message: GENERIC_OAUTH_ERROR_CODES.INVALID_OAUTH_CONFIG });
      const additionalParams = typeof providerConfig.tokenUrlParams === "function" ? providerConfig.tokenUrlParams(ctx) : providerConfig.tokenUrlParams;
      tokens = await validateAuthorizationCode({
        headers: providerConfig.authorizationHeaders,
        code,
        codeVerifier: providerConfig.pkce ? codeVerifier : void 0,
        redirectURI: `${ctx.context.baseURL}/oauth2/callback/${providerConfig.providerId}`,
        options: {
          clientId: providerConfig.clientId,
          clientSecret: providerConfig.clientSecret,
          redirectURI: providerConfig.redirectURI
        },
        tokenEndpoint: finalTokenUrl,
        authentication: providerConfig.authentication,
        additionalParams
      });
    }
  } catch (e) {
    ctx.context.logger.error(e && typeof e === "object" && "name" in e ? e.name : "", e);
    throw redirectOnError("oauth_code_verification_failed");
  }
  if (!tokens) throw new APIError("BAD_REQUEST", { message: GENERIC_OAUTH_ERROR_CODES.INVALID_OAUTH_CONFIG });
  const userInfo = await (async function handleUserInfo() {
    const userInfo$1 = providerConfig.getUserInfo ? await providerConfig.getUserInfo(tokens) : await getUserInfo(tokens, finalUserInfoUrl);
    if (!userInfo$1) throw redirectOnError("user_info_is_missing");
    const mapUser = providerConfig.mapProfileToUser ? await providerConfig.mapProfileToUser(userInfo$1) : userInfo$1;
    const email2 = mapUser.email ? mapUser.email.toLowerCase() : userInfo$1.email?.toLowerCase();
    if (!email2) {
      ctx.context.logger.error("Unable to get user info", userInfo$1);
      throw redirectOnError("email_is_missing");
    }
    const id = mapUser.id ? String(mapUser.id) : String(userInfo$1.id);
    const name = mapUser.name ? mapUser.name : userInfo$1.name;
    if (!name) {
      ctx.context.logger.error("Unable to get user info", userInfo$1);
      throw redirectOnError("name_is_missing");
    }
    return {
      ...userInfo$1,
      ...mapUser,
      email: email2,
      id,
      name
    };
  })();
  if (link) {
    if (ctx.context.options.account?.accountLinking?.allowDifferentEmails !== true && link.email !== userInfo.email) return redirectOnError("email_doesn't_match");
    const existingAccount = await ctx.context.internalAdapter.findAccountByProviderId(String(userInfo.id), providerConfig.providerId);
    if (existingAccount) {
      if (existingAccount.userId !== link.userId) return redirectOnError("account_already_linked_to_different_user");
      const updateData = Object.fromEntries(Object.entries({
        accessToken: await setTokenUtil(tokens.accessToken, ctx.context),
        idToken: tokens.idToken,
        refreshToken: await setTokenUtil(tokens.refreshToken, ctx.context),
        accessTokenExpiresAt: tokens.accessTokenExpiresAt,
        refreshTokenExpiresAt: tokens.refreshTokenExpiresAt,
        scope: tokens.scopes?.join(",")
      }).filter(([_, value]) => value !== void 0));
      await ctx.context.internalAdapter.updateAccount(existingAccount.id, updateData);
    } else if (!await ctx.context.internalAdapter.createAccount({
      userId: link.userId,
      providerId: providerConfig.providerId,
      accountId: userInfo.id,
      accessToken: await setTokenUtil(tokens.accessToken, ctx.context),
      accessTokenExpiresAt: tokens.accessTokenExpiresAt,
      refreshTokenExpiresAt: tokens.refreshTokenExpiresAt,
      scope: tokens.scopes?.join(","),
      refreshToken: await setTokenUtil(tokens.refreshToken, ctx.context),
      idToken: tokens.idToken
    })) return redirectOnError("unable_to_link_account");
    let toRedirectTo$1;
    try {
      toRedirectTo$1 = callbackURL.toString();
    } catch {
      toRedirectTo$1 = callbackURL;
    }
    throw ctx.redirect(toRedirectTo$1);
  }
  const result = await handleOAuthUserInfo(ctx, {
    userInfo,
    account: {
      providerId: providerConfig.providerId,
      accountId: userInfo.id,
      ...tokens,
      scope: tokens.scopes?.join(",")
    },
    callbackURL,
    disableSignUp: providerConfig.disableImplicitSignUp && !requestSignUp || providerConfig.disableSignUp,
    overrideUserInfo: providerConfig.overrideUserInfo
  });
  if (result.error) return redirectOnError(result.error.split(" ").join("_"));
  const { session, user } = result.data;
  await setSessionCookie(ctx, {
    session,
    user
  });
  let toRedirectTo;
  try {
    toRedirectTo = (result.isRegister ? newUserURL || callbackURL : callbackURL).toString();
  } catch {
    toRedirectTo = result.isRegister ? newUserURL || callbackURL : callbackURL;
  }
  throw ctx.redirect(toRedirectTo);
});
var OAuth2LinkAccountBodySchema = object({
  providerId: string(),
  callbackURL: string(),
  scopes: array(string()).meta({ description: "Additional scopes to request when linking the account" }).optional(),
  errorCallbackURL: string().meta({ description: "The URL to redirect to if there is an error during the link process" }).optional()
});
var oAuth2LinkAccount = (options) => createAuthEndpoint("/oauth2/link", {
  method: "POST",
  body: OAuth2LinkAccountBodySchema,
  use: [sessionMiddleware],
  metadata: { openapi: {
    description: "Link an OAuth2 account to the current user session",
    responses: { "200": {
      description: "Authorization URL generated successfully for linking an OAuth2 account",
      content: { "application/json": { schema: {
        type: "object",
        properties: {
          url: {
            type: "string",
            format: "uri",
            description: "The authorization URL to redirect the user to for linking the OAuth2 account"
          },
          redirect: {
            type: "boolean",
            description: "Indicates that the client should redirect to the provided URL",
            enum: [true]
          }
        },
        required: ["url", "redirect"]
      } } }
    } }
  } }
}, async (c) => {
  const session = c.context.session;
  if (!session) throw new APIError("UNAUTHORIZED", { message: GENERIC_OAUTH_ERROR_CODES.SESSION_REQUIRED });
  const provider = options.config.find((p) => p.providerId === c.body.providerId);
  if (!provider) throw new APIError("NOT_FOUND", { message: BASE_ERROR_CODES.PROVIDER_NOT_FOUND });
  const { providerId, clientId, clientSecret, redirectURI, authorizationUrl, discoveryUrl, pkce, scopes, prompt, accessType, authorizationUrlParams } = provider;
  let finalAuthUrl = authorizationUrl;
  if (!finalAuthUrl) {
    if (!discoveryUrl) throw new APIError("BAD_REQUEST", { message: GENERIC_OAUTH_ERROR_CODES.INVALID_OAUTH_CONFIGURATION });
    const discovery = await betterFetch(discoveryUrl, {
      method: "GET",
      headers: provider.discoveryHeaders,
      onError(context) {
        c.context.logger.error(context.error.message, context.error, { discoveryUrl });
      }
    });
    if (discovery.data) finalAuthUrl = discovery.data.authorization_endpoint;
  }
  if (!finalAuthUrl) throw new APIError("BAD_REQUEST", { message: GENERIC_OAUTH_ERROR_CODES.INVALID_OAUTH_CONFIGURATION });
  const state = await generateState(c, {
    userId: session.user.id,
    email: session.user.email
  }, void 0);
  const additionalParams = typeof authorizationUrlParams === "function" ? authorizationUrlParams(c) : authorizationUrlParams;
  const url = await createAuthorizationURL({
    id: providerId,
    options: {
      clientId,
      clientSecret,
      redirectURI: redirectURI || `${c.context.baseURL}/oauth2/callback/${providerId}`
    },
    authorizationEndpoint: finalAuthUrl,
    state: state.state,
    codeVerifier: pkce ? state.codeVerifier : void 0,
    scopes: c.body.scopes || scopes || [],
    redirectURI: redirectURI || `${c.context.baseURL}/oauth2/callback/${providerId}`,
    prompt,
    accessType,
    additionalParams
  });
  return c.json({
    url: url.toString(),
    redirect: true
  });
});
async function getUserInfo(tokens, finalUserInfoUrl) {
  if (tokens.idToken) {
    const decoded = decodeJwt(tokens.idToken);
    if (decoded) {
      if (decoded.sub && decoded.email) return {
        id: decoded.sub,
        emailVerified: decoded.email_verified,
        image: decoded.picture,
        ...decoded
      };
    }
  }
  if (!finalUserInfoUrl) return null;
  const userInfo = await betterFetch(finalUserInfoUrl, {
    method: "GET",
    headers: { Authorization: `Bearer ${tokens.accessToken}` }
  });
  return {
    id: userInfo.data?.sub ?? "",
    emailVerified: userInfo.data?.email_verified ?? false,
    email: userInfo.data?.email,
    image: userInfo.data?.picture,
    name: userInfo.data?.name,
    ...userInfo.data
  };
}

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/generic-oauth/index.mjs
var genericOAuth = (options) => {
  return {
    id: "generic-oauth",
    init: (ctx) => {
      return { context: { socialProviders: options.config.map((c) => {
        let finalUserInfoUrl = c.userInfoUrl;
        return {
          id: c.providerId,
          name: c.providerId,
          async createAuthorizationURL(data) {
            let finalAuthUrl = c.authorizationUrl;
            if (!finalAuthUrl && c.discoveryUrl) {
              const discovery = await betterFetch(c.discoveryUrl, {
                method: "GET",
                headers: c.discoveryHeaders
              });
              if (discovery.data) {
                finalAuthUrl = discovery.data.authorization_endpoint;
                finalUserInfoUrl = finalUserInfoUrl ?? discovery.data.userinfo_endpoint;
              }
            }
            if (!finalAuthUrl) throw new APIError("BAD_REQUEST", { message: GENERIC_OAUTH_ERROR_CODES.INVALID_OAUTH_CONFIGURATION });
            return createAuthorizationURL({
              id: c.providerId,
              options: {
                clientId: c.clientId,
                clientSecret: c.clientSecret,
                redirectURI: c.redirectURI
              },
              authorizationEndpoint: finalAuthUrl,
              state: data.state,
              codeVerifier: c.pkce ? data.codeVerifier : void 0,
              scopes: c.scopes || [],
              redirectURI: `${ctx.baseURL}/oauth2/callback/${c.providerId}`
            });
          },
          async validateAuthorizationCode(data) {
            if (c.getToken) return c.getToken(data);
            let finalTokenUrl = c.tokenUrl;
            if (c.discoveryUrl) {
              const discovery = await betterFetch(c.discoveryUrl, {
                method: "GET",
                headers: c.discoveryHeaders
              });
              if (discovery.data) {
                finalTokenUrl = discovery.data.token_endpoint;
                finalUserInfoUrl = discovery.data.userinfo_endpoint;
              }
            }
            if (!finalTokenUrl) throw new APIError("BAD_REQUEST", { message: GENERIC_OAUTH_ERROR_CODES.TOKEN_URL_NOT_FOUND });
            return validateAuthorizationCode({
              headers: c.authorizationHeaders,
              code: data.code,
              codeVerifier: data.codeVerifier,
              redirectURI: data.redirectURI,
              options: {
                clientId: c.clientId,
                clientSecret: c.clientSecret,
                redirectURI: c.redirectURI
              },
              tokenEndpoint: finalTokenUrl,
              authentication: c.authentication
            });
          },
          async refreshAccessToken(refreshToken) {
            let finalTokenUrl = c.tokenUrl;
            if (c.discoveryUrl) {
              const discovery = await betterFetch(c.discoveryUrl, {
                method: "GET",
                headers: c.discoveryHeaders
              });
              if (discovery.data) finalTokenUrl = discovery.data.token_endpoint;
            }
            if (!finalTokenUrl) throw new APIError("BAD_REQUEST", { message: GENERIC_OAUTH_ERROR_CODES.TOKEN_URL_NOT_FOUND });
            return refreshAccessToken({
              refreshToken,
              options: {
                clientId: c.clientId,
                clientSecret: c.clientSecret
              },
              authentication: c.authentication,
              tokenEndpoint: finalTokenUrl
            });
          },
          async getUserInfo(tokens) {
            const userInfo = c.getUserInfo ? await c.getUserInfo(tokens) : await getUserInfo(tokens, finalUserInfoUrl);
            if (!userInfo) return null;
            const userMap = await c.mapProfileToUser?.(userInfo);
            return {
              user: {
                id: userInfo?.id,
                email: userInfo?.email,
                emailVerified: userInfo?.emailVerified,
                image: userInfo?.image,
                name: userInfo?.name,
                ...userMap
              },
              data: userInfo
            };
          },
          options: { overrideUserInfoOnSignIn: c.overrideUserInfo }
        };
      }).concat(ctx.socialProviders) } };
    },
    endpoints: {
      signInWithOAuth2: signInWithOAuth2(options),
      oAuth2Callback: oAuth2Callback(options),
      oAuth2LinkAccount: oAuth2LinkAccount(options)
    },
    options,
    $ERROR_CODES: GENERIC_OAUTH_ERROR_CODES
  };
};

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/haveibeenpwned/index.mjs
var ERROR_CODES3 = defineErrorCodes({ PASSWORD_COMPROMISED: "The password you entered has been compromised. Please choose a different password." });
async function checkPasswordCompromise(password, customMessage) {
  if (!password) return;
  const sha1Hash = (await createHash("SHA-1", "hex").digest(password)).toUpperCase();
  const prefix = sha1Hash.substring(0, 5);
  const suffix = sha1Hash.substring(5);
  try {
    const { data, error } = await betterFetch(`https://api.pwnedpasswords.com/range/${prefix}`, { headers: {
      "Add-Padding": "true",
      "User-Agent": "BetterAuth Password Checker"
    } });
    if (error) throw new APIError("INTERNAL_SERVER_ERROR", { message: `Failed to check password. Status: ${error.status}` });
    if (data.split("\n").some((line2) => line2.split(":")[0].toUpperCase() === suffix.toUpperCase())) throw new APIError("BAD_REQUEST", {
      message: customMessage || ERROR_CODES3.PASSWORD_COMPROMISED,
      code: "PASSWORD_COMPROMISED"
    });
  } catch (error) {
    if (error instanceof APIError) throw error;
    throw new APIError("INTERNAL_SERVER_ERROR", { message: "Failed to check password. Please try again later." });
  }
}
var haveIBeenPwned = (options) => {
  const paths = options?.paths || [
    "/sign-up/email",
    "/change-password",
    "/reset-password"
  ];
  return {
    id: "haveIBeenPwned",
    init(ctx) {
      return { context: { password: {
        ...ctx.password,
        async hash(password) {
          const c = await getCurrentAuthContext();
          if (!c.path || !paths.includes(c.path)) return ctx.password.hash(password);
          await checkPasswordCompromise(password, options?.customPasswordCompromisedMessage);
          return ctx.password.hash(password);
        }
      } } };
    },
    options,
    $ERROR_CODES: ERROR_CODES3
  };
};

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/jwt/adapter.mjs
var getJwksAdapter = (adapter, options) => {
  return {
    getAllKeys: async (ctx) => {
      if (options?.adapter?.getJwks) return await options.adapter.getJwks(ctx);
      return await adapter.findMany({ model: "jwks" });
    },
    getLatestKey: async (ctx) => {
      if (options?.adapter?.getJwks) return (await options.adapter.getJwks(ctx))?.sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime())[0];
      return (await adapter.findMany({ model: "jwks" }))?.sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime())[0];
    },
    createJwk: async (ctx, webKey) => {
      if (options?.adapter?.createJwk) return await options.adapter.createJwk(webKey, ctx);
      return await adapter.create({
        model: "jwks",
        data: {
          ...webKey,
          createdAt: /* @__PURE__ */ new Date()
        }
      });
    }
  };
};

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/jwt/utils.mjs
function toExpJWT(expirationTime, iat) {
  if (typeof expirationTime === "number") return expirationTime;
  else if (expirationTime instanceof Date) return Math.floor(expirationTime.getTime() / 1e3);
  else return iat + sec(expirationTime);
}
async function generateExportedKeyPair(options) {
  const { alg, ...cfg } = options?.jwks?.keyPairConfig ?? {
    alg: "EdDSA",
    crv: "Ed25519"
  };
  const { publicKey, privateKey } = await generateKeyPair(alg, {
    ...cfg,
    extractable: true
  });
  return {
    publicWebKey: await exportJWK(publicKey),
    privateWebKey: await exportJWK(privateKey),
    alg,
    cfg
  };
}
async function createJwk(ctx, options) {
  const { publicWebKey, privateWebKey, alg, cfg } = await generateExportedKeyPair(options);
  const stringifiedPrivateWebKey = JSON.stringify(privateWebKey);
  const privateKeyEncryptionEnabled = !options?.jwks?.disablePrivateKeyEncryption;
  let jwk = {
    alg,
    ...cfg && "crv" in cfg ? { crv: cfg.crv } : {},
    publicKey: JSON.stringify(publicWebKey),
    privateKey: privateKeyEncryptionEnabled ? JSON.stringify(await symmetricEncrypt({
      key: ctx.context.secret,
      data: stringifiedPrivateWebKey
    })) : stringifiedPrivateWebKey,
    createdAt: /* @__PURE__ */ new Date(),
    ...options?.jwks?.rotationInterval ? { expiresAt: new Date(Date.now() + options.jwks.rotationInterval * 1e3) } : {}
  };
  return await getJwksAdapter(ctx.context.adapter, options).createJwk(ctx, jwk);
}

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/jwt/sign.mjs
async function signJWT(ctx, config) {
  const { options } = config;
  const payload = config.payload;
  const nowSeconds = Math.floor(Date.now() / 1e3);
  const iat = payload.iat;
  let exp = payload.exp;
  const defaultExp = toExpJWT(options?.jwt?.expirationTime ?? "15m", iat ?? nowSeconds);
  exp = exp ?? defaultExp;
  const nbf = payload.nbf;
  const iss = payload.iss;
  const defaultIss = options?.jwt?.issuer ?? ctx.context.options.baseURL;
  const aud = payload.aud;
  const defaultAud = options?.jwt?.audience ?? ctx.context.options.baseURL;
  if (options?.jwt?.sign) {
    const jwtPayload = {
      ...payload,
      iat,
      exp,
      nbf,
      iss: iss ?? defaultIss,
      aud: aud ?? defaultAud
    };
    return options.jwt.sign(jwtPayload);
  }
  let key = await getJwksAdapter(ctx.context.adapter, options).getLatestKey(ctx);
  if (!key || key.expiresAt && key.expiresAt < /* @__PURE__ */ new Date()) key = await createJwk(ctx, options);
  let privateWebKey = !options?.jwks?.disablePrivateKeyEncryption ? await symmetricDecrypt({
    key: ctx.context.secret,
    data: JSON.parse(key.privateKey)
  }).catch(() => {
    throw new BetterAuthError("Failed to decrypt private key. Make sure the secret currently in use is the same as the one used to encrypt the private key. If you are using a different secret, either clean up your JWKS or disable private key encryption.");
  }) : key.privateKey;
  const alg = key.alg ?? options?.jwks?.keyPairConfig?.alg ?? "EdDSA";
  const privateKey = await importJWK(JSON.parse(privateWebKey), alg);
  const jwt2 = new SignJWT(payload).setProtectedHeader({
    alg,
    kid: key.id
  }).setExpirationTime(exp).setIssuer(iss ?? defaultIss).setAudience(aud ?? defaultAud);
  if (iat) jwt2.setIssuedAt(iat);
  if (payload.sub) jwt2.setSubject(payload.sub);
  if (payload.nbf) jwt2.setNotBefore(payload.nbf);
  if (payload.jti) jwt2.setJti(payload.jti);
  return await jwt2.sign(privateKey);
}
async function getJwtToken(ctx, options) {
  const payload = !options?.jwt?.definePayload ? ctx.context.session.user : await options.jwt.definePayload(ctx.context.session);
  return await signJWT(ctx, {
    options,
    payload: {
      iat: Math.floor(Date.now() / 1e3),
      ...payload,
      sub: await options?.jwt?.getSubject?.(ctx.context.session) ?? ctx.context.session.user.id
    }
  });
}

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/jwt/verify.mjs
async function verifyJWT(token, options) {
  const ctx = await getCurrentAuthContext();
  try {
    const parts = token.split(".");
    if (parts.length !== 3) return null;
    const headerStr = new TextDecoder().decode(base64.decode(parts[0]));
    const kid = JSON.parse(headerStr).kid;
    if (!kid) {
      ctx.context.logger.debug("JWT missing kid in header");
      return null;
    }
    const keys = await getJwksAdapter(ctx.context.adapter, options).getAllKeys(ctx);
    if (!keys || keys.length === 0) {
      ctx.context.logger.debug("No JWKS keys available");
      return null;
    }
    const key = keys.find((k) => k.id === kid);
    if (!key) {
      ctx.context.logger.debug(`No JWKS key found for kid: ${kid}`);
      return null;
    }
    const { payload } = await jwtVerify(token, await importJWK(JSON.parse(key.publicKey), key.alg ?? options?.jwks?.keyPairConfig?.alg ?? "EdDSA"), {
      issuer: options?.jwt?.issuer ?? ctx.context.options.baseURL,
      audience: options?.jwt?.audience ?? ctx.context.options.baseURL
    });
    if (!payload.sub || !payload.aud) return null;
    return payload;
  } catch (error) {
    ctx.context.logger.debug("JWT verification failed", error);
    return null;
  }
}

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/jwt/schema.mjs
var schema4 = { jwks: { fields: {
  publicKey: {
    type: "string",
    required: true
  },
  privateKey: {
    type: "string",
    required: true
  },
  createdAt: {
    type: "date",
    required: true
  },
  expiresAt: {
    type: "date",
    required: false
  }
} } };

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/jwt/index.mjs
var signJWTBodySchema = object({
  payload: record(string(), any()),
  overrideOptions: record(string(), any()).optional()
});
var verifyJWTBodySchema = object({
  token: string(),
  issuer: string().optional()
});
var jwt = (options) => {
  if (options?.jwt?.sign && !options.jwks?.remoteUrl) throw new BetterAuthError("jwks_config", "jwks.remoteUrl must be set when using jwt.sign");
  if (options?.jwks?.remoteUrl && !options.jwks?.keyPairConfig?.alg) throw new BetterAuthError("jwks_config", "must specify alg when using the oidc plugin and jwks.remoteUrl");
  const jwksPath = options?.jwks?.jwksPath ?? "/jwks";
  if (typeof jwksPath !== "string" || jwksPath.length === 0 || !jwksPath.startsWith("/") || jwksPath.includes("..")) throw new BetterAuthError("jwks_config", "jwksPath must be a non-empty string starting with '/' and not contain '..'");
  return {
    id: "jwt",
    options,
    endpoints: {
      getJwks: createAuthEndpoint(jwksPath, {
        method: "GET",
        metadata: { openapi: {
          operationId: "getJSONWebKeySet",
          description: "Get the JSON Web Key Set",
          responses: { "200": {
            description: "JSON Web Key Set retrieved successfully",
            content: { "application/json": { schema: {
              type: "object",
              properties: { keys: {
                type: "array",
                description: "Array of public JSON Web Keys",
                items: {
                  type: "object",
                  properties: {
                    kid: {
                      type: "string",
                      description: "Key ID uniquely identifying the key, corresponds to the 'id' from the stored Jwk"
                    },
                    kty: {
                      type: "string",
                      description: "Key type (e.g., 'RSA', 'EC', 'OKP')"
                    },
                    alg: {
                      type: "string",
                      description: "Algorithm intended for use with the key (e.g., 'EdDSA', 'RS256')"
                    },
                    use: {
                      type: "string",
                      description: "Intended use of the public key (e.g., 'sig' for signature)",
                      enum: ["sig"],
                      nullable: true
                    },
                    n: {
                      type: "string",
                      description: "Modulus for RSA keys (base64url-encoded)",
                      nullable: true
                    },
                    e: {
                      type: "string",
                      description: "Exponent for RSA keys (base64url-encoded)",
                      nullable: true
                    },
                    crv: {
                      type: "string",
                      description: "Curve name for elliptic curve keys (e.g., 'Ed25519', 'P-256')",
                      nullable: true
                    },
                    x: {
                      type: "string",
                      description: "X coordinate for elliptic curve keys (base64url-encoded)",
                      nullable: true
                    },
                    y: {
                      type: "string",
                      description: "Y coordinate for elliptic curve keys (base64url-encoded)",
                      nullable: true
                    }
                  },
                  required: [
                    "kid",
                    "kty",
                    "alg"
                  ]
                }
              } },
              required: ["keys"]
            } } }
          } }
        } }
      }, async (ctx) => {
        if (options?.jwks?.remoteUrl) throw new APIError("NOT_FOUND");
        const adapter = getJwksAdapter(ctx.context.adapter, options);
        let keySets = await adapter.getAllKeys(ctx);
        if (!keySets || keySets?.length === 0) {
          await createJwk(ctx, options);
          keySets = await adapter.getAllKeys(ctx);
        }
        if (!keySets?.length) throw new BetterAuthError("No key sets found. Make sure you have a key in your database.");
        const now = Date.now();
        const gracePeriod = (options?.jwks?.gracePeriod ?? 3600 * 24 * 30) * 1e3;
        const keys = keySets.filter((key) => {
          if (!key.expiresAt) return true;
          return key.expiresAt.getTime() + gracePeriod > now;
        });
        const keyPairConfig = options?.jwks?.keyPairConfig;
        const defaultCrv = keyPairConfig ? "crv" in keyPairConfig ? keyPairConfig.crv : void 0 : void 0;
        return ctx.json({ keys: keys.map((keySet) => {
          return {
            alg: keySet.alg ?? options?.jwks?.keyPairConfig?.alg ?? "EdDSA",
            crv: keySet.crv ?? defaultCrv,
            ...JSON.parse(keySet.publicKey),
            kid: keySet.id
          };
        }) });
      }),
      getToken: createAuthEndpoint("/token", {
        method: "GET",
        requireHeaders: true,
        use: [sessionMiddleware],
        metadata: { openapi: {
          operationId: "getJSONWebToken",
          description: "Get a JWT token",
          responses: { 200: {
            description: "Success",
            content: { "application/json": { schema: {
              type: "object",
              properties: { token: { type: "string" } }
            } } }
          } }
        } }
      }, async (ctx) => {
        const jwt$1 = await getJwtToken(ctx, options);
        return ctx.json({ token: jwt$1 });
      }),
      signJWT: createAuthEndpoint({
        method: "POST",
        metadata: { $Infer: { body: {} } },
        body: signJWTBodySchema
      }, async (c) => {
        const jwt$1 = await signJWT(c, {
          options: {
            ...options,
            ...c.body.overrideOptions
          },
          payload: c.body.payload
        });
        return c.json({ token: jwt$1 });
      }),
      verifyJWT: createAuthEndpoint({
        method: "POST",
        metadata: { $Infer: {
          body: {},
          response: {}
        } },
        body: verifyJWTBodySchema
      }, async (ctx) => {
        const overrideOptions = ctx.body.issuer ? {
          ...options,
          jwt: {
            ...options?.jwt,
            issuer: ctx.body.issuer
          }
        } : options;
        const payload = await verifyJWT(ctx.body.token, overrideOptions);
        return ctx.json({ payload });
      })
    },
    hooks: { after: [{
      matcher(context) {
        return context.path === "/get-session";
      },
      handler: createAuthMiddleware(async (ctx) => {
        if (options?.disableSettingJwtHeader) return;
        const session = ctx.context.session || ctx.context.newSession;
        if (session && session.session) {
          const jwt$1 = await getJwtToken(ctx, options);
          const exposedHeaders = ctx.context.responseHeaders?.get("access-control-expose-headers") || "";
          const headersSet = new Set(exposedHeaders.split(",").map((header) => header.trim()).filter(Boolean));
          headersSet.add("set-auth-jwt");
          ctx.setHeader("set-auth-jwt", jwt$1);
          ctx.setHeader("Access-Control-Expose-Headers", Array.from(headersSet).join(", "));
        }
      })
    }] },
    schema: mergeSchema(schema4, options?.schema)
  };
};

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/last-login-method/index.mjs
var lastLoginMethod = (userConfig) => {
  const paths = [
    "/callback/:id",
    "/oauth2/callback/:providerId",
    "/sign-in/email",
    "/sign-up/email"
  ];
  const defaultResolveMethod = (ctx) => {
    if (paths.includes(ctx.path)) return ctx.params?.id || ctx.params?.providerId || ctx.path.split("/").pop();
    if (ctx.path.includes("siwe")) return "siwe";
    if (ctx.path.includes("/passkey/verify-authentication")) return "passkey";
    return null;
  };
  const config = {
    cookieName: "better-auth.last_used_login_method",
    maxAge: 3600 * 24 * 30,
    ...userConfig
  };
  return {
    id: "last-login-method",
    init(ctx) {
      return { options: { databaseHooks: {
        user: { create: { async before(user, context) {
          if (!config.storeInDatabase) return;
          if (!context) return;
          const lastUsedLoginMethod = config.customResolveMethod?.(context) ?? defaultResolveMethod(context);
          if (lastUsedLoginMethod) return { data: {
            ...user,
            lastLoginMethod: lastUsedLoginMethod
          } };
        } } },
        session: { create: { async after(session, context) {
          if (!config.storeInDatabase) return;
          if (!context) return;
          const lastUsedLoginMethod = config.customResolveMethod?.(context) ?? defaultResolveMethod(context);
          if (lastUsedLoginMethod && session?.userId) try {
            await ctx.internalAdapter.updateUser(session.userId, { lastLoginMethod: lastUsedLoginMethod });
          } catch (error) {
            ctx.logger.error("Failed to update lastLoginMethod", error);
          }
        } } }
      } } };
    },
    hooks: { after: [{
      matcher() {
        return true;
      },
      handler: createAuthMiddleware(async (ctx) => {
        const lastUsedLoginMethod = config.customResolveMethod?.(ctx) ?? defaultResolveMethod(ctx);
        if (lastUsedLoginMethod) {
          const setCookie = ctx.context.responseHeaders?.get("set-cookie");
          const sessionTokenName = ctx.context.authCookies.sessionToken.name;
          if (setCookie && setCookie.includes(sessionTokenName)) {
            const cookieAttributes = {
              ...ctx.context.authCookies.sessionToken.options,
              maxAge: config.maxAge,
              httpOnly: false
            };
            ctx.setCookie(config.cookieName, lastUsedLoginMethod, cookieAttributes);
          }
        }
      })
    }] },
    schema: config.storeInDatabase ? { user: { fields: { lastLoginMethod: {
      type: "string",
      input: false,
      required: false,
      fieldName: config.schema?.user?.lastLoginMethod || "lastLoginMethod"
    } } } } : void 0,
    options: userConfig
  };
};

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/magic-link/utils.mjs
var defaultKeyHasher3 = async (otp) => {
  const hash = await createHash("SHA-256").digest(new TextEncoder().encode(otp));
  return base64Url.encode(new Uint8Array(hash), { padding: false });
};

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/magic-link/index.mjs
var signInMagicLinkBodySchema = object({
  email: email().meta({ description: "Email address to send the magic link" }),
  name: string().meta({ description: 'User display name. Only used if the user is registering for the first time. Eg: "my-name"' }).optional(),
  callbackURL: string().meta({ description: "URL to redirect after magic link verification" }).optional(),
  newUserCallbackURL: string().meta({ description: "URL to redirect after new user signup. Only used if the user is registering for the first time." }).optional(),
  errorCallbackURL: string().meta({ description: "URL to redirect after error." }).optional()
});
var magicLinkVerifyQuerySchema = object({
  token: string().meta({ description: "Verification token" }),
  callbackURL: string().meta({ description: 'URL to redirect after magic link verification, if not provided the user will be redirected to the root URL. Eg: "/dashboard"' }).optional(),
  errorCallbackURL: string().meta({ description: "URL to redirect after error." }).optional(),
  newUserCallbackURL: string().meta({ description: "URL to redirect after new user signup. Only used if the user is registering for the first time." }).optional()
});
var magicLink = (options) => {
  const opts = {
    storeToken: "plain",
    ...options
  };
  async function storeToken(ctx, token) {
    if (opts.storeToken === "hashed") return await defaultKeyHasher3(token);
    if (typeof opts.storeToken === "object" && "type" in opts.storeToken && opts.storeToken.type === "custom-hasher") return await opts.storeToken.hash(token);
    return token;
  }
  return {
    id: "magic-link",
    endpoints: {
      signInMagicLink: createAuthEndpoint("/sign-in/magic-link", {
        method: "POST",
        requireHeaders: true,
        body: signInMagicLinkBodySchema,
        metadata: { openapi: {
          operationId: "signInWithMagicLink",
          description: "Sign in with magic link",
          responses: { 200: {
            description: "Success",
            content: { "application/json": { schema: {
              type: "object",
              properties: { status: { type: "boolean" } }
            } } }
          } }
        } }
      }, async (ctx) => {
        const { email: email2 } = ctx.body;
        const verificationToken = opts?.generateToken ? await opts.generateToken(email2) : generateRandomString(32, "a-z", "A-Z");
        const storedToken = await storeToken(ctx, verificationToken);
        await ctx.context.internalAdapter.createVerificationValue({
          identifier: storedToken,
          value: JSON.stringify({
            email: email2,
            name: ctx.body.name
          }),
          expiresAt: new Date(Date.now() + (opts.expiresIn || 300) * 1e3)
        });
        const realBaseURL = new URL(ctx.context.baseURL);
        const pathname = realBaseURL.pathname === "/" ? "" : realBaseURL.pathname;
        const basePath = pathname ? "" : ctx.context.options.basePath || "";
        const url = new URL(`${pathname}${basePath}/magic-link/verify`, realBaseURL.origin);
        url.searchParams.set("token", verificationToken);
        url.searchParams.set("callbackURL", ctx.body.callbackURL || "/");
        if (ctx.body.newUserCallbackURL) url.searchParams.set("newUserCallbackURL", ctx.body.newUserCallbackURL);
        if (ctx.body.errorCallbackURL) url.searchParams.set("errorCallbackURL", ctx.body.errorCallbackURL);
        await options.sendMagicLink({
          email: email2,
          url: url.toString(),
          token: verificationToken
        }, ctx);
        return ctx.json({ status: true });
      }),
      magicLinkVerify: createAuthEndpoint("/magic-link/verify", {
        method: "GET",
        query: magicLinkVerifyQuerySchema,
        use: [
          originCheck((ctx) => {
            return ctx.query.callbackURL ? decodeURIComponent(ctx.query.callbackURL) : "/";
          }),
          originCheck((ctx) => {
            return ctx.query.newUserCallbackURL ? decodeURIComponent(ctx.query.newUserCallbackURL) : "/";
          }),
          originCheck((ctx) => {
            return ctx.query.errorCallbackURL ? decodeURIComponent(ctx.query.errorCallbackURL) : "/";
          })
        ],
        requireHeaders: true,
        metadata: { openapi: {
          operationId: "verifyMagicLink",
          description: "Verify magic link",
          responses: { 200: {
            description: "Success",
            content: { "application/json": { schema: {
              type: "object",
              properties: {
                session: { $ref: "#/components/schemas/Session" },
                user: { $ref: "#/components/schemas/User" }
              }
            } } }
          } }
        } }
      }, async (ctx) => {
        const token = ctx.query.token;
        const callbackURL = new URL(ctx.query.callbackURL ? decodeURIComponent(ctx.query.callbackURL) : "/", ctx.context.baseURL).toString();
        const errorCallbackURL = new URL(ctx.query.errorCallbackURL ? decodeURIComponent(ctx.query.errorCallbackURL) : callbackURL, ctx.context.baseURL);
        function redirectWithError(error) {
          errorCallbackURL.searchParams.set("error", error);
          throw ctx.redirect(errorCallbackURL.toString());
        }
        const newUserCallbackURL = new URL(ctx.query.newUserCallbackURL ? decodeURIComponent(ctx.query.newUserCallbackURL) : callbackURL, ctx.context.baseURL).toString();
        const storedToken = await storeToken(ctx, token);
        const tokenValue = await ctx.context.internalAdapter.findVerificationValue(storedToken);
        if (!tokenValue) redirectWithError("INVALID_TOKEN");
        if (tokenValue.expiresAt < /* @__PURE__ */ new Date()) {
          await ctx.context.internalAdapter.deleteVerificationValue(tokenValue.id);
          redirectWithError("EXPIRED_TOKEN");
        }
        await ctx.context.internalAdapter.deleteVerificationValue(tokenValue.id);
        const { email: email2, name } = JSON.parse(tokenValue.value);
        let isNewUser = false;
        let user = await ctx.context.internalAdapter.findUserByEmail(email2).then((res) => res?.user);
        if (!user) if (!opts.disableSignUp) {
          const newUser = await ctx.context.internalAdapter.createUser({
            email: email2,
            emailVerified: true,
            name: name || ""
          });
          isNewUser = true;
          user = newUser;
          if (!user) redirectWithError("failed_to_create_user");
        } else redirectWithError("new_user_signup_disabled");
        if (!user.emailVerified) user = await ctx.context.internalAdapter.updateUser(user.id, { emailVerified: true });
        const session = await ctx.context.internalAdapter.createSession(user.id);
        if (!session) redirectWithError("failed_to_create_session");
        await setSessionCookie(ctx, {
          session,
          user
        });
        if (!ctx.query.callbackURL) return ctx.json({
          token: session.token,
          user: {
            id: user.id,
            email: user.email,
            emailVerified: user.emailVerified,
            name: user.name,
            image: user.image,
            createdAt: user.createdAt,
            updatedAt: user.updatedAt
          }
        });
        if (isNewUser) throw ctx.redirect(newUserCallbackURL);
        throw ctx.redirect(callbackURL);
      })
    },
    rateLimit: [{
      pathMatcher(path) {
        return path.startsWith("/sign-in/magic-link") || path.startsWith("/magic-link/verify");
      },
      window: opts.rateLimit?.window || 60,
      max: opts.rateLimit?.max || 5
    }],
    options
  };
};

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/oidc-provider/error.mjs
var OIDCProviderError = class extends APIError {
};
var InvalidRequest = class extends OIDCProviderError {
  constructor(error_description, error_detail) {
    super("BAD_REQUEST", {
      message: "invalid_request",
      error_description,
      error_detail
    });
  }
};

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/oidc-provider/utils/prompt.mjs
function parsePrompt(prompt) {
  const prompts = prompt.split(" ").map((p) => p.trim());
  const set = /* @__PURE__ */ new Set();
  for (const p of prompts) if (p === "login" || p === "consent" || p === "select_account" || p === "none") set.add(p);
  if (set.has("none") && set.size > 1) throw new InvalidRequest("prompt none must only be used alone");
  return new Set(set);
}

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/oidc-provider/authorize.mjs
function formatErrorURL(url, error, description) {
  return `${url.includes("?") ? "&" : "?"}error=${error}&error_description=${description}`;
}
function getErrorURL(ctx, error, description) {
  return formatErrorURL(ctx.context.options.onAPIError?.errorURL || `${ctx.context.baseURL}/error`, error, description);
}
async function authorize(ctx, options) {
  const handleRedirect = (url) => {
    if (ctx.request?.headers.get("sec-fetch-mode") === "cors") return ctx.json({
      redirect: true,
      url
    });
    else throw ctx.redirect(url);
  };
  const opts = {
    codeExpiresIn: 600,
    defaultScope: "openid",
    ...options,
    scopes: [
      "openid",
      "profile",
      "email",
      "offline_access",
      ...options?.scopes || []
    ]
  };
  if (!ctx.request) throw new APIError("UNAUTHORIZED", {
    error_description: "request not found",
    error: "invalid_request"
  });
  const session = await getSessionFromCtx(ctx);
  if (!session) {
    const query$1 = ctx.query;
    if (parsePrompt(query$1.prompt ?? "").has("none") && query$1.redirect_uri) return handleRedirect(formatErrorURL(query$1.redirect_uri, "login_required", "Authentication required but prompt is none"));
    await ctx.setSignedCookie("oidc_login_prompt", JSON.stringify(ctx.query), ctx.context.secret, {
      maxAge: 600,
      path: "/",
      sameSite: "lax"
    });
    const queryFromURL = ctx.request.url?.split("?")[1];
    return handleRedirect(`${options.loginPage}?${queryFromURL}`);
  }
  const query = ctx.query;
  if (!query.client_id) {
    const errorURL = getErrorURL(ctx, "invalid_client", "client_id is required");
    throw ctx.redirect(errorURL);
  }
  if (!query.response_type) {
    const errorURL = getErrorURL(ctx, "invalid_request", "response_type is required");
    throw ctx.redirect(errorURL);
  }
  const client = await getClient(ctx.query.client_id, options.trustedClients || []);
  if (!client) {
    const errorURL = getErrorURL(ctx, "invalid_client", "client_id is required");
    throw ctx.redirect(errorURL);
  }
  const redirectURI = client.redirectUrls.find((url) => url === ctx.query.redirect_uri);
  if (!redirectURI || !query.redirect_uri)
    throw new APIError("BAD_REQUEST", { message: "Invalid redirect URI" });
  if (client.disabled) {
    const errorURL = getErrorURL(ctx, "client_disabled", "client is disabled");
    throw ctx.redirect(errorURL);
  }
  if (query.response_type !== "code") {
    const errorURL = getErrorURL(ctx, "unsupported_response_type", "unsupported response type");
    throw ctx.redirect(errorURL);
  }
  const requestScope = query.scope?.split(" ").filter((s) => s) || opts.defaultScope?.split(" ") || [];
  const invalidScopes = requestScope.filter((scope) => {
    return !opts.scopes.includes(scope);
  });
  if (invalidScopes.length) return handleRedirect(formatErrorURL(query.redirect_uri, "invalid_scope", `The following scopes are invalid: ${invalidScopes.join(", ")}`));
  if ((!query.code_challenge || !query.code_challenge_method) && options.requirePKCE) return handleRedirect(formatErrorURL(query.redirect_uri, "invalid_request", "pkce is required"));
  if (!query.code_challenge_method) query.code_challenge_method = "plain";
  if (!["s256", options.allowPlainCodeChallengeMethod ? "plain" : "s256"].includes(query.code_challenge_method?.toLowerCase() || "")) return handleRedirect(formatErrorURL(query.redirect_uri, "invalid_request", "invalid code_challenge method"));
  const code = generateRandomString(32, "a-z", "A-Z", "0-9");
  const codeExpiresInMs = opts.codeExpiresIn * 1e3;
  const expiresAt = new Date(Date.now() + codeExpiresInMs);
  const skipConsentForTrustedClient = client.skipConsent;
  const hasAlreadyConsented = await ctx.context.adapter.findOne({
    model: "oauthConsent",
    where: [{
      field: "clientId",
      value: client.clientId
    }, {
      field: "userId",
      value: session.user.id
    }]
  }).then((res) => {
    if (!res?.consentGiven) return false;
    const consentedScopes = res.scopes ? res.scopes.split(" ") : [];
    return requestScope.every((scope) => consentedScopes.includes(scope));
  });
  const promptSet = parsePrompt(query.prompt ?? "");
  if (promptSet.has("none")) {
    if (!skipConsentForTrustedClient && !hasAlreadyConsented) return handleRedirect(formatErrorURL(query.redirect_uri, "consent_required", "Consent required but prompt is none"));
  }
  let requireLogin = promptSet.has("login");
  if (query.max_age !== void 0) {
    const maxAge = Number(query.max_age);
    if (Number.isInteger(maxAge) && maxAge >= 0) {
      if ((Date.now() - new Date(session.session.createdAt).getTime()) / 1e3 > maxAge) requireLogin = true;
    }
  }
  const requireConsent = !skipConsentForTrustedClient && (!hasAlreadyConsented || promptSet.has("consent"));
  try {
    await ctx.context.internalAdapter.createVerificationValue({
      value: JSON.stringify({
        clientId: client.clientId,
        redirectURI: query.redirect_uri,
        scope: requestScope,
        userId: session.user.id,
        authTime: new Date(session.session.createdAt).getTime(),
        requireConsent,
        state: requireConsent ? query.state : null,
        codeChallenge: query.code_challenge,
        codeChallengeMethod: query.code_challenge_method,
        nonce: query.nonce
      }),
      identifier: code,
      expiresAt
    });
  } catch {
    return handleRedirect(formatErrorURL(query.redirect_uri, "server_error", "An error occurred while processing the request"));
  }
  if (requireLogin) {
    await ctx.setSignedCookie("oidc_login_prompt", JSON.stringify(ctx.query), ctx.context.secret, {
      maxAge: 600,
      path: "/",
      sameSite: "lax"
    });
    await ctx.setSignedCookie("oidc_consent_prompt", code, ctx.context.secret, {
      maxAge: 600,
      path: "/",
      sameSite: "lax"
    });
    return handleRedirect(`${options.loginPage}?${new URLSearchParams({
      client_id: client.clientId,
      code,
      state: query.state
    }).toString()}`);
  }
  if (!requireConsent) {
    const redirectURIWithCode = new URL(redirectURI);
    redirectURIWithCode.searchParams.set("code", code);
    redirectURIWithCode.searchParams.set("state", ctx.query.state);
    return handleRedirect(redirectURIWithCode.toString());
  }
  if (options?.consentPage) {
    await ctx.setSignedCookie("oidc_consent_prompt", code, ctx.context.secret, {
      maxAge: 600,
      path: "/",
      sameSite: "lax"
    });
    const urlParams = new URLSearchParams();
    urlParams.set("consent_code", code);
    urlParams.set("client_id", client.clientId);
    urlParams.set("scope", requestScope.join(" "));
    return handleRedirect(`${options.consentPage}?${urlParams.toString()}`);
  }
  const htmlFn = options?.getConsentHTML;
  if (!htmlFn) throw new APIError("INTERNAL_SERVER_ERROR", { message: "No consent page provided" });
  return new Response(htmlFn({
    scopes: requestScope,
    clientMetadata: client.metadata,
    clientIcon: client?.icon,
    clientId: client.clientId,
    clientName: client.name,
    code
  }), { headers: { "content-type": "text/html" } });
}

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/oidc-provider/schema.mjs
object({
  clientId: string(),
  clientSecret: string().optional(),
  type: _enum([
    "web",
    "native",
    "user-agent-based",
    "public"
  ]),
  name: string(),
  icon: string().optional(),
  metadata: string().optional(),
  disabled: boolean().optional().default(false),
  redirectUrls: string(),
  userId: string().optional(),
  createdAt: date(),
  updatedAt: date()
});
var schema5 = {
  oauthApplication: {
    modelName: "oauthApplication",
    fields: {
      name: { type: "string" },
      icon: {
        type: "string",
        required: false
      },
      metadata: {
        type: "string",
        required: false
      },
      clientId: {
        type: "string",
        unique: true
      },
      clientSecret: {
        type: "string",
        required: false
      },
      redirectUrls: { type: "string" },
      type: { type: "string" },
      disabled: {
        type: "boolean",
        required: false,
        defaultValue: false
      },
      userId: {
        type: "string",
        required: false,
        references: {
          model: "user",
          field: "id",
          onDelete: "cascade"
        },
        index: true
      },
      createdAt: { type: "date" },
      updatedAt: { type: "date" }
    }
  },
  oauthAccessToken: {
    modelName: "oauthAccessToken",
    fields: {
      accessToken: {
        type: "string",
        unique: true
      },
      refreshToken: {
        type: "string",
        unique: true
      },
      accessTokenExpiresAt: { type: "date" },
      refreshTokenExpiresAt: { type: "date" },
      clientId: {
        type: "string",
        references: {
          model: "oauthApplication",
          field: "clientId",
          onDelete: "cascade"
        },
        index: true
      },
      userId: {
        type: "string",
        required: false,
        references: {
          model: "user",
          field: "id",
          onDelete: "cascade"
        },
        index: true
      },
      scopes: { type: "string" },
      createdAt: { type: "date" },
      updatedAt: { type: "date" }
    }
  },
  oauthConsent: {
    modelName: "oauthConsent",
    fields: {
      clientId: {
        type: "string",
        references: {
          model: "oauthApplication",
          field: "clientId",
          onDelete: "cascade"
        },
        index: true
      },
      userId: {
        type: "string",
        references: {
          model: "user",
          field: "id",
          onDelete: "cascade"
        },
        index: true
      },
      scopes: { type: "string" },
      createdAt: { type: "date" },
      updatedAt: { type: "date" },
      consentGiven: { type: "boolean" }
    }
  }
};

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/oidc-provider/utils.mjs
var defaultClientSecretHasher = async (clientSecret) => {
  const hash = await createHash("SHA-256").digest(new TextEncoder().encode(clientSecret));
  return base64Url.encode(new Uint8Array(hash), { padding: false });
};

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/oidc-provider/index.mjs
var getJwtPlugin = (ctx) => {
  return ctx.context.options.plugins?.find((plugin) => plugin.id === "jwt");
};
async function getClient(clientId, trustedClients = []) {
  const { context: { adapter } } = await getCurrentAuthContext();
  const trustedClient = trustedClients.find((client) => client.clientId === clientId);
  if (trustedClient) return trustedClient;
  return adapter.findOne({
    model: "oauthApplication",
    where: [{
      field: "clientId",
      value: clientId
    }]
  }).then((res) => {
    if (!res) return null;
    return {
      clientId: res.clientId,
      clientSecret: res.clientSecret,
      type: res.type,
      name: res.name,
      icon: res.icon,
      disabled: res.disabled,
      redirectUrls: (res.redirectUrls ?? "").split(","),
      metadata: res.metadata ? JSON.parse(res.metadata) : {}
    };
  });
}
var getMetadata = (ctx, options) => {
  const jwtPlugin = getJwtPlugin(ctx);
  const issuer = jwtPlugin && jwtPlugin.options?.jwt && jwtPlugin.options.jwt.issuer ? jwtPlugin.options.jwt.issuer : ctx.context.options.baseURL;
  const baseURL = ctx.context.baseURL;
  const supportedAlgs = options?.useJWTPlugin ? [
    "RS256",
    "EdDSA",
    "none"
  ] : ["HS256", "none"];
  return {
    issuer,
    authorization_endpoint: `${baseURL}/oauth2/authorize`,
    token_endpoint: `${baseURL}/oauth2/token`,
    userinfo_endpoint: `${baseURL}/oauth2/userinfo`,
    jwks_uri: `${baseURL}/jwks`,
    registration_endpoint: `${baseURL}/oauth2/register`,
    end_session_endpoint: `${baseURL}/oauth2/endsession`,
    scopes_supported: [
      "openid",
      "profile",
      "email",
      "offline_access"
    ],
    response_types_supported: ["code"],
    response_modes_supported: ["query"],
    grant_types_supported: ["authorization_code", "refresh_token"],
    acr_values_supported: ["urn:mace:incommon:iap:silver", "urn:mace:incommon:iap:bronze"],
    subject_types_supported: ["public"],
    id_token_signing_alg_values_supported: supportedAlgs,
    token_endpoint_auth_methods_supported: [
      "client_secret_basic",
      "client_secret_post",
      "none"
    ],
    code_challenge_methods_supported: ["S256"],
    claims_supported: [
      "sub",
      "iss",
      "aud",
      "exp",
      "nbf",
      "iat",
      "jti",
      "email",
      "email_verified",
      "name"
    ],
    ...options?.metadata
  };
};
var oAuthConsentBodySchema = object({
  accept: boolean(),
  consent_code: string().optional().nullish()
});
var oAuth2TokenBodySchema = record(any(), any());
var registerOAuthApplicationBodySchema = object({
  redirect_uris: array(string()).meta({ description: 'A list of redirect URIs. Eg: ["https://client.example.com/callback"]' }),
  token_endpoint_auth_method: _enum([
    "none",
    "client_secret_basic",
    "client_secret_post"
  ]).meta({ description: 'The authentication method for the token endpoint. Eg: "client_secret_basic"' }).default("client_secret_basic").optional(),
  grant_types: array(_enum([
    "authorization_code",
    "implicit",
    "password",
    "client_credentials",
    "refresh_token",
    "urn:ietf:params:oauth:grant-type:jwt-bearer",
    "urn:ietf:params:oauth:grant-type:saml2-bearer"
  ])).meta({ description: 'The grant types supported by the application. Eg: ["authorization_code"]' }).default(["authorization_code"]).optional(),
  response_types: array(_enum(["code", "token"])).meta({ description: 'The response types supported by the application. Eg: ["code"]' }).default(["code"]).optional(),
  client_name: string().meta({ description: 'The name of the application. Eg: "My App"' }).optional(),
  client_uri: string().meta({ description: 'The URI of the application. Eg: "https://client.example.com"' }).optional(),
  logo_uri: string().meta({ description: 'The URI of the application logo. Eg: "https://client.example.com/logo.png"' }).optional(),
  scope: string().meta({ description: 'The scopes supported by the application. Separated by spaces. Eg: "profile email"' }).optional(),
  contacts: array(string()).meta({ description: 'The contact information for the application. Eg: ["admin@example.com"]' }).optional(),
  tos_uri: string().meta({ description: 'The URI of the application terms of service. Eg: "https://client.example.com/tos"' }).optional(),
  policy_uri: string().meta({ description: 'The URI of the application privacy policy. Eg: "https://client.example.com/policy"' }).optional(),
  jwks_uri: string().meta({ description: 'The URI of the application JWKS. Eg: "https://client.example.com/jwks"' }).optional(),
  jwks: record(any(), any()).meta({ description: 'The JWKS of the application. Eg: {"keys": [{"kty": "RSA", "alg": "RS256", "use": "sig", "n": "...", "e": "..."}]}' }).optional(),
  metadata: record(any(), any()).meta({ description: 'The metadata of the application. Eg: {"key": "value"}' }).optional(),
  software_id: string().meta({ description: 'The software ID of the application. Eg: "my-software"' }).optional(),
  software_version: string().meta({ description: 'The software version of the application. Eg: "1.0.0"' }).optional(),
  software_statement: string().meta({ description: "The software statement of the application." }).optional()
});
var DEFAULT_CODE_EXPIRES_IN = 600;
var DEFAULT_ACCESS_TOKEN_EXPIRES_IN = 3600;
var DEFAULT_REFRESH_TOKEN_EXPIRES_IN = 604800;
var oidcProvider = (options) => {
  const modelName = {
    oauthClient: "oauthApplication",
    oauthAccessToken: "oauthAccessToken",
    oauthConsent: "oauthConsent"
  };
  const opts = {
    codeExpiresIn: DEFAULT_CODE_EXPIRES_IN,
    defaultScope: "openid",
    accessTokenExpiresIn: DEFAULT_ACCESS_TOKEN_EXPIRES_IN,
    refreshTokenExpiresIn: DEFAULT_REFRESH_TOKEN_EXPIRES_IN,
    allowPlainCodeChallengeMethod: true,
    storeClientSecret: "plain",
    ...options,
    scopes: [
      "openid",
      "profile",
      "email",
      "offline_access",
      ...options?.scopes || []
    ]
  };
  const trustedClients = options.trustedClients || [];
  async function storeClientSecret(ctx, clientSecret) {
    if (opts.storeClientSecret === "encrypted") return await symmetricEncrypt({
      key: ctx.context.secret,
      data: clientSecret
    });
    if (opts.storeClientSecret === "hashed") return await defaultClientSecretHasher(clientSecret);
    if (typeof opts.storeClientSecret === "object" && "hash" in opts.storeClientSecret) return await opts.storeClientSecret.hash(clientSecret);
    if (typeof opts.storeClientSecret === "object" && "encrypt" in opts.storeClientSecret) return await opts.storeClientSecret.encrypt(clientSecret);
    return clientSecret;
  }
  async function verifyStoredClientSecret(ctx, storedClientSecret, clientSecret) {
    if (opts.storeClientSecret === "encrypted") return await symmetricDecrypt({
      key: ctx.context.secret,
      data: storedClientSecret
    }) === clientSecret;
    if (opts.storeClientSecret === "hashed") return await defaultClientSecretHasher(clientSecret) === storedClientSecret;
    if (typeof opts.storeClientSecret === "object" && "hash" in opts.storeClientSecret) return await opts.storeClientSecret.hash(clientSecret) === storedClientSecret;
    if (typeof opts.storeClientSecret === "object" && "decrypt" in opts.storeClientSecret) return await opts.storeClientSecret.decrypt(storedClientSecret) === clientSecret;
    return clientSecret === storedClientSecret;
  }
  return {
    id: "oidc",
    hooks: { after: [{
      matcher() {
        return true;
      },
      handler: createAuthMiddleware(async (ctx) => {
        const loginPromptCookie = await ctx.getSignedCookie("oidc_login_prompt", ctx.context.secret);
        const cookieName = ctx.context.authCookies.sessionToken.name;
        const parsedSetCookieHeader = parseSetCookieHeader(ctx.context.responseHeaders?.get("set-cookie") || "");
        const hasSessionToken = parsedSetCookieHeader.has(cookieName);
        if (!loginPromptCookie || !hasSessionToken) return;
        ctx.setCookie("oidc_login_prompt", "", { maxAge: 0 });
        const sessionToken = parsedSetCookieHeader.get(cookieName)?.value?.split(".")[0];
        if (!sessionToken) return;
        const session = await ctx.context.internalAdapter.findSession(sessionToken) || ctx.context.newSession;
        if (!session) return;
        ctx.query = JSON.parse(loginPromptCookie);
        const promptSet = parsePrompt(String(ctx.query?.prompt));
        if (promptSet.has("login")) {
          const newPromptSet = new Set(promptSet);
          newPromptSet.delete("login");
          ctx.query = {
            ...ctx.query,
            prompt: Array.from(newPromptSet).join(" ")
          };
        }
        ctx.context.session = session;
        return await authorize(ctx, opts);
      })
    }] },
    endpoints: {
      getOpenIdConfig: createAuthEndpoint("/.well-known/openid-configuration", {
        method: "GET",
        operationId: "getOpenIdConfig",
        metadata: HIDE_METADATA
      }, async (ctx) => {
        const metadata = getMetadata(ctx, options);
        return ctx.json(metadata);
      }),
      oAuth2authorize: createAuthEndpoint("/oauth2/authorize", {
        method: "GET",
        operationId: "oauth2Authorize",
        query: record(string(), any()),
        metadata: { openapi: {
          description: "Authorize an OAuth2 request",
          responses: { "200": {
            description: "Authorization response generated successfully",
            content: { "application/json": { schema: {
              type: "object",
              additionalProperties: true,
              description: "Authorization response, contents depend on the authorize function implementation"
            } } }
          } }
        } }
      }, async (ctx) => {
        return authorize(ctx, opts);
      }),
      oAuthConsent: createAuthEndpoint("/oauth2/consent", {
        method: "POST",
        operationId: "oauth2Consent",
        body: oAuthConsentBodySchema,
        use: [sessionMiddleware],
        metadata: { openapi: {
          description: "Handle OAuth2 consent. Supports both URL parameter-based flows (consent_code in body) and cookie-based flows (signed cookie).",
          requestBody: {
            required: true,
            content: { "application/json": { schema: {
              type: "object",
              properties: {
                accept: {
                  type: "boolean",
                  description: "Whether the user accepts or denies the consent request"
                },
                consent_code: {
                  type: "string",
                  description: "The consent code from the authorization request. Optional if using cookie-based flow."
                }
              },
              required: ["accept"]
            } } }
          },
          responses: { "200": {
            description: "Consent processed successfully",
            content: { "application/json": { schema: {
              type: "object",
              properties: { redirectURI: {
                type: "string",
                format: "uri",
                description: "The URI to redirect to, either with an authorization code or an error"
              } },
              required: ["redirectURI"]
            } } }
          } }
        } }
      }, async (ctx) => {
        let consentCode = ctx.body.consent_code || null;
        if (!consentCode) {
          const cookieValue = await ctx.getSignedCookie("oidc_consent_prompt", ctx.context.secret);
          if (cookieValue) consentCode = cookieValue;
        }
        if (!consentCode) throw new APIError("UNAUTHORIZED", {
          error_description: "consent_code is required (either in body or cookie)",
          error: "invalid_request"
        });
        const verification = await ctx.context.internalAdapter.findVerificationValue(consentCode);
        if (!verification) throw new APIError("UNAUTHORIZED", {
          error_description: "Invalid code",
          error: "invalid_request"
        });
        if (verification.expiresAt < /* @__PURE__ */ new Date()) throw new APIError("UNAUTHORIZED", {
          error_description: "Code expired",
          error: "invalid_request"
        });
        ctx.setCookie("oidc_consent_prompt", "", { maxAge: 0 });
        const value = JSON.parse(verification.value);
        if (!value.requireConsent) throw new APIError("UNAUTHORIZED", {
          error_description: "Consent not required",
          error: "invalid_request"
        });
        if (!ctx.body.accept) {
          await ctx.context.internalAdapter.deleteVerificationValue(verification.id);
          return ctx.json({ redirectURI: `${value.redirectURI}?error=access_denied&error_description=User denied access` });
        }
        const code = generateRandomString(32, "a-z", "A-Z", "0-9");
        const codeExpiresInMs = (opts?.codeExpiresIn ?? DEFAULT_CODE_EXPIRES_IN) * 1e3;
        const expiresAt = new Date(Date.now() + codeExpiresInMs);
        await ctx.context.internalAdapter.updateVerificationValue(verification.id, {
          value: JSON.stringify({
            ...value,
            requireConsent: false
          }),
          identifier: code,
          expiresAt
        });
        await ctx.context.adapter.create({
          model: modelName.oauthConsent,
          data: {
            clientId: value.clientId,
            userId: value.userId,
            scopes: value.scope.join(" "),
            consentGiven: true,
            createdAt: /* @__PURE__ */ new Date(),
            updatedAt: /* @__PURE__ */ new Date()
          }
        });
        const redirectURI = new URL(value.redirectURI);
        redirectURI.searchParams.set("code", code);
        if (value.state) redirectURI.searchParams.set("state", value.state);
        return ctx.json({ redirectURI: redirectURI.toString() });
      }),
      oAuth2token: createAuthEndpoint("/oauth2/token", {
        method: "POST",
        operationId: "oauth2Token",
        body: oAuth2TokenBodySchema,
        metadata: {
          ...HIDE_METADATA,
          allowedMediaTypes: ["application/x-www-form-urlencoded", "application/json"]
        }
      }, async (ctx) => {
        let { body } = ctx;
        if (!body) throw new APIError("BAD_REQUEST", {
          error_description: "request body not found",
          error: "invalid_request"
        });
        if (body instanceof FormData) body = Object.fromEntries(body.entries());
        if (!(body instanceof Object)) throw new APIError("BAD_REQUEST", {
          error_description: "request body is not an object",
          error: "invalid_request"
        });
        let { client_id, client_secret } = body;
        const authorization = ctx.request?.headers.get("authorization") || null;
        if (authorization && !client_id && !client_secret && authorization.startsWith("Basic ")) try {
          const encoded = authorization.replace("Basic ", "");
          const decoded = new TextDecoder().decode(base64.decode(encoded));
          if (!decoded.includes(":")) throw new APIError("UNAUTHORIZED", {
            error_description: "invalid authorization header format",
            error: "invalid_client"
          });
          const [id, secret] = decoded.split(":");
          if (!id || !secret) throw new APIError("UNAUTHORIZED", {
            error_description: "invalid authorization header format",
            error: "invalid_client"
          });
          client_id = id;
          client_secret = secret;
        } catch {
          throw new APIError("UNAUTHORIZED", {
            error_description: "invalid authorization header format",
            error: "invalid_client"
          });
        }
        const now = Date.now();
        const iat = Math.floor(now / 1e3);
        const exp = iat + (opts.accessTokenExpiresIn ?? 3600);
        const accessTokenExpiresAt = new Date(exp * 1e3);
        const refreshTokenExpiresAt = new Date((iat + (opts.refreshTokenExpiresIn ?? 604800)) * 1e3);
        const { grant_type, code, redirect_uri, refresh_token, code_verifier } = body;
        if (grant_type === "refresh_token") {
          if (!refresh_token) throw new APIError("BAD_REQUEST", {
            error_description: "refresh_token is required",
            error: "invalid_request"
          });
          const token = await ctx.context.adapter.findOne({
            model: modelName.oauthAccessToken,
            where: [{
              field: "refreshToken",
              value: refresh_token.toString()
            }]
          });
          if (!token) throw new APIError("UNAUTHORIZED", {
            error_description: "invalid refresh token",
            error: "invalid_grant"
          });
          if (token.clientId !== client_id?.toString()) throw new APIError("UNAUTHORIZED", {
            error_description: "invalid client_id",
            error: "invalid_client"
          });
          if (token.refreshTokenExpiresAt < /* @__PURE__ */ new Date()) throw new APIError("UNAUTHORIZED", {
            error_description: "refresh token expired",
            error: "invalid_grant"
          });
          const accessToken$1 = generateRandomString(32, "a-z", "A-Z");
          const newRefreshToken = generateRandomString(32, "a-z", "A-Z");
          await ctx.context.adapter.create({
            model: modelName.oauthAccessToken,
            data: {
              accessToken: accessToken$1,
              refreshToken: newRefreshToken,
              accessTokenExpiresAt,
              refreshTokenExpiresAt,
              clientId: client_id.toString(),
              userId: token.userId,
              scopes: token.scopes,
              createdAt: new Date(iat * 1e3),
              updatedAt: new Date(iat * 1e3)
            }
          });
          return ctx.json({
            access_token: accessToken$1,
            token_type: "Bearer",
            expires_in: opts.accessTokenExpiresIn,
            refresh_token: newRefreshToken,
            scope: token.scopes
          });
        }
        if (!code) throw new APIError("BAD_REQUEST", {
          error_description: "code is required",
          error: "invalid_request"
        });
        if (options.requirePKCE && !code_verifier) throw new APIError("BAD_REQUEST", {
          error_description: "code verifier is missing",
          error: "invalid_request"
        });
        const verificationValue = await ctx.context.internalAdapter.findVerificationValue(code.toString());
        if (!verificationValue) throw new APIError("UNAUTHORIZED", {
          error_description: "invalid code",
          error: "invalid_grant"
        });
        if (verificationValue.expiresAt < /* @__PURE__ */ new Date()) throw new APIError("UNAUTHORIZED", {
          error_description: "code expired",
          error: "invalid_grant"
        });
        await ctx.context.internalAdapter.deleteVerificationValue(verificationValue.id);
        if (!client_id) throw new APIError("UNAUTHORIZED", {
          error_description: "client_id is required",
          error: "invalid_client"
        });
        if (!grant_type) throw new APIError("BAD_REQUEST", {
          error_description: "grant_type is required",
          error: "invalid_request"
        });
        if (grant_type !== "authorization_code") throw new APIError("BAD_REQUEST", {
          error_description: "grant_type must be 'authorization_code'",
          error: "unsupported_grant_type"
        });
        if (!redirect_uri) throw new APIError("BAD_REQUEST", {
          error_description: "redirect_uri is required",
          error: "invalid_request"
        });
        const client = await getClient(client_id.toString(), trustedClients);
        if (!client) throw new APIError("UNAUTHORIZED", {
          error_description: "invalid client_id",
          error: "invalid_client"
        });
        if (client.disabled) throw new APIError("UNAUTHORIZED", {
          error_description: "client is disabled",
          error: "invalid_client"
        });
        const value = JSON.parse(verificationValue.value);
        if (value.clientId !== client_id.toString()) throw new APIError("UNAUTHORIZED", {
          error_description: "invalid client_id",
          error: "invalid_client"
        });
        if (value.redirectURI !== redirect_uri.toString()) throw new APIError("UNAUTHORIZED", {
          error_description: "invalid redirect_uri",
          error: "invalid_client"
        });
        if (value.codeChallenge && !code_verifier) throw new APIError("BAD_REQUEST", {
          error_description: "code verifier is missing",
          error: "invalid_request"
        });
        if (client.type === "public") {
          if (!code_verifier) throw new APIError("BAD_REQUEST", {
            error_description: "code verifier is required for public clients",
            error: "invalid_request"
          });
        } else {
          if (!client.clientSecret || !client_secret) throw new APIError("UNAUTHORIZED", {
            error_description: "client_secret is required for confidential clients",
            error: "invalid_client"
          });
          if (!await verifyStoredClientSecret(ctx, client.clientSecret, client_secret.toString())) throw new APIError("UNAUTHORIZED", {
            error_description: "invalid client_secret",
            error: "invalid_client"
          });
        }
        if ((value.codeChallengeMethod === "plain" ? code_verifier : await createHash("SHA-256", "base64urlnopad").digest(code_verifier)) !== value.codeChallenge) throw new APIError("UNAUTHORIZED", {
          error_description: "code verification failed",
          error: "invalid_request"
        });
        const requestedScopes = value.scope;
        await ctx.context.internalAdapter.deleteVerificationValue(verificationValue.id);
        const accessToken = generateRandomString(32, "a-z", "A-Z");
        const refreshToken = generateRandomString(32, "A-Z", "a-z");
        await ctx.context.adapter.create({
          model: modelName.oauthAccessToken,
          data: {
            accessToken,
            refreshToken,
            accessTokenExpiresAt,
            refreshTokenExpiresAt,
            clientId: client_id.toString(),
            userId: value.userId,
            scopes: requestedScopes.join(" "),
            createdAt: new Date(iat * 1e3),
            updatedAt: new Date(iat * 1e3)
          }
        });
        const user = await ctx.context.internalAdapter.findUserById(value.userId);
        if (!user) throw new APIError("UNAUTHORIZED", {
          error_description: "user not found",
          error: "invalid_grant"
        });
        const profile = {
          given_name: user.name.split(" ")[0],
          family_name: user.name.split(" ")[1],
          name: user.name,
          profile: user.image,
          updated_at: new Date(user.updatedAt).toISOString()
        };
        const email2 = {
          email: user.email,
          email_verified: user.emailVerified
        };
        const userClaims = {
          ...requestedScopes.includes("profile") ? profile : {},
          ...requestedScopes.includes("email") ? email2 : {}
        };
        const additionalUserClaims = options.getAdditionalUserInfoClaim ? await options.getAdditionalUserInfoClaim(user, requestedScopes, client) : {};
        const payload = {
          sub: user.id,
          aud: client_id.toString(),
          iat,
          auth_time: ctx.context.session ? new Date(ctx.context.session.session.createdAt).getTime() : void 0,
          nonce: value.nonce,
          acr: "urn:mace:incommon:iap:silver",
          ...userClaims,
          ...additionalUserClaims
        };
        const expirationTime = Math.floor(Date.now() / 1e3) + (opts?.accessTokenExpiresIn ?? DEFAULT_ACCESS_TOKEN_EXPIRES_IN);
        let idToken;
        if (options.useJWTPlugin) {
          const jwtPlugin = getJwtPlugin(ctx);
          if (!jwtPlugin) {
            ctx.context.logger.error("OIDC: `useJWTPlugin` is enabled but the JWT plugin is not available. Make sure you have the JWT Plugin in your plugins array or set `useJWTPlugin` to false.");
            throw new APIError("INTERNAL_SERVER_ERROR", {
              error_description: "JWT plugin is not enabled",
              error: "internal_server_error"
            });
          }
          idToken = await getJwtToken({
            ...ctx,
            context: {
              ...ctx.context,
              session: {
                session: {
                  id: generateRandomString(32, "a-z", "A-Z"),
                  createdAt: new Date(iat * 1e3),
                  updatedAt: new Date(iat * 1e3),
                  userId: user.id,
                  expiresAt: accessTokenExpiresAt,
                  token: accessToken,
                  ipAddress: ctx.request?.headers.get("x-forwarded-for")
                },
                user
              }
            }
          }, {
            ...jwtPlugin.options,
            jwt: {
              ...jwtPlugin.options?.jwt,
              getSubject: () => user.id,
              audience: client_id.toString(),
              issuer: jwtPlugin.options?.jwt?.issuer ?? ctx.context.options.baseURL,
              expirationTime,
              definePayload: () => payload
            }
          });
        } else idToken = await new SignJWT(payload).setProtectedHeader({ alg: "HS256" }).setIssuedAt(iat).setExpirationTime(accessTokenExpiresAt).sign(new TextEncoder().encode(client.clientSecret));
        return ctx.json({
          access_token: accessToken,
          token_type: "Bearer",
          expires_in: opts.accessTokenExpiresIn,
          refresh_token: requestedScopes.includes("offline_access") ? refreshToken : void 0,
          scope: requestedScopes.join(" "),
          id_token: requestedScopes.includes("openid") ? idToken : void 0
        }, { headers: {
          "Cache-Control": "no-store",
          Pragma: "no-cache"
        } });
      }),
      oAuth2userInfo: createAuthEndpoint("/oauth2/userinfo", {
        method: "GET",
        operationId: "oauth2Userinfo",
        metadata: {
          ...HIDE_METADATA,
          openapi: {
            description: "Get OAuth2 user information",
            responses: { "200": {
              description: "User information retrieved successfully",
              content: { "application/json": { schema: {
                type: "object",
                properties: {
                  sub: {
                    type: "string",
                    description: "Subject identifier (user ID)"
                  },
                  email: {
                    type: "string",
                    format: "email",
                    nullable: true,
                    description: "User's email address, included if 'email' scope is granted"
                  },
                  name: {
                    type: "string",
                    nullable: true,
                    description: "User's full name, included if 'profile' scope is granted"
                  },
                  picture: {
                    type: "string",
                    format: "uri",
                    nullable: true,
                    description: "User's profile picture URL, included if 'profile' scope is granted"
                  },
                  given_name: {
                    type: "string",
                    nullable: true,
                    description: "User's given name, included if 'profile' scope is granted"
                  },
                  family_name: {
                    type: "string",
                    nullable: true,
                    description: "User's family name, included if 'profile' scope is granted"
                  },
                  email_verified: {
                    type: "boolean",
                    nullable: true,
                    description: "Whether the email is verified, included if 'email' scope is granted"
                  }
                },
                required: ["sub"]
              } } }
            } }
          }
        }
      }, async (ctx) => {
        if (!ctx.request) throw new APIError("UNAUTHORIZED", {
          error_description: "request not found",
          error: "invalid_request"
        });
        const authorization = ctx.request.headers.get("authorization");
        if (!authorization) throw new APIError("UNAUTHORIZED", {
          error_description: "authorization header not found",
          error: "invalid_request"
        });
        const token = authorization.replace("Bearer ", "");
        const accessToken = await ctx.context.adapter.findOne({
          model: modelName.oauthAccessToken,
          where: [{
            field: "accessToken",
            value: token
          }]
        });
        if (!accessToken) throw new APIError("UNAUTHORIZED", {
          error_description: "invalid access token",
          error: "invalid_token"
        });
        if (accessToken.accessTokenExpiresAt < /* @__PURE__ */ new Date()) throw new APIError("UNAUTHORIZED", {
          error_description: "The Access Token expired",
          error: "invalid_token"
        });
        const client = await getClient(accessToken.clientId, trustedClients);
        if (!client) throw new APIError("UNAUTHORIZED", {
          error_description: "client not found",
          error: "invalid_token"
        });
        const user = await ctx.context.internalAdapter.findUserById(accessToken.userId);
        if (!user) throw new APIError("UNAUTHORIZED", {
          error_description: "user not found",
          error: "invalid_token"
        });
        const requestedScopes = accessToken.scopes.split(" ");
        const baseUserClaims = {
          sub: user.id,
          email: requestedScopes.includes("email") ? user.email : void 0,
          name: requestedScopes.includes("profile") ? user.name : void 0,
          picture: requestedScopes.includes("profile") ? user.image : void 0,
          given_name: requestedScopes.includes("profile") ? user.name.split(" ")[0] : void 0,
          family_name: requestedScopes.includes("profile") ? user.name.split(" ")[1] : void 0,
          email_verified: requestedScopes.includes("email") ? user.emailVerified : void 0
        };
        const userClaims = options.getAdditionalUserInfoClaim ? await options.getAdditionalUserInfoClaim(user, requestedScopes, client) : baseUserClaims;
        return ctx.json({
          ...baseUserClaims,
          ...userClaims
        });
      }),
      registerOAuthApplication: createAuthEndpoint("/oauth2/register", {
        method: "POST",
        body: registerOAuthApplicationBodySchema,
        metadata: { openapi: {
          description: "Register an OAuth2 application",
          responses: { "200": {
            description: "OAuth2 application registered successfully",
            content: { "application/json": { schema: {
              type: "object",
              properties: {
                name: {
                  type: "string",
                  description: "Name of the OAuth2 application"
                },
                icon: {
                  type: "string",
                  nullable: true,
                  description: "Icon URL for the application"
                },
                metadata: {
                  type: "object",
                  additionalProperties: true,
                  nullable: true,
                  description: "Additional metadata for the application"
                },
                clientId: {
                  type: "string",
                  description: "Unique identifier for the client"
                },
                clientSecret: {
                  type: "string",
                  description: "Secret key for the client"
                },
                redirectURLs: {
                  type: "array",
                  items: {
                    type: "string",
                    format: "uri"
                  },
                  description: "List of allowed redirect URLs"
                },
                type: {
                  type: "string",
                  description: "Type of the client",
                  enum: ["web"]
                },
                authenticationScheme: {
                  type: "string",
                  description: "Authentication scheme used by the client",
                  enum: ["client_secret"]
                },
                disabled: {
                  type: "boolean",
                  description: "Whether the client is disabled",
                  enum: [false]
                },
                userId: {
                  type: "string",
                  nullable: true,
                  description: "ID of the user who registered the client, null if registered anonymously"
                },
                createdAt: {
                  type: "string",
                  format: "date-time",
                  description: "Creation timestamp"
                },
                updatedAt: {
                  type: "string",
                  format: "date-time",
                  description: "Last update timestamp"
                }
              },
              required: [
                "name",
                "clientId",
                "clientSecret",
                "redirectURLs",
                "type",
                "authenticationScheme",
                "disabled",
                "createdAt",
                "updatedAt"
              ]
            } } }
          } }
        } }
      }, async (ctx) => {
        const body = ctx.body;
        const session = await getSessionFromCtx(ctx);
        if (!session && !options.allowDynamicClientRegistration) throw new APIError("UNAUTHORIZED", {
          error: "invalid_token",
          error_description: "Authentication required for client registration"
        });
        if ((!body.grant_types || body.grant_types.includes("authorization_code") || body.grant_types.includes("implicit")) && (!body.redirect_uris || body.redirect_uris.length === 0)) throw new APIError("BAD_REQUEST", {
          error: "invalid_redirect_uri",
          error_description: "Redirect URIs are required for authorization_code and implicit grant types"
        });
        if (body.grant_types && body.response_types) {
          if (body.grant_types.includes("authorization_code") && !body.response_types.includes("code")) throw new APIError("BAD_REQUEST", {
            error: "invalid_client_metadata",
            error_description: "When 'authorization_code' grant type is used, 'code' response type must be included"
          });
          if (body.grant_types.includes("implicit") && !body.response_types.includes("token")) throw new APIError("BAD_REQUEST", {
            error: "invalid_client_metadata",
            error_description: "When 'implicit' grant type is used, 'token' response type must be included"
          });
        }
        const clientId = options.generateClientId?.() || generateRandomString(32, "a-z", "A-Z");
        const clientSecret = options.generateClientSecret?.() || generateRandomString(32, "a-z", "A-Z");
        const storedClientSecret = await storeClientSecret(ctx, clientSecret);
        const client = await ctx.context.adapter.create({
          model: modelName.oauthClient,
          data: {
            name: body.client_name,
            icon: body.logo_uri,
            metadata: body.metadata ? JSON.stringify(body.metadata) : null,
            clientId,
            clientSecret: storedClientSecret,
            redirectUrls: body.redirect_uris.join(","),
            type: "web",
            authenticationScheme: body.token_endpoint_auth_method || "client_secret_basic",
            disabled: false,
            userId: session?.session.userId,
            createdAt: /* @__PURE__ */ new Date(),
            updatedAt: /* @__PURE__ */ new Date()
          }
        });
        return ctx.json({
          client_id: clientId,
          ...client.type !== "public" ? {
            client_secret: clientSecret,
            client_secret_expires_at: 0
          } : {},
          client_id_issued_at: Math.floor(Date.now() / 1e3),
          client_secret_expires_at: 0,
          redirect_uris: body.redirect_uris,
          token_endpoint_auth_method: body.token_endpoint_auth_method || "client_secret_basic",
          grant_types: body.grant_types || ["authorization_code"],
          response_types: body.response_types || ["code"],
          client_name: body.client_name,
          client_uri: body.client_uri,
          logo_uri: body.logo_uri,
          scope: body.scope,
          contacts: body.contacts,
          tos_uri: body.tos_uri,
          policy_uri: body.policy_uri,
          jwks_uri: body.jwks_uri,
          jwks: body.jwks,
          software_id: body.software_id,
          software_version: body.software_version,
          software_statement: body.software_statement,
          metadata: body.metadata
        }, {
          status: 201,
          headers: {
            "Cache-Control": "no-store",
            Pragma: "no-cache"
          }
        });
      }),
      getOAuthClient: createAuthEndpoint("/oauth2/client/:id", {
        method: "GET",
        use: [sessionMiddleware],
        metadata: { openapi: {
          description: "Get OAuth2 client details",
          responses: { "200": {
            description: "OAuth2 client retrieved successfully",
            content: { "application/json": { schema: {
              type: "object",
              properties: {
                clientId: {
                  type: "string",
                  description: "Unique identifier for the client"
                },
                name: {
                  type: "string",
                  description: "Name of the OAuth2 application"
                },
                icon: {
                  type: "string",
                  nullable: true,
                  description: "Icon URL for the application"
                }
              },
              required: ["clientId", "name"]
            } } }
          } }
        } }
      }, async (ctx) => {
        const client = await getClient(ctx.params.id, trustedClients);
        if (!client) throw new APIError("NOT_FOUND", {
          error_description: "client not found",
          error: "not_found"
        });
        return ctx.json({
          clientId: client.clientId,
          name: client.name,
          icon: client.icon || null
        });
      }),
      endSession: createAuthEndpoint("/oauth2/endsession", {
        method: ["GET", "POST"],
        query: object({
          id_token_hint: string().optional(),
          logout_hint: string().optional(),
          client_id: string().optional(),
          post_logout_redirect_uri: string().optional(),
          state: string().optional(),
          ui_locales: string().optional()
        }).optional(),
        metadata: {
          ...HIDE_METADATA,
          openapi: {
            description: "RP-Initiated Logout endpoint. Logs out the end-user and optionally redirects to a post-logout URI.",
            parameters: [
              {
                name: "id_token_hint",
                in: "query",
                description: "Previously issued ID Token passed as a hint about the End-User's current authenticated session",
                required: false,
                schema: { type: "string" }
              },
              {
                name: "logout_hint",
                in: "query",
                description: "Hint to the Authorization Server about the End-User that is logging out",
                required: false,
                schema: { type: "string" }
              },
              {
                name: "client_id",
                in: "query",
                description: "OAuth 2.0 Client Identifier. Required if post_logout_redirect_uri is used without id_token_hint",
                required: false,
                schema: { type: "string" }
              },
              {
                name: "post_logout_redirect_uri",
                in: "query",
                description: "URL to which the RP is requesting that the End-User's User Agent be redirected after a logout has been performed",
                required: false,
                schema: {
                  type: "string",
                  format: "uri"
                }
              },
              {
                name: "state",
                in: "query",
                description: "Opaque value used by the RP to maintain state between the logout request and the callback",
                required: false,
                schema: { type: "string" }
              },
              {
                name: "ui_locales",
                in: "query",
                description: "End-User's preferred languages and scripts for the user interface",
                required: false,
                schema: { type: "string" }
              }
            ],
            responses: {
              "302": { description: "Redirect to post_logout_redirect_uri or logout confirmation page" },
              "200": { description: "Logout completed successfully" }
            }
          }
        }
      }, async (ctx) => {
        const { id_token_hint, client_id, post_logout_redirect_uri, state } = ctx.query || {};
        let validatedClientId = null;
        let validatedUserId = null;
        if (id_token_hint) try {
          const jwtPlugin = getJwtPlugin(ctx);
          if (jwtPlugin && jwtPlugin.options && options?.useJWTPlugin) {
            const verified = await verifyJWT(id_token_hint, jwtPlugin.options);
            if (verified) {
              validatedUserId = verified.sub;
              validatedClientId = verified.aud ? typeof verified.aud === "string" ? verified.aud : verified.aud[0] : null;
            }
          } else if (client_id) {
            const client = await getClient(client_id, trustedClients);
            if (client && client.clientSecret) try {
              const { payload } = await jwtVerify(id_token_hint, new TextEncoder().encode(client.clientSecret));
              validatedUserId = payload.sub;
              validatedClientId = payload.aud;
            } catch {
            }
          }
        } catch {
          ctx.context.logger.debug("Invalid id_token_hint provided to end_session endpoint");
        }
        if (client_id) {
          if (!await getClient(client_id, trustedClients)) throw new APIError("BAD_REQUEST", {
            error: "invalid_client",
            error_description: "Invalid client_id"
          });
          if (validatedClientId && validatedClientId !== client_id) throw new APIError("BAD_REQUEST", {
            error: "invalid_request",
            error_description: "client_id does not match the ID Token's audience"
          });
          validatedClientId = client_id;
        }
        if (post_logout_redirect_uri) {
          if (!validatedClientId) throw new APIError("BAD_REQUEST", {
            error: "invalid_request",
            error_description: "client_id is required when using post_logout_redirect_uri without a valid id_token_hint"
          });
          const client = await getClient(validatedClientId, trustedClients);
          if (!client) throw new APIError("BAD_REQUEST", {
            error: "invalid_client",
            error_description: "Invalid client"
          });
          if (!client.redirectUrls.some((registeredUri) => post_logout_redirect_uri === registeredUri)) throw new APIError("BAD_REQUEST", {
            error: "invalid_request",
            error_description: "post_logout_redirect_uri is not registered for this client"
          });
        }
        const session = await getSessionFromCtx(ctx);
        if (validatedUserId || session) {
          const userId = validatedUserId || session?.user.id;
          if (userId) await ctx.context.adapter.deleteMany({
            model: modelName.oauthAccessToken,
            where: [{
              field: "userId",
              value: userId
            }]
          });
        }
        if (session) {
          await ctx.context.internalAdapter.deleteSession(session.session.token);
          ctx.setSignedCookie(ctx.context.authCookies.sessionToken.name, "", ctx.context.secret, { maxAge: 0 });
        }
        if (post_logout_redirect_uri) try {
          const redirectUrl = new URL(post_logout_redirect_uri);
          if (state) redirectUrl.searchParams.set("state", state);
          return ctx.redirect(redirectUrl.toString());
        } catch {
          throw new APIError("BAD_REQUEST", {
            error: "invalid_request",
            error_description: "Invalid post_logout_redirect_uri format"
          });
        }
        return ctx.json({
          success: true,
          message: "Logout successful"
        });
      })
    },
    schema: mergeSchema(schema5, options?.schema),
    get options() {
      return opts;
    }
  };
};

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/mcp/authorize.mjs
function redirectErrorURL(url, error, description) {
  return `${url.includes("?") ? "&" : "?"}error=${error}&error_description=${description}`;
}
async function authorizeMCPOAuth(ctx, options) {
  ctx.setHeader("Access-Control-Allow-Origin", "*");
  ctx.setHeader("Access-Control-Allow-Methods", "POST, OPTIONS");
  ctx.setHeader("Access-Control-Allow-Headers", "Content-Type, Authorization");
  ctx.setHeader("Access-Control-Max-Age", "86400");
  const opts = {
    codeExpiresIn: 600,
    defaultScope: "openid",
    ...options,
    scopes: [
      "openid",
      "profile",
      "email",
      "offline_access",
      ...options?.scopes || []
    ]
  };
  if (!ctx.request) throw new APIError("UNAUTHORIZED", {
    error_description: "request not found",
    error: "invalid_request"
  });
  const session = await getSessionFromCtx(ctx);
  if (!session) {
    await ctx.setSignedCookie("oidc_login_prompt", JSON.stringify(ctx.query), ctx.context.secret, {
      maxAge: 600,
      path: "/",
      sameSite: "lax"
    });
    const queryFromURL = ctx.request.url?.split("?")[1];
    throw ctx.redirect(`${options.loginPage}?${queryFromURL}`);
  }
  const query = ctx.query;
  if (!query.client_id) throw ctx.redirect(`${ctx.context.baseURL}/error?error=invalid_client`);
  if (!query.response_type) throw ctx.redirect(redirectErrorURL(`${ctx.context.baseURL}/error`, "invalid_request", "response_type is required"));
  const client = await ctx.context.adapter.findOne({
    model: "oauthApplication",
    where: [{
      field: "clientId",
      value: ctx.query.client_id
    }]
  }).then((res) => {
    if (!res) return null;
    return {
      ...res,
      redirectUrls: res.redirectUrls.split(","),
      metadata: res.metadata ? JSON.parse(res.metadata) : {}
    };
  });
  if (!client) throw ctx.redirect(`${ctx.context.baseURL}/error?error=invalid_client`);
  const redirectURI = client.redirectUrls.find((url) => url === ctx.query.redirect_uri);
  if (!redirectURI || !query.redirect_uri)
    throw new APIError("BAD_REQUEST", { message: "Invalid redirect URI" });
  if (client.disabled) throw ctx.redirect(`${ctx.context.baseURL}/error?error=client_disabled`);
  if (query.response_type !== "code") throw ctx.redirect(`${ctx.context.baseURL}/error?error=unsupported_response_type`);
  const requestScope = query.scope?.split(" ").filter((s) => s) || opts.defaultScope.split(" ");
  const invalidScopes = requestScope.filter((scope) => {
    return !opts.scopes.includes(scope);
  });
  if (invalidScopes.length) throw ctx.redirect(redirectErrorURL(query.redirect_uri, "invalid_scope", `The following scopes are invalid: ${invalidScopes.join(", ")}`));
  if ((!query.code_challenge || !query.code_challenge_method) && options.requirePKCE) throw ctx.redirect(redirectErrorURL(query.redirect_uri, "invalid_request", "pkce is required"));
  if (!query.code_challenge_method) query.code_challenge_method = "plain";
  if (!["s256", options.allowPlainCodeChallengeMethod ? "plain" : "s256"].includes(query.code_challenge_method?.toLowerCase() || "")) throw ctx.redirect(redirectErrorURL(query.redirect_uri, "invalid_request", "invalid code_challenge method"));
  const code = generateRandomString(32, "a-z", "A-Z", "0-9");
  const codeExpiresInMs = opts.codeExpiresIn * 1e3;
  const expiresAt = new Date(Date.now() + codeExpiresInMs);
  try {
    await ctx.context.internalAdapter.createVerificationValue({
      value: JSON.stringify({
        clientId: client.clientId,
        redirectURI: query.redirect_uri,
        scope: requestScope,
        userId: session.user.id,
        authTime: new Date(session.session.createdAt).getTime(),
        requireConsent: query.prompt === "consent",
        state: query.prompt === "consent" ? query.state : null,
        codeChallenge: query.code_challenge,
        codeChallengeMethod: query.code_challenge_method,
        nonce: query.nonce
      }),
      identifier: code,
      expiresAt
    });
  } catch {
    throw ctx.redirect(redirectErrorURL(query.redirect_uri, "server_error", "An error occurred while processing the request"));
  }
  if (query.prompt !== "consent") {
    const redirectURIWithCode$1 = new URL(redirectURI);
    redirectURIWithCode$1.searchParams.set("code", code);
    if (ctx.query.state) redirectURIWithCode$1.searchParams.set("state", ctx.query.state);
    throw ctx.redirect(redirectURIWithCode$1.toString());
  }
  if (options?.consentPage) {
    await ctx.setSignedCookie("oidc_consent_prompt", code, ctx.context.secret, {
      maxAge: 600,
      path: "/",
      sameSite: "lax"
    });
    const urlParams = new URLSearchParams();
    urlParams.set("consent_code", code);
    urlParams.set("client_id", client.clientId);
    urlParams.set("scope", requestScope.join(" "));
    const consentURI = `${options.consentPage}?${urlParams.toString()}`;
    throw ctx.redirect(consentURI);
  }
  const redirectURIWithCode = new URL(redirectURI);
  redirectURIWithCode.searchParams.set("code", code);
  if (ctx.query.state) redirectURIWithCode.searchParams.set("state", ctx.query.state);
  throw ctx.redirect(redirectURIWithCode.toString());
}

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/mcp/index.mjs
var getMCPProviderMetadata = (ctx, options) => {
  const issuer = ctx.context.options.baseURL;
  const baseURL = ctx.context.baseURL;
  if (!issuer || !baseURL) throw new APIError("INTERNAL_SERVER_ERROR", {
    error: "invalid_issuer",
    error_description: "issuer or baseURL is not set. If you're the app developer, please make sure to set the `baseURL` in your auth config."
  });
  return {
    issuer,
    authorization_endpoint: `${baseURL}/mcp/authorize`,
    token_endpoint: `${baseURL}/mcp/token`,
    userinfo_endpoint: `${baseURL}/mcp/userinfo`,
    jwks_uri: `${baseURL}/mcp/jwks`,
    registration_endpoint: `${baseURL}/mcp/register`,
    scopes_supported: [
      "openid",
      "profile",
      "email",
      "offline_access"
    ],
    response_types_supported: ["code"],
    response_modes_supported: ["query"],
    grant_types_supported: ["authorization_code", "refresh_token"],
    acr_values_supported: ["urn:mace:incommon:iap:silver", "urn:mace:incommon:iap:bronze"],
    subject_types_supported: ["public"],
    id_token_signing_alg_values_supported: ["RS256", "none"],
    token_endpoint_auth_methods_supported: [
      "client_secret_basic",
      "client_secret_post",
      "none"
    ],
    code_challenge_methods_supported: ["S256"],
    claims_supported: [
      "sub",
      "iss",
      "aud",
      "exp",
      "nbf",
      "iat",
      "jti",
      "email",
      "email_verified",
      "name"
    ],
    ...options?.metadata
  };
};
var getMCPProtectedResourceMetadata = (ctx, options) => {
  const baseURL = ctx.context.baseURL;
  const origin = new URL(baseURL).origin;
  return {
    resource: options?.resource ?? origin,
    authorization_servers: [origin],
    jwks_uri: options?.oidcConfig?.metadata?.jwks_uri ?? `${baseURL}/mcp/jwks`,
    scopes_supported: options?.oidcConfig?.metadata?.scopes_supported ?? [
      "openid",
      "profile",
      "email",
      "offline_access"
    ],
    bearer_methods_supported: ["header"],
    resource_signing_alg_values_supported: ["RS256", "none"]
  };
};
var registerMcpClientBodySchema = object({
  redirect_uris: array(string()),
  token_endpoint_auth_method: _enum([
    "none",
    "client_secret_basic",
    "client_secret_post"
  ]).default("client_secret_basic").optional(),
  grant_types: array(_enum([
    "authorization_code",
    "implicit",
    "password",
    "client_credentials",
    "refresh_token",
    "urn:ietf:params:oauth:grant-type:jwt-bearer",
    "urn:ietf:params:oauth:grant-type:saml2-bearer"
  ])).default(["authorization_code"]).optional(),
  response_types: array(_enum(["code", "token"])).default(["code"]).optional(),
  client_name: string().optional(),
  client_uri: string().optional(),
  logo_uri: string().optional(),
  scope: string().optional(),
  contacts: array(string()).optional(),
  tos_uri: string().optional(),
  policy_uri: string().optional(),
  jwks_uri: string().optional(),
  jwks: record(string(), any()).optional(),
  metadata: record(any(), any()).optional(),
  software_id: string().optional(),
  software_version: string().optional(),
  software_statement: string().optional()
});
var mcpOAuthTokenBodySchema = record(any(), any());
var mcp = (options) => {
  const opts = {
    codeExpiresIn: 600,
    defaultScope: "openid",
    accessTokenExpiresIn: 3600,
    refreshTokenExpiresIn: 604800,
    allowPlainCodeChallengeMethod: true,
    ...options.oidcConfig,
    loginPage: options.loginPage,
    scopes: [
      "openid",
      "profile",
      "email",
      "offline_access",
      ...options.oidcConfig?.scopes || []
    ]
  };
  const modelName = {
    oauthClient: "oauthApplication",
    oauthAccessToken: "oauthAccessToken",
    oauthConsent: "oauthConsent"
  };
  const provider = oidcProvider(opts);
  return {
    id: "mcp",
    hooks: { after: [{
      matcher() {
        return true;
      },
      handler: createAuthMiddleware(async (ctx) => {
        const cookie = await ctx.getSignedCookie("oidc_login_prompt", ctx.context.secret);
        const cookieName = ctx.context.authCookies.sessionToken.name;
        const parsedSetCookieHeader = parseSetCookieHeader(ctx.context.responseHeaders?.get("set-cookie") || "");
        const hasSessionToken = parsedSetCookieHeader.has(cookieName);
        if (!cookie || !hasSessionToken) return;
        ctx.setCookie("oidc_login_prompt", "", { maxAge: 0 });
        const sessionToken = parsedSetCookieHeader.get(cookieName)?.value?.split(".")[0];
        if (!sessionToken) return;
        const session = await ctx.context.internalAdapter.findSession(sessionToken) || ctx.context.newSession;
        if (!session) return;
        const promptSet = parsePrompt(String(ctx.query?.prompt));
        if (promptSet.has("login")) {
          const newPromptSet = new Set(promptSet);
          newPromptSet.delete("login");
          ctx.query = {
            ...ctx.query,
            prompt: Array.from(newPromptSet).join(" ")
          };
        }
        ctx.context.session = session;
        return await authorizeMCPOAuth(ctx, opts);
      })
    }] },
    endpoints: {
      oAuthConsent: provider.endpoints.oAuthConsent,
      getMcpOAuthConfig: createAuthEndpoint("/.well-known/oauth-authorization-server", {
        method: "GET",
        metadata: HIDE_METADATA
      }, async (c) => {
        try {
          const metadata = getMCPProviderMetadata(c, options);
          return c.json(metadata);
        } catch (e) {
          console.log(e);
          return c.json(null);
        }
      }),
      getMCPProtectedResource: createAuthEndpoint("/.well-known/oauth-protected-resource", {
        method: "GET",
        metadata: HIDE_METADATA
      }, async (c) => {
        const metadata = getMCPProtectedResourceMetadata(c, options);
        return c.json(metadata);
      }),
      mcpOAuthAuthorize: createAuthEndpoint("/mcp/authorize", {
        method: "GET",
        query: record(string(), any()),
        metadata: { openapi: {
          description: "Authorize an OAuth2 request using MCP",
          responses: { "200": {
            description: "Authorization response generated successfully",
            content: { "application/json": { schema: {
              type: "object",
              additionalProperties: true,
              description: "Authorization response, contents depend on the authorize function implementation"
            } } }
          } }
        } }
      }, async (ctx) => {
        return authorizeMCPOAuth(ctx, opts);
      }),
      mcpOAuthToken: createAuthEndpoint("/mcp/token", {
        method: "POST",
        body: mcpOAuthTokenBodySchema,
        metadata: {
          ...HIDE_METADATA,
          allowedMediaTypes: ["application/x-www-form-urlencoded", "application/json"]
        }
      }, async (ctx) => {
        ctx.setHeader("Access-Control-Allow-Origin", "*");
        ctx.setHeader("Access-Control-Allow-Methods", "POST, OPTIONS");
        ctx.setHeader("Access-Control-Allow-Headers", "Content-Type, Authorization");
        ctx.setHeader("Access-Control-Max-Age", "86400");
        let { body } = ctx;
        if (!body) throw ctx.error("BAD_REQUEST", {
          error_description: "request body not found",
          error: "invalid_request"
        });
        if (body instanceof FormData) body = Object.fromEntries(body.entries());
        if (!(body instanceof Object)) throw new APIError("BAD_REQUEST", {
          error_description: "request body is not an object",
          error: "invalid_request"
        });
        let { client_id, client_secret } = body;
        const authorization = ctx.request?.headers.get("authorization") || null;
        if (authorization && !client_id && !client_secret && authorization.startsWith("Basic ")) try {
          const encoded = authorization.replace("Basic ", "");
          const decoded = new TextDecoder().decode(base64.decode(encoded));
          if (!decoded.includes(":")) throw new APIError("UNAUTHORIZED", {
            error_description: "invalid authorization header format",
            error: "invalid_client"
          });
          const [id, secret] = decoded.split(":");
          if (!id || !secret) throw new APIError("UNAUTHORIZED", {
            error_description: "invalid authorization header format",
            error: "invalid_client"
          });
          client_id = id;
          client_secret = secret;
        } catch {
          throw new APIError("UNAUTHORIZED", {
            error_description: "invalid authorization header format",
            error: "invalid_client"
          });
        }
        const { grant_type, code, redirect_uri, refresh_token, code_verifier } = body;
        if (grant_type === "refresh_token") {
          if (!refresh_token) throw new APIError("BAD_REQUEST", {
            error_description: "refresh_token is required",
            error: "invalid_request"
          });
          const token = await ctx.context.adapter.findOne({
            model: "oauthAccessToken",
            where: [{
              field: "refreshToken",
              value: refresh_token.toString()
            }]
          });
          if (!token) throw new APIError("UNAUTHORIZED", {
            error_description: "invalid refresh token",
            error: "invalid_grant"
          });
          if (token.clientId !== client_id?.toString()) throw new APIError("UNAUTHORIZED", {
            error_description: "invalid client_id",
            error: "invalid_client"
          });
          if (token.refreshTokenExpiresAt < /* @__PURE__ */ new Date()) throw new APIError("UNAUTHORIZED", {
            error_description: "refresh token expired",
            error: "invalid_grant"
          });
          const accessToken$1 = generateRandomString(32, "a-z", "A-Z");
          const newRefreshToken = generateRandomString(32, "a-z", "A-Z");
          const accessTokenExpiresAt$1 = new Date(Date.now() + opts.accessTokenExpiresIn * 1e3);
          const refreshTokenExpiresAt$1 = new Date(Date.now() + opts.refreshTokenExpiresIn * 1e3);
          await ctx.context.adapter.create({
            model: modelName.oauthAccessToken,
            data: {
              accessToken: accessToken$1,
              refreshToken: newRefreshToken,
              accessTokenExpiresAt: accessTokenExpiresAt$1,
              refreshTokenExpiresAt: refreshTokenExpiresAt$1,
              clientId: client_id.toString(),
              userId: token.userId,
              scopes: token.scopes,
              createdAt: /* @__PURE__ */ new Date(),
              updatedAt: /* @__PURE__ */ new Date()
            }
          });
          return ctx.json({
            access_token: accessToken$1,
            token_type: "bearer",
            expires_in: opts.accessTokenExpiresIn,
            refresh_token: newRefreshToken,
            scope: token.scopes
          });
        }
        if (!code) throw new APIError("BAD_REQUEST", {
          error_description: "code is required",
          error: "invalid_request"
        });
        if (opts.requirePKCE && !code_verifier) throw new APIError("BAD_REQUEST", {
          error_description: "code verifier is missing",
          error: "invalid_request"
        });
        const verificationValue = await ctx.context.internalAdapter.findVerificationValue(code.toString());
        if (!verificationValue) throw new APIError("UNAUTHORIZED", {
          error_description: "invalid code",
          error: "invalid_grant"
        });
        if (verificationValue.expiresAt < /* @__PURE__ */ new Date()) throw new APIError("UNAUTHORIZED", {
          error_description: "code expired",
          error: "invalid_grant"
        });
        await ctx.context.internalAdapter.deleteVerificationValue(verificationValue.id);
        if (!client_id) throw new APIError("UNAUTHORIZED", {
          error_description: "client_id is required",
          error: "invalid_client"
        });
        if (!grant_type) throw new APIError("BAD_REQUEST", {
          error_description: "grant_type is required",
          error: "invalid_request"
        });
        if (grant_type !== "authorization_code") throw new APIError("BAD_REQUEST", {
          error_description: "grant_type must be 'authorization_code'",
          error: "unsupported_grant_type"
        });
        if (!redirect_uri) throw new APIError("BAD_REQUEST", {
          error_description: "redirect_uri is required",
          error: "invalid_request"
        });
        const client = await ctx.context.adapter.findOne({
          model: modelName.oauthClient,
          where: [{
            field: "clientId",
            value: client_id.toString()
          }]
        }).then((res) => {
          if (!res) return null;
          return {
            ...res,
            redirectUrls: res.redirectUrls.split(","),
            metadata: res.metadata ? JSON.parse(res.metadata) : {}
          };
        });
        if (!client) throw new APIError("UNAUTHORIZED", {
          error_description: "invalid client_id",
          error: "invalid_client"
        });
        if (client.disabled) throw new APIError("UNAUTHORIZED", {
          error_description: "client is disabled",
          error: "invalid_client"
        });
        if (client.type === "public") {
          if (!code_verifier) throw new APIError("BAD_REQUEST", {
            error_description: "code verifier is required for public clients",
            error: "invalid_request"
          });
        } else {
          if (!client_secret) throw new APIError("UNAUTHORIZED", {
            error_description: "client_secret is required for confidential clients",
            error: "invalid_client"
          });
          if (!(client.clientSecret === client_secret.toString())) throw new APIError("UNAUTHORIZED", {
            error_description: "invalid client_secret",
            error: "invalid_client"
          });
        }
        const value = JSON.parse(verificationValue.value);
        if (value.clientId !== client_id.toString()) throw new APIError("UNAUTHORIZED", {
          error_description: "invalid client_id",
          error: "invalid_client"
        });
        if (value.redirectURI !== redirect_uri.toString()) throw new APIError("UNAUTHORIZED", {
          error_description: "invalid redirect_uri",
          error: "invalid_client"
        });
        if (value.codeChallenge && !code_verifier) throw new APIError("BAD_REQUEST", {
          error_description: "code verifier is missing",
          error: "invalid_request"
        });
        if ((value.codeChallengeMethod === "plain" ? code_verifier : await createHash("SHA-256", "base64urlnopad").digest(code_verifier)) !== value.codeChallenge) throw new APIError("UNAUTHORIZED", {
          error_description: "code verification failed",
          error: "invalid_request"
        });
        const requestedScopes = value.scope;
        await ctx.context.internalAdapter.deleteVerificationValue(verificationValue.id);
        const accessToken = generateRandomString(32, "a-z", "A-Z");
        const refreshToken = generateRandomString(32, "A-Z", "a-z");
        const accessTokenExpiresAt = new Date(Date.now() + opts.accessTokenExpiresIn * 1e3);
        const refreshTokenExpiresAt = new Date(Date.now() + opts.refreshTokenExpiresIn * 1e3);
        await ctx.context.adapter.create({
          model: modelName.oauthAccessToken,
          data: {
            accessToken,
            refreshToken,
            accessTokenExpiresAt,
            refreshTokenExpiresAt,
            clientId: client_id.toString(),
            userId: value.userId,
            scopes: requestedScopes.join(" "),
            createdAt: /* @__PURE__ */ new Date(),
            updatedAt: /* @__PURE__ */ new Date()
          }
        });
        const user = await ctx.context.internalAdapter.findUserById(value.userId);
        if (!user) throw new APIError("UNAUTHORIZED", {
          error_description: "user not found",
          error: "invalid_grant"
        });
        let secretKey = {
          alg: "HS256",
          key: await getWebcryptoSubtle().generateKey({
            name: "HMAC",
            hash: "SHA-256"
          }, true, ["sign", "verify"])
        };
        const profile = {
          given_name: user.name.split(" ")[0],
          family_name: user.name.split(" ")[1],
          name: user.name,
          profile: user.image,
          updated_at: Math.floor(new Date(user.updatedAt).getTime() / 1e3)
        };
        const email2 = {
          email: user.email,
          email_verified: user.emailVerified
        };
        const userClaims = {
          ...requestedScopes.includes("profile") ? profile : {},
          ...requestedScopes.includes("email") ? email2 : {}
        };
        const additionalUserClaims = opts.getAdditionalUserInfoClaim ? await opts.getAdditionalUserInfoClaim(user, requestedScopes, client) : {};
        const idToken = await new SignJWT({
          sub: user.id,
          aud: client_id.toString(),
          iat: Date.now(),
          auth_time: ctx.context.session ? new Date(ctx.context.session.session.createdAt).getTime() : void 0,
          nonce: value.nonce,
          acr: "urn:mace:incommon:iap:silver",
          ...userClaims,
          ...additionalUserClaims
        }).setProtectedHeader({ alg: secretKey.alg }).setIssuedAt().setExpirationTime(Math.floor(Date.now() / 1e3) + opts.accessTokenExpiresIn).sign(secretKey.key);
        return ctx.json({
          access_token: accessToken,
          token_type: "Bearer",
          expires_in: opts.accessTokenExpiresIn,
          refresh_token: requestedScopes.includes("offline_access") ? refreshToken : void 0,
          scope: requestedScopes.join(" "),
          id_token: requestedScopes.includes("openid") ? idToken : void 0
        }, { headers: {
          "Cache-Control": "no-store",
          Pragma: "no-cache"
        } });
      }),
      registerMcpClient: createAuthEndpoint("/mcp/register", {
        method: "POST",
        body: registerMcpClientBodySchema,
        metadata: { openapi: {
          description: "Register an OAuth2 application",
          responses: { "200": {
            description: "OAuth2 application registered successfully",
            content: { "application/json": { schema: {
              type: "object",
              properties: {
                name: {
                  type: "string",
                  description: "Name of the OAuth2 application"
                },
                icon: {
                  type: "string",
                  nullable: true,
                  description: "Icon URL for the application"
                },
                metadata: {
                  type: "object",
                  additionalProperties: true,
                  nullable: true,
                  description: "Additional metadata for the application"
                },
                clientId: {
                  type: "string",
                  description: "Unique identifier for the client"
                },
                clientSecret: {
                  type: "string",
                  description: "Secret key for the client. Not included for public clients."
                },
                redirectUrls: {
                  type: "array",
                  items: {
                    type: "string",
                    format: "uri"
                  },
                  description: "List of allowed redirect URLs"
                },
                type: {
                  type: "string",
                  description: "Type of the client",
                  enum: ["web", "public"]
                },
                authenticationScheme: {
                  type: "string",
                  description: "Authentication scheme used by the client",
                  enum: ["client_secret", "none"]
                },
                disabled: {
                  type: "boolean",
                  description: "Whether the client is disabled",
                  enum: [false]
                },
                userId: {
                  type: "string",
                  nullable: true,
                  description: "ID of the user who registered the client, null if registered anonymously"
                },
                createdAt: {
                  type: "string",
                  format: "date-time",
                  description: "Creation timestamp"
                },
                updatedAt: {
                  type: "string",
                  format: "date-time",
                  description: "Last update timestamp"
                }
              },
              required: [
                "name",
                "clientId",
                "redirectUrls",
                "type",
                "authenticationScheme",
                "disabled",
                "createdAt",
                "updatedAt"
              ]
            } } }
          } }
        } }
      }, async (ctx) => {
        const body = ctx.body;
        const session = await getSessionFromCtx(ctx);
        ctx.setHeader("Access-Control-Allow-Origin", "*");
        ctx.setHeader("Access-Control-Allow-Methods", "POST, OPTIONS");
        ctx.setHeader("Access-Control-Allow-Headers", "Content-Type, Authorization");
        ctx.setHeader("Access-Control-Max-Age", "86400");
        ctx.headers?.set("Access-Control-Max-Age", "86400");
        if ((!body.grant_types || body.grant_types.includes("authorization_code") || body.grant_types.includes("implicit")) && (!body.redirect_uris || body.redirect_uris.length === 0)) throw new APIError("BAD_REQUEST", {
          error: "invalid_redirect_uri",
          error_description: "Redirect URIs are required for authorization_code and implicit grant types"
        });
        if (body.grant_types && body.response_types) {
          if (body.grant_types.includes("authorization_code") && !body.response_types.includes("code")) throw new APIError("BAD_REQUEST", {
            error: "invalid_client_metadata",
            error_description: "When 'authorization_code' grant type is used, 'code' response type must be included"
          });
          if (body.grant_types.includes("implicit") && !body.response_types.includes("token")) throw new APIError("BAD_REQUEST", {
            error: "invalid_client_metadata",
            error_description: "When 'implicit' grant type is used, 'token' response type must be included"
          });
        }
        const clientId = opts.generateClientId?.() || generateRandomString(32, "a-z", "A-Z");
        const clientSecret = opts.generateClientSecret?.() || generateRandomString(32, "a-z", "A-Z");
        const clientType = body.token_endpoint_auth_method === "none" ? "public" : "web";
        const finalClientSecret = clientType === "public" ? "" : clientSecret;
        await ctx.context.adapter.create({
          model: modelName.oauthClient,
          data: {
            name: body.client_name,
            icon: body.logo_uri,
            metadata: body.metadata ? JSON.stringify(body.metadata) : null,
            clientId,
            clientSecret: finalClientSecret,
            redirectUrls: body.redirect_uris.join(","),
            type: clientType,
            authenticationScheme: body.token_endpoint_auth_method || "client_secret_basic",
            disabled: false,
            userId: session?.session.userId,
            createdAt: /* @__PURE__ */ new Date(),
            updatedAt: /* @__PURE__ */ new Date()
          }
        });
        const responseData = {
          client_id: clientId,
          client_id_issued_at: Math.floor(Date.now() / 1e3),
          redirect_uris: body.redirect_uris,
          token_endpoint_auth_method: body.token_endpoint_auth_method || "client_secret_basic",
          grant_types: body.grant_types || ["authorization_code"],
          response_types: body.response_types || ["code"],
          client_name: body.client_name,
          client_uri: body.client_uri,
          logo_uri: body.logo_uri,
          scope: body.scope,
          contacts: body.contacts,
          tos_uri: body.tos_uri,
          policy_uri: body.policy_uri,
          jwks_uri: body.jwks_uri,
          jwks: body.jwks,
          software_id: body.software_id,
          software_version: body.software_version,
          software_statement: body.software_statement,
          metadata: body.metadata,
          ...clientType !== "public" ? {
            client_secret: finalClientSecret,
            client_secret_expires_at: 0
          } : {}
        };
        return new Response(JSON.stringify(responseData), {
          status: 201,
          headers: {
            "Content-Type": "application/json",
            "Cache-Control": "no-store",
            Pragma: "no-cache"
          }
        });
      }),
      getMcpSession: createAuthEndpoint("/mcp/get-session", {
        method: "GET",
        requireHeaders: true
      }, async (c) => {
        const accessToken = c.headers?.get("Authorization")?.replace("Bearer ", "");
        if (!accessToken) {
          c.headers?.set("WWW-Authenticate", "Bearer");
          return c.json(null);
        }
        const accessTokenData = await c.context.adapter.findOne({
          model: modelName.oauthAccessToken,
          where: [{
            field: "accessToken",
            value: accessToken
          }]
        });
        if (!accessTokenData) return c.json(null);
        return c.json(accessTokenData);
      })
    },
    schema: schema5,
    options
  };
};
var withMcpAuth = (auth, handler) => {
  return async (req) => {
    const baseURL = getBaseURL(auth.options.baseURL, auth.options.basePath);
    if (!baseURL && !isProduction) logger.warn("Unable to get the baseURL, please check your config!");
    const session = await auth.api.getMcpSession({ headers: req.headers });
    const wwwAuthenticateValue = `Bearer resource_metadata="${baseURL}/.well-known/oauth-protected-resource"`;
    if (!session) return Response.json({
      jsonrpc: "2.0",
      error: {
        code: -32e3,
        message: "Unauthorized: Authentication required",
        "www-authenticate": wwwAuthenticateValue
      },
      id: null
    }, {
      status: 401,
      headers: {
        "WWW-Authenticate": wwwAuthenticateValue,
        "Access-Control-Expose-Headers": "WWW-Authenticate"
      }
    });
    return handler(req, session);
  };
};
var oAuthDiscoveryMetadata = (auth) => {
  return async (request) => {
    const res = await auth.api.getMcpOAuthConfig();
    return new Response(JSON.stringify(res), {
      status: 200,
      headers: {
        "Content-Type": "application/json",
        "Access-Control-Allow-Origin": "*",
        "Access-Control-Allow-Methods": "POST, OPTIONS",
        "Access-Control-Allow-Headers": "Content-Type, Authorization",
        "Access-Control-Max-Age": "86400"
      }
    });
  };
};
var oAuthProtectedResourceMetadata = (auth) => {
  return async (request) => {
    const res = await auth.api.getMCPProtectedResource();
    return new Response(JSON.stringify(res), {
      status: 200,
      headers: {
        "Content-Type": "application/json",
        "Access-Control-Allow-Origin": "*",
        "Access-Control-Allow-Methods": "POST, OPTIONS",
        "Access-Control-Allow-Headers": "Content-Type, Authorization",
        "Access-Control-Max-Age": "86400"
      }
    });
  };
};

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/multi-session/index.mjs
var ERROR_CODES4 = defineErrorCodes({ INVALID_SESSION_TOKEN: "Invalid session token" });
var setActiveSessionBodySchema = object({ sessionToken: string().meta({ description: "The session token to set as active" }) });
var revokeDeviceSessionBodySchema = object({ sessionToken: string().meta({ description: "The session token to revoke" }) });
var multiSession = (options) => {
  const opts = {
    maximumSessions: 5,
    ...options
  };
  const isMultiSessionCookie = (key) => key.includes("_multi-");
  return {
    id: "multi-session",
    endpoints: {
      listDeviceSessions: createAuthEndpoint("/multi-session/list-device-sessions", {
        method: "GET",
        requireHeaders: true
      }, async (ctx) => {
        const cookieHeader = ctx.headers?.get("cookie");
        if (!cookieHeader) return ctx.json([]);
        const cookies = Object.fromEntries(parseCookies(cookieHeader));
        const sessionTokens = (await Promise.all(Object.entries(cookies).filter(([key]) => isMultiSessionCookie(key)).map(async ([key]) => await ctx.getSignedCookie(key, ctx.context.secret)))).filter((v) => typeof v === "string");
        if (!sessionTokens.length) return ctx.json([]);
        const uniqueUserSessions = (await ctx.context.internalAdapter.findSessions(sessionTokens)).filter((session) => session && session.session.expiresAt > /* @__PURE__ */ new Date()).reduce((acc, session) => {
          if (!acc.find((s) => s.user.id === session.user.id)) acc.push(session);
          return acc;
        }, []);
        return ctx.json(uniqueUserSessions);
      }),
      setActiveSession: createAuthEndpoint("/multi-session/set-active", {
        method: "POST",
        body: setActiveSessionBodySchema,
        requireHeaders: true,
        use: [sessionMiddleware],
        metadata: { openapi: {
          description: "Set the active session",
          responses: { 200: {
            description: "Success",
            content: { "application/json": { schema: {
              type: "object",
              properties: { session: { $ref: "#/components/schemas/Session" } }
            } } }
          } }
        } }
      }, async (ctx) => {
        const sessionToken = ctx.body.sessionToken;
        const multiSessionCookieName = `${ctx.context.authCookies.sessionToken.name}_multi-${sessionToken.toLowerCase()}`;
        if (!await ctx.getSignedCookie(multiSessionCookieName, ctx.context.secret)) throw new APIError("UNAUTHORIZED", { message: ERROR_CODES4.INVALID_SESSION_TOKEN });
        const session = await ctx.context.internalAdapter.findSession(sessionToken);
        if (!session || session.session.expiresAt < /* @__PURE__ */ new Date()) {
          ctx.setCookie(multiSessionCookieName, "", {
            ...ctx.context.authCookies.sessionToken.options,
            maxAge: 0
          });
          throw new APIError("UNAUTHORIZED", { message: ERROR_CODES4.INVALID_SESSION_TOKEN });
        }
        await setSessionCookie(ctx, session);
        return ctx.json(session);
      }),
      revokeDeviceSession: createAuthEndpoint("/multi-session/revoke", {
        method: "POST",
        body: revokeDeviceSessionBodySchema,
        requireHeaders: true,
        use: [sessionMiddleware],
        metadata: { openapi: {
          description: "Revoke a device session",
          responses: { 200: {
            description: "Success",
            content: { "application/json": { schema: {
              type: "object",
              properties: { status: { type: "boolean" } }
            } } }
          } }
        } }
      }, async (ctx) => {
        const sessionToken = ctx.body.sessionToken;
        const multiSessionCookieName = `${ctx.context.authCookies.sessionToken.name}_multi-${sessionToken.toLowerCase()}`;
        if (!await ctx.getSignedCookie(multiSessionCookieName, ctx.context.secret)) throw new APIError("UNAUTHORIZED", { message: ERROR_CODES4.INVALID_SESSION_TOKEN });
        await ctx.context.internalAdapter.deleteSession(sessionToken);
        ctx.setCookie(multiSessionCookieName, "", {
          ...ctx.context.authCookies.sessionToken.options,
          maxAge: 0
        });
        if (!(ctx.context.session?.session.token === sessionToken)) return ctx.json({ status: true });
        const cookieHeader = ctx.headers?.get("cookie");
        if (cookieHeader) {
          const cookies = Object.fromEntries(parseCookies(cookieHeader));
          const sessionTokens = (await Promise.all(Object.entries(cookies).filter(([key]) => isMultiSessionCookie(key)).map(async ([key]) => await ctx.getSignedCookie(key, ctx.context.secret)))).filter((v) => typeof v === "string");
          const internalAdapter = ctx.context.internalAdapter;
          if (sessionTokens.length > 0) {
            const validSessions = (await internalAdapter.findSessions(sessionTokens)).filter((session) => session && session.session.expiresAt > /* @__PURE__ */ new Date());
            if (validSessions.length > 0) {
              const nextSession = validSessions[0];
              await setSessionCookie(ctx, nextSession);
            } else deleteSessionCookie(ctx);
          } else deleteSessionCookie(ctx);
        } else deleteSessionCookie(ctx);
        return ctx.json({ status: true });
      })
    },
    hooks: { after: [{
      matcher: () => true,
      handler: createAuthMiddleware(async (ctx) => {
        const cookieString = ctx.context.responseHeaders?.get("set-cookie");
        if (!cookieString) return;
        const setCookies = parseSetCookieHeader(cookieString);
        const sessionCookieConfig = ctx.context.authCookies.sessionToken;
        const sessionToken = ctx.context.newSession?.session.token;
        if (!sessionToken) return;
        const cookies = parseCookies(ctx.headers?.get("cookie") || "");
        const cookieName = `${sessionCookieConfig.name}_multi-${sessionToken.toLowerCase()}`;
        if (setCookies.get(cookieName) || cookies.get(cookieName)) return;
        if (Object.keys(Object.fromEntries(cookies)).filter(isMultiSessionCookie).length + (cookieString.includes("session_token") ? 1 : 0) >= opts.maximumSessions) return;
        await ctx.setSignedCookie(cookieName, sessionToken, ctx.context.secret, sessionCookieConfig.options);
      })
    }, {
      matcher: (context) => context.path === "/sign-out",
      handler: createAuthMiddleware(async (ctx) => {
        const cookieHeader = ctx.headers?.get("cookie");
        if (!cookieHeader) return;
        const cookies = Object.fromEntries(parseCookies(cookieHeader));
        const multiSessionKeys = Object.keys(cookies).filter((key) => isMultiSessionCookie(key));
        const verifiedTokens = (await Promise.all(multiSessionKeys.map(async (key) => {
          const verifiedToken = await ctx.getSignedCookie(key, ctx.context.secret);
          if (verifiedToken) {
            ctx.setCookie(key.toLowerCase().replace("__secure-", "__Secure-"), "", {
              ...ctx.context.authCookies.sessionToken.options,
              maxAge: 0
            });
            return verifiedToken;
          }
          return null;
        }))).filter((v) => typeof v === "string");
        if (verifiedTokens.length > 0) await ctx.context.internalAdapter.deleteSessions(verifiedTokens);
      })
    }] },
    options,
    $ERROR_CODES: ERROR_CODES4
  };
};

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/oauth-proxy/utils.mjs
function stripTrailingSlash(url) {
  if (!url) return "";
  return url.replace(/\/+$/, "");
}
function getVendorBaseURL() {
  const vercel = env.VERCEL_URL ? `https://${env.VERCEL_URL}` : void 0;
  const netlify = env.NETLIFY_URL;
  const render = env.RENDER_URL;
  const aws = env.AWS_LAMBDA_FUNCTION_NAME;
  const google = env.GOOGLE_CLOUD_FUNCTION_NAME;
  const azure = env.AZURE_FUNCTION_NAME;
  return vercel || netlify || render || aws || google || azure;
}
function resolveCurrentURL(ctx, opts) {
  return new URL(opts?.currentURL || ctx.request?.url || getVendorBaseURL() || ctx.context.baseURL);
}
function checkSkipProxy(ctx, opts) {
  if (ctx.request?.headers.get("x-skip-oauth-proxy")) return true;
  const productionURL = opts?.productionURL || env.BETTER_AUTH_URL;
  if (!productionURL) return false;
  const currentURL = ctx.request?.url || getVendorBaseURL();
  if (!currentURL) return false;
  return getOrigin(productionURL) === getOrigin(currentURL);
}

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/oauth-proxy/index.mjs
var oAuthProxyQuerySchema = object({
  callbackURL: string().meta({ description: "The URL to redirect to after the proxy" }),
  cookies: string().meta({ description: "The cookies to set after the proxy" })
});
var oAuthProxy = (opts) => {
  const maxAge = opts?.maxAge ?? 60;
  return {
    id: "oauth-proxy",
    options: opts,
    endpoints: { oAuthProxy: createAuthEndpoint("/oauth-proxy-callback", {
      method: "GET",
      operationId: "oauthProxyCallback",
      query: oAuthProxyQuerySchema,
      use: [originCheck((ctx) => ctx.query.callbackURL)],
      metadata: { openapi: {
        operationId: "oauthProxyCallback",
        description: "OAuth Proxy Callback",
        parameters: [{
          in: "query",
          name: "callbackURL",
          required: true,
          description: "The URL to redirect to after the proxy"
        }, {
          in: "query",
          name: "cookies",
          required: true,
          description: "The cookies to set after the proxy"
        }],
        responses: { 302: {
          description: "Redirect",
          headers: { Location: {
            description: "The URL to redirect to",
            schema: { type: "string" }
          } }
        } }
      } }
    }, async (ctx) => {
      let decryptedPayload = null;
      try {
        decryptedPayload = await symmetricDecrypt({
          key: ctx.context.secret,
          data: ctx.query.cookies
        });
      } catch (e) {
        ctx.context.logger.error("Failed to decrypt OAuth proxy cookies:", e);
      }
      if (!decryptedPayload) {
        const errorURL = ctx.context.options.onAPIError?.errorURL || `${stripTrailingSlash(ctx.context.options.baseURL)}/api/auth/error`;
        throw ctx.redirect(`${errorURL}?error=OAuthProxy - Invalid cookies or secret`);
      }
      let payload;
      try {
        payload = parseJSON(decryptedPayload);
      } catch (e) {
        ctx.context.logger.error("Failed to parse OAuth proxy payload:", e);
        const errorURL = ctx.context.options.onAPIError?.errorURL || `${stripTrailingSlash(ctx.context.options.baseURL)}/api/auth/error`;
        throw ctx.redirect(`${errorURL}?error=OAuthProxy - Invalid payload format`);
      }
      if (!payload.cookies || typeof payload.cookies !== "string" || typeof payload.timestamp !== "number") {
        ctx.context.logger.error("OAuth proxy payload missing required fields");
        const errorURL = ctx.context.options.onAPIError?.errorURL || `${stripTrailingSlash(ctx.context.options.baseURL)}/api/auth/error`;
        throw ctx.redirect(`${errorURL}?error=OAuthProxy - Invalid payload structure`);
      }
      const age = (Date.now() - payload.timestamp) / 1e3;
      if (age > maxAge || age < -10) {
        ctx.context.logger.error(`OAuth proxy payload expired or invalid (age: ${age}s, maxAge: ${maxAge}s)`);
        const errorURL = ctx.context.options.onAPIError?.errorURL || `${stripTrailingSlash(ctx.context.options.baseURL)}/api/auth/error`;
        throw ctx.redirect(`${errorURL}?error=OAuthProxy - Payload expired or invalid`);
      }
      const decryptedCookies = payload.cookies;
      const isSecureContext = resolveCurrentURL(ctx, opts).protocol === "https:";
      const parsedCookies = parseSetCookieHeader(decryptedCookies);
      const processedCookies = Array.from(parsedCookies.entries()).map(([name, attrs]) => {
        const options = {};
        if (attrs.path) options.path = attrs.path;
        if (attrs.expires) options.expires = attrs.expires;
        if (attrs.samesite) options.sameSite = attrs.samesite;
        if (attrs.httponly) options.httpOnly = true;
        if (attrs["max-age"] !== void 0) options.maxAge = attrs["max-age"];
        if (isSecureContext) options.secure = true;
        const cookieName = isSecureContext ? name : stripSecureCookiePrefix(name);
        let cookieValue;
        try {
          cookieValue = decodeURIComponent(attrs.value);
        } catch {
          cookieValue = attrs.value;
        }
        return {
          name: cookieName,
          value: cookieValue,
          options
        };
      });
      for (const cookie of processedCookies) ctx.setCookie(cookie.name, cookie.value, cookie.options);
      throw ctx.redirect(ctx.query.callbackURL);
    }) },
    hooks: {
      before: [
        {
          matcher(context) {
            return !!(context.path?.startsWith("/sign-in/social") || context.path?.startsWith("/sign-in/oauth2"));
          },
          handler: createAuthMiddleware(async (ctx) => {
            if (checkSkipProxy(ctx, opts)) return;
            const currentURL = resolveCurrentURL(ctx, opts);
            const productionURL = opts?.productionURL;
            const originalCallbackURL = ctx.body?.callbackURL || ctx.context.baseURL;
            if (productionURL) {
              const productionBaseURL = `${stripTrailingSlash(productionURL)}${ctx.context.options.basePath || "/api/auth"}`;
              ctx.context.baseURL = productionBaseURL;
            }
            const newCallbackURL = `${stripTrailingSlash(currentURL.origin)}${ctx.context.options.basePath || "/api/auth"}/oauth-proxy-callback?callbackURL=${encodeURIComponent(originalCallbackURL)}`;
            if (!ctx.body) return;
            ctx.body.callbackURL = newCallbackURL;
          })
        },
        {
          matcher(context) {
            return !!(context.path?.startsWith("/callback") || context.path?.startsWith("/oauth2/callback"));
          },
          handler: createAuthMiddleware(async (ctx) => {
            const state = ctx.query?.state || ctx.body?.state;
            if (!state || typeof state !== "string") return;
            let statePackage;
            try {
              statePackage = parseJSON(await symmetricDecrypt({
                key: ctx.context.secret,
                data: state
              }));
            } catch {
              return;
            }
            if (!statePackage.isOAuthProxy || !statePackage.state || !statePackage.stateCookie) return;
            let stateCookieValue;
            try {
              stateCookieValue = await symmetricDecrypt({
                key: ctx.context.secret,
                data: statePackage.stateCookie
              });
              parseJSON(stateCookieValue);
            } catch (e) {
              ctx.context.logger.error("Failed to decrypt OAuth proxy state cookie:", e);
              return;
            }
            ctx.context._oauthProxySnapshot = {
              storeStateStrategy: ctx.context.oauthConfig.storeStateStrategy,
              skipStateCookieCheck: ctx.context.oauthConfig.skipStateCookieCheck,
              internalAdapter: ctx.context.internalAdapter
            };
            const originalAdapter = ctx.context.internalAdapter;
            const capturedStatePackage = statePackage;
            ctx.context.oauthConfig.storeStateStrategy = "database";
            ctx.context.internalAdapter = {
              ...ctx.context.internalAdapter,
              findVerificationValue: async (identifier) => {
                if (identifier === capturedStatePackage.state) return {
                  id: `oauth-proxy-${capturedStatePackage.state}`,
                  identifier: capturedStatePackage.state,
                  value: stateCookieValue,
                  createdAt: /* @__PURE__ */ new Date(),
                  updatedAt: /* @__PURE__ */ new Date(),
                  expiresAt: new Date(Date.now() + 600 * 1e3)
                };
                return originalAdapter.findVerificationValue(identifier);
              }
            };
            if (ctx.query?.state) ctx.query.state = statePackage.state;
            if (ctx.body?.state) ctx.body.state = statePackage.state;
            ctx.context.oauthConfig.skipStateCookieCheck = true;
          })
        },
        {
          matcher() {
            return true;
          },
          handler: createAuthMiddleware(async (ctx) => {
            if (ctx.path !== "/callback/:id") return;
            if (ctx.context.oauthConfig.storeStateStrategy === "cookie") return;
            if (ctx.context._oauthProxySnapshot) return;
            const state = ctx.query?.state || ctx.body?.state;
            if (!state) return;
            const data = await ctx.context.internalAdapter.findVerificationValue(state);
            if (!data) return;
            let parsedState;
            try {
              parsedState = parseJSON(data.value);
            } catch {
              parsedState = void 0;
            }
            if (!parsedState?.callbackURL?.includes("/oauth-proxy-callback")) return;
            ctx.context._oauthProxySnapshot = {
              storeStateStrategy: ctx.context.oauthConfig.storeStateStrategy,
              skipStateCookieCheck: ctx.context.oauthConfig.skipStateCookieCheck,
              internalAdapter: ctx.context.internalAdapter
            };
            ctx.context.oauthConfig.skipStateCookieCheck = true;
          })
        }
      ],
      after: [
        {
          matcher(context) {
            return !!(context.path?.startsWith("/sign-in/social") || context.path?.startsWith("/sign-in/oauth2"));
          },
          handler: createAuthMiddleware(async (ctx) => {
            if (checkSkipProxy(ctx, opts)) return;
            if (ctx.context.oauthConfig.storeStateStrategy !== "cookie") return;
            const signInResponse = ctx.context.returned;
            if (!signInResponse || typeof signInResponse !== "object" || !("url" in signInResponse)) return;
            const { url: providerURL } = signInResponse;
            if (typeof providerURL !== "string") return;
            const oauthURL = new URL(providerURL);
            const originalState = oauthURL.searchParams.get("state");
            if (!originalState) return;
            const setCookieHeader = ctx.context.responseHeaders?.get("set-cookie");
            if (!setCookieHeader) return;
            const stateCookie = ctx.context.createAuthCookie("oauth_state");
            const stateCookieAttrs = parseSetCookieHeader(setCookieHeader).get(stateCookie.name);
            if (!stateCookieAttrs?.value) return;
            const stateCookieValue = stateCookieAttrs.value;
            try {
              const statePackage = {
                state: originalState,
                stateCookie: stateCookieValue,
                isOAuthProxy: true
              };
              const encryptedPackage = await symmetricEncrypt({
                key: ctx.context.secret,
                data: JSON.stringify(statePackage)
              });
              oauthURL.searchParams.set("state", encryptedPackage);
              ctx.context.returned = {
                ...signInResponse,
                url: oauthURL.toString()
              };
            } catch (e) {
              ctx.context.logger.error("Failed to encrypt OAuth proxy state package:", e);
            }
          })
        },
        {
          matcher(context) {
            return !!(context.path?.startsWith("/callback") || context.path?.startsWith("/oauth2/callback"));
          },
          handler: createAuthMiddleware(async (ctx) => {
            const headers = ctx.context.responseHeaders;
            const location = headers?.get("location");
            if (!location?.includes("/oauth-proxy-callback?callbackURL") || !location.startsWith("http")) return;
            const productionOrigin = getOrigin(opts?.productionURL || ctx.context.options.baseURL || ctx.context.baseURL);
            const locationURL = new URL(location);
            if (locationURL.origin === productionOrigin) {
              const newLocation = locationURL.searchParams.get("callbackURL");
              if (!newLocation) return;
              ctx.setHeader("location", newLocation);
              return;
            }
            const setCookies = headers?.get("set-cookie");
            if (!setCookies) return;
            const payload = {
              cookies: setCookies,
              timestamp: Date.now()
            };
            const encryptedCookies = await symmetricEncrypt({
              key: ctx.context.secret,
              data: JSON.stringify(payload)
            });
            const locationWithCookies = `${location}&cookies=${encodeURIComponent(encryptedCookies)}`;
            ctx.setHeader("location", locationWithCookies);
          })
        },
        {
          matcher(context) {
            return !!(context.path?.startsWith("/callback") || context.path?.startsWith("/oauth2/callback"));
          },
          handler: createAuthMiddleware(async (ctx) => {
            const contextWithSnapshot = ctx.context;
            const snapshot = contextWithSnapshot._oauthProxySnapshot;
            if (snapshot) {
              ctx.context.oauthConfig.storeStateStrategy = snapshot.storeStateStrategy;
              ctx.context.oauthConfig.skipStateCookieCheck = snapshot.skipStateCookieCheck;
              ctx.context.internalAdapter = snapshot.internalAdapter;
              contextWithSnapshot._oauthProxySnapshot = void 0;
            }
          })
        }
      ]
    }
  };
};

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/utils/boolean.mjs
function toBoolean(value) {
  return value === "true" || value === true;
}

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/one-tap/index.mjs
var oneTapCallbackBodySchema = object({ idToken: string().meta({ description: "Google ID token, which the client obtains from the One Tap API" }) });
var oneTap = (options) => ({
  id: "one-tap",
  endpoints: { oneTapCallback: createAuthEndpoint("/one-tap/callback", {
    method: "POST",
    body: oneTapCallbackBodySchema,
    metadata: { openapi: {
      summary: "One tap callback",
      description: "Use this endpoint to authenticate with Google One Tap",
      responses: {
        200: {
          description: "Successful response",
          content: { "application/json": { schema: {
            type: "object",
            properties: {
              session: { $ref: "#/components/schemas/Session" },
              user: { $ref: "#/components/schemas/User" }
            }
          } } }
        },
        400: { description: "Invalid token" }
      }
    } }
  }, async (ctx) => {
    const { idToken } = ctx.body;
    let payload;
    try {
      const { payload: verifiedPayload } = await jwtVerify(idToken, createRemoteJWKSet(new URL("https://www.googleapis.com/oauth2/v3/certs")), {
        issuer: ["https://accounts.google.com", "accounts.google.com"],
        audience: options?.clientId || ctx.context.options.socialProviders?.google?.clientId
      });
      payload = verifiedPayload;
    } catch {
      throw new APIError("BAD_REQUEST", { message: "invalid id token" });
    }
    const { email: email2, email_verified, name, picture, sub } = payload;
    if (!email2) return ctx.json({ error: "Email not available in token" });
    const user = await ctx.context.internalAdapter.findUserByEmail(email2);
    if (!user) {
      if (options?.disableSignup) throw new APIError("BAD_GATEWAY", { message: "User not found" });
      const newUser = await ctx.context.internalAdapter.createOAuthUser({
        email: email2,
        emailVerified: typeof email_verified === "boolean" ? email_verified : toBoolean(email_verified),
        name,
        image: picture
      }, {
        providerId: "google",
        accountId: sub
      });
      if (!newUser) throw new APIError("INTERNAL_SERVER_ERROR", { message: "Could not create user" });
      const session$1 = await ctx.context.internalAdapter.createSession(newUser.user.id);
      await setSessionCookie(ctx, {
        user: newUser.user,
        session: session$1
      });
      return ctx.json({
        token: session$1.token,
        user: {
          id: newUser.user.id,
          email: newUser.user.email,
          emailVerified: newUser.user.emailVerified,
          name: newUser.user.name,
          image: newUser.user.image,
          createdAt: newUser.user.createdAt,
          updatedAt: newUser.user.updatedAt
        }
      });
    }
    if (!await ctx.context.internalAdapter.findAccount(sub)) {
      const accountLinking = ctx.context.options.account?.accountLinking;
      if (accountLinking?.enabled !== false && (accountLinking?.trustedProviders?.includes("google") || email_verified)) await ctx.context.internalAdapter.linkAccount({
        userId: user.user.id,
        providerId: "google",
        accountId: sub,
        scope: "openid,profile,email",
        idToken
      });
      else throw new APIError("UNAUTHORIZED", { message: "Google sub doesn't match" });
    }
    const session = await ctx.context.internalAdapter.createSession(user.user.id);
    await setSessionCookie(ctx, {
      user: user.user,
      session
    });
    return ctx.json({
      token: session.token,
      user: {
        id: user.user.id,
        email: user.user.email,
        emailVerified: user.user.emailVerified,
        name: user.user.name,
        image: user.user.image,
        createdAt: user.user.createdAt,
        updatedAt: user.user.updatedAt
      }
    });
  }) },
  options
});

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/one-time-token/utils.mjs
var defaultKeyHasher4 = async (token) => {
  const hash = await createHash("SHA-256").digest(new TextEncoder().encode(token));
  return base64Url.encode(new Uint8Array(hash), { padding: false });
};

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/one-time-token/index.mjs
var verifyOneTimeTokenBodySchema = object({ token: string().meta({ description: 'The token to verify. Eg: "some-token"' }) });
var oneTimeToken = (options) => {
  const opts = {
    storeToken: "plain",
    ...options
  };
  async function storeToken(ctx, token) {
    if (opts.storeToken === "hashed") return await defaultKeyHasher4(token);
    if (typeof opts.storeToken === "object" && "type" in opts.storeToken && opts.storeToken.type === "custom-hasher") return await opts.storeToken.hash(token);
    return token;
  }
  async function generateToken(c, session) {
    const token = opts?.generateToken ? await opts.generateToken(session, c) : generateRandomString(32);
    const expiresAt = new Date(Date.now() + (opts?.expiresIn ?? 3) * 60 * 1e3);
    const storedToken = await storeToken(c, token);
    await c.context.internalAdapter.createVerificationValue({
      value: session.session.token,
      identifier: `one-time-token:${storedToken}`,
      expiresAt
    });
    return token;
  }
  return {
    id: "one-time-token",
    endpoints: {
      generateOneTimeToken: createAuthEndpoint("/one-time-token/generate", {
        method: "GET",
        use: [sessionMiddleware]
      }, async (c) => {
        if (opts?.disableClientRequest && c.request) throw c.error("BAD_REQUEST", { message: "Client requests are disabled" });
        const session = c.context.session;
        const token = await generateToken(c, session);
        return c.json({ token });
      }),
      verifyOneTimeToken: createAuthEndpoint("/one-time-token/verify", {
        method: "POST",
        body: verifyOneTimeTokenBodySchema
      }, async (c) => {
        const { token } = c.body;
        const storedToken = await storeToken(c, token);
        const verificationValue = await c.context.internalAdapter.findVerificationValue(`one-time-token:${storedToken}`);
        if (!verificationValue) throw c.error("BAD_REQUEST", { message: "Invalid token" });
        await c.context.internalAdapter.deleteVerificationValue(verificationValue.id);
        if (verificationValue.expiresAt < /* @__PURE__ */ new Date()) throw c.error("BAD_REQUEST", { message: "Token expired" });
        const session = await c.context.internalAdapter.findSession(verificationValue.value);
        if (!session) throw c.error("BAD_REQUEST", { message: "Session not found" });
        if (!opts?.disableSetSessionCookie) await setSessionCookie(c, session);
        if (session.session.expiresAt < /* @__PURE__ */ new Date()) throw c.error("BAD_REQUEST", { message: "Session expired" });
        return c.json(session);
      })
    },
    hooks: { after: [{
      matcher: () => true,
      handler: createAuthMiddleware(async (ctx) => {
        if (ctx.context.newSession) {
          if (!opts?.setOttHeaderOnNewSession) return;
          const exposedHeaders = ctx.context.responseHeaders?.get("access-control-expose-headers") || "";
          const headersSet = new Set(exposedHeaders.split(",").map((header) => header.trim()).filter(Boolean));
          headersSet.add("set-ott");
          const token = await generateToken(ctx, ctx.context.newSession);
          ctx.setHeader("set-ott", token);
          ctx.setHeader("Access-Control-Expose-Headers", Array.from(headersSet).join(", "));
        }
      })
    }] },
    options
  };
};

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/open-api/generator.mjs
var allowedType = /* @__PURE__ */ new Set([
  "string",
  "number",
  "boolean",
  "array",
  "object"
]);
function getTypeFromZodType(zodType) {
  const type = zodType.type;
  return allowedType.has(type) ? type : "string";
}
function getFieldSchema(field) {
  const schema9 = {
    type: field.type === "date" ? "string" : field.type,
    ...field.type === "date" && { format: "date-time" }
  };
  if (field.defaultValue !== void 0) schema9.default = typeof field.defaultValue === "function" ? "Generated at runtime" : field.defaultValue;
  if (field.input === false) schema9.readOnly = true;
  return schema9;
}
function getParameters(options) {
  const parameters = [];
  if (options.metadata?.openapi?.parameters) {
    parameters.push(...options.metadata.openapi.parameters);
    return parameters;
  }
  if (options.query instanceof ZodObject) Object.entries(options.query.shape).forEach(([key, value]) => {
    if (value instanceof ZodType) parameters.push({
      name: key,
      in: "query",
      schema: {
        ...processZodType(value),
        ..."minLength" in value && value.minLength ? { minLength: value.minLength } : {}
      }
    });
  });
  return parameters;
}
function getRequestBody(options) {
  if (options.metadata?.openapi?.requestBody) return options.metadata.openapi.requestBody;
  if (!options.body) return void 0;
  if (options.body instanceof ZodObject || options.body instanceof ZodOptional) {
    const shape = options.body.shape;
    if (!shape) return void 0;
    const properties = {};
    const required = [];
    Object.entries(shape).forEach(([key, value]) => {
      if (value instanceof ZodType) {
        properties[key] = processZodType(value);
        if (!(value instanceof ZodOptional)) required.push(key);
      }
    });
    return {
      required: options.body instanceof ZodOptional ? false : options.body ? true : false,
      content: { "application/json": { schema: {
        type: "object",
        properties,
        required
      } } }
    };
  }
}
function processZodType(zodType) {
  if (zodType instanceof ZodOptional) {
    const innerType = zodType._def.innerType;
    const innerSchema = processZodType(innerType);
    if (innerSchema.type) {
      const type = Array.isArray(innerSchema.type) ? innerSchema.type : [innerSchema.type];
      return {
        ...innerSchema,
        type: Array.from(/* @__PURE__ */ new Set([...type, "null"]))
      };
    }
    return { anyOf: [innerSchema, { type: "null" }] };
  }
  if (zodType instanceof ZodObject) {
    const shape = zodType.shape;
    if (shape) {
      const properties = {};
      const required = [];
      Object.entries(shape).forEach(([key, value]) => {
        if (value instanceof ZodType) {
          properties[key] = processZodType(value);
          if (!(value instanceof ZodOptional)) required.push(key);
        }
      });
      return {
        type: "object",
        properties,
        ...required.length > 0 ? { required } : {},
        description: zodType.description
      };
    }
  }
  return {
    type: getTypeFromZodType(zodType),
    description: zodType.description
  };
}
function getResponse(responses) {
  return {
    "400": {
      content: { "application/json": { schema: {
        type: "object",
        properties: { message: { type: "string" } },
        required: ["message"]
      } } },
      description: "Bad Request. Usually due to missing parameters, or invalid parameters."
    },
    "401": {
      content: { "application/json": { schema: {
        type: "object",
        properties: { message: { type: "string" } },
        required: ["message"]
      } } },
      description: "Unauthorized. Due to missing or invalid authentication."
    },
    "403": {
      content: { "application/json": { schema: {
        type: "object",
        properties: { message: { type: "string" } }
      } } },
      description: "Forbidden. You do not have permission to access this resource or to perform this action."
    },
    "404": {
      content: { "application/json": { schema: {
        type: "object",
        properties: { message: { type: "string" } }
      } } },
      description: "Not Found. The requested resource was not found."
    },
    "429": {
      content: { "application/json": { schema: {
        type: "object",
        properties: { message: { type: "string" } }
      } } },
      description: "Too Many Requests. You have exceeded the rate limit. Try again later."
    },
    "500": {
      content: { "application/json": { schema: {
        type: "object",
        properties: { message: { type: "string" } }
      } } },
      description: "Internal Server Error. This is a problem with the server that you cannot fix."
    },
    ...responses
  };
}
function toOpenApiPath(path) {
  return path.split("/").map((part) => part.startsWith(":") ? `{${part.slice(1)}}` : part).join("/");
}
async function generator(ctx, options) {
  const baseEndpoints = getEndpoints(ctx, {
    ...options,
    plugins: []
  });
  const tables = (0, db_exports.getAuthTables)({
    ...options,
    session: {
      ...options.session,
      storeSessionInDatabase: true
    }
  });
  const components = { schemas: { ...Object.entries(tables).reduce((acc, [key, value]) => {
    const modelName = key.charAt(0).toUpperCase() + key.slice(1);
    const fields = value.fields;
    const required = [];
    const properties = { id: { type: "string" } };
    Object.entries(fields).forEach(([fieldKey, fieldValue]) => {
      if (!fieldValue) return;
      properties[fieldKey] = getFieldSchema(fieldValue);
      if (fieldValue.required && fieldValue.input !== false) required.push(fieldKey);
    });
    Object.entries(properties).forEach(([key$1, prop]) => {
      const field = value.fields[key$1];
      if (field && field.type === "date" && prop.type === "string") prop.format = "date-time";
    });
    acc[modelName] = {
      type: "object",
      properties,
      required
    };
    return acc;
  }, {}) } };
  const paths = {};
  Object.entries(baseEndpoints.api).forEach(([_, value]) => {
    if (!value.path || ctx.options.disabledPaths?.includes(value.path)) return;
    const options$1 = value.options;
    if (options$1.metadata?.SERVER_ONLY) return;
    const path = toOpenApiPath(value.path);
    if (options$1.method === "GET" || options$1.method === "DELETE") paths[path] = {
      ...paths[path],
      [options$1.method.toLowerCase()]: {
        tags: ["Default", ...options$1.metadata?.openapi?.tags || []],
        description: options$1.metadata?.openapi?.description,
        operationId: options$1.metadata?.openapi?.operationId,
        security: [{ bearerAuth: [] }],
        parameters: getParameters(options$1),
        responses: getResponse(options$1.metadata?.openapi?.responses)
      }
    };
    if (options$1.method === "POST" || options$1.method === "PATCH" || options$1.method === "PUT") {
      const body = getRequestBody(options$1);
      paths[path] = {
        ...paths[path],
        [options$1.method.toLowerCase()]: {
          tags: ["Default", ...options$1.metadata?.openapi?.tags || []],
          description: options$1.metadata?.openapi?.description,
          operationId: options$1.metadata?.openapi?.operationId,
          security: [{ bearerAuth: [] }],
          parameters: getParameters(options$1),
          ...body ? { requestBody: body } : { requestBody: { content: { "application/json": { schema: {
            type: "object",
            properties: {}
          } } } } },
          responses: getResponse(options$1.metadata?.openapi?.responses)
        }
      };
    }
  });
  for (const plugin of options.plugins || []) {
    if (plugin.id === "open-api") continue;
    const pluginEndpoints = getEndpoints(ctx, {
      ...options,
      plugins: [plugin]
    });
    const api = Object.keys(pluginEndpoints.api).map((key) => {
      if (baseEndpoints.api[key] === void 0) return pluginEndpoints.api[key];
      return null;
    }).filter((x) => x !== null);
    Object.entries(api).forEach(([key, value]) => {
      if (!value.path || ctx.options.disabledPaths?.includes(value.path)) return;
      const options$1 = value.options;
      if (options$1.metadata?.SERVER_ONLY) return;
      const path = toOpenApiPath(value.path);
      if (options$1.method === "GET" || options$1.method === "DELETE") paths[path] = {
        ...paths[path],
        [options$1.method.toLowerCase()]: {
          tags: options$1.metadata?.openapi?.tags || [plugin.id.charAt(0).toUpperCase() + plugin.id.slice(1)],
          description: options$1.metadata?.openapi?.description,
          operationId: options$1.metadata?.openapi?.operationId,
          security: [{ bearerAuth: [] }],
          parameters: getParameters(options$1),
          responses: getResponse(options$1.metadata?.openapi?.responses)
        }
      };
      if (options$1.method === "POST" || options$1.method === "PATCH" || options$1.method === "PUT") paths[path] = {
        ...paths[path],
        [options$1.method.toLowerCase()]: {
          tags: options$1.metadata?.openapi?.tags || [plugin.id.charAt(0).toUpperCase() + plugin.id.slice(1)],
          description: options$1.metadata?.openapi?.description,
          operationId: options$1.metadata?.openapi?.operationId,
          security: [{ bearerAuth: [] }],
          parameters: getParameters(options$1),
          requestBody: getRequestBody(options$1),
          responses: getResponse(options$1.metadata?.openapi?.responses)
        }
      };
    });
  }
  return {
    openapi: "3.1.1",
    info: {
      title: "Better Auth",
      description: "API Reference for your Better Auth Instance",
      version: "1.1.0"
    },
    components: {
      ...components,
      securitySchemes: {
        apiKeyCookie: {
          type: "apiKey",
          in: "cookie",
          name: "apiKeyCookie",
          description: "API Key authentication via cookie"
        },
        bearerAuth: {
          type: "http",
          scheme: "bearer",
          description: "Bearer token authentication"
        }
      }
    },
    security: [{
      apiKeyCookie: [],
      bearerAuth: []
    }],
    servers: [{ url: ctx.baseURL }],
    tags: [{
      name: "Default",
      description: "Default endpoints that are included with Better Auth by default. These endpoints are not part of any plugin."
    }],
    paths
  };
}

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/open-api/logo.mjs
var logo = `<svg width="75" height="75" viewBox="0 0 75 75" fill="none" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<rect width="75" height="75" fill="url(#pattern0_21_12)"/>
<defs>
<pattern id="pattern0_21_12" patternContentUnits="objectBoundingBox" width="1" height="1">
<use xlink:href="#image0_21_12" transform="scale(0.00094697)"/>
</pattern>
<image id="image0_21_12" width="1056" height="1056" xlink:href="data:image/jpeg;base64,/9j/4AAQSkZJRgABAQAASABIAAD/4QBARXhpZgAATU0AKgAAAAgAAYdpAAQAAAABAAAAGgAAAAAAAqACAAQAAAABAAAEIKADAAQAAAABAAAEIAAAAAD/7QA4UGhvdG9zaG9wIDMuMAA4QklNBAQAAAAAAAA4QklNBCUAAAAAABDUHYzZjwCyBOmACZjs+EJ+/+ICKElDQ19QUk9GSUxFAAEBAAACGGFwcGwEAAAAbW50clJHQiBYWVogB+YAAQABAAAAAAAAYWNzcEFQUEwAAAAAQVBQTAAAAAAAAAAAAAAAAAAAAAAAAPbWAAEAAAAA0y1hcHBs7P2jjjiFR8NttL1PetoYLwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKZGVzYwAAAPwAAAAwY3BydAAAASwAAABQd3RwdAAAAXwAAAAUclhZWgAAAZAAAAAUZ1hZWgAAAaQAAAAUYlhZWgAAAbgAAAAUclRSQwAAAcwAAAAgY2hhZAAAAewAAAAsYlRSQwAAAcwAAAAgZ1RSQwAAAcwAAAAgbWx1YwAAAAAAAAABAAAADGVuVVMAAAAUAAAAHABEAGkAcwBwAGwAYQB5ACAAUAAzbWx1YwAAAAAAAAABAAAADGVuVVMAAAA0AAAAHABDAG8AcAB5AHIAaQBnAGgAdAAgAEEAcABwAGwAZQAgAEkAbgBjAC4ALAAgADIAMAAyADJYWVogAAAAAAAA9tUAAQAAAADTLFhZWiAAAAAAAACD3wAAPb////+7WFlaIAAAAAAAAEq/AACxNwAACrlYWVogAAAAAAAAKDgAABELAADIuXBhcmEAAAAAAAMAAAACZmYAAPKnAAANWQAAE9AAAApbc2YzMgAAAAAAAQxCAAAF3v//8yYAAAeTAAD9kP//+6L///2jAAAD3AAAwG7/wAARCAQgBCADASIAAhEBAxEB/8QAHwAAAQUBAQEBAQEAAAAAAAAAAAECAwQFBgcICQoL/8QAtRAAAgEDAwIEAwUFBAQAAAF9AQIDAAQRBRIhMUEGE1FhByJxFDKBkaEII0KxwRVS0fAkM2JyggkKFhcYGRolJicoKSo0NTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqDhIWGh4iJipKTlJWWl5iZmqKjpKWmp6ipqrKztLW2t7i5usLDxMXGx8jJytLT1NXW19jZ2uHi4+Tl5ufo6erx8vP09fb3+Pn6/8QAHwEAAwEBAQEBAQEBAQAAAAAAAAECAwQFBgcICQoL/8QAtREAAgECBAQDBAcFBAQAAQJ3AAECAxEEBSExBhJBUQdhcRMiMoEIFEKRobHBCSMzUvAVYnLRChYkNOEl8RcYGRomJygpKjU2Nzg5OkNERUZHSElKU1RVVldYWVpjZGVmZ2hpanN0dXZ3eHl6goOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4uPk5ebn6Onq8vP09fb3+Pn6/9sAQwACAgICAgIDAgIDBAMDAwQFBAQEBAUHBQUFBQUHCAcHBwcHBwgICAgICAgICgoKCgoKCwsLCwsNDQ0NDQ0NDQ0N/9sAQwECAgIDAwMGAwMGDQkHCQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0N/90ABABC/9oADAMBAAIRAxEAPwD9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//Q/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/0f38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/9L9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//T/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/1P38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/9X9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//W/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/1/38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/9D9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//R/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/0v38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/9P9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//U/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/1f38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/9b9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//X/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/0P38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/9H9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//S/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/0/38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/9T9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//V/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/1v38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAK/Ln/gq38a/in8Dvgp4T8R/CfxFdeG9SvvFMdlcXFoELyW5srqQxnzEcY3op4Gciv1Gr8Z/+C2X/JvXgj/sc4v/AE33lAH4z/8ADwv9tD/oq2tf9823/wAZo/4eF/tof9FW1r/vm2/+M18Z0UAfZn/Dwv8AbQ/6KtrX/fNt/wDGaP8Ah4X+2h/0VbWv++bb/wCM18Z0UAfZn/Dwv9tD/oq2tf8AfNt/8Zo/4eF/tof9FW1r/vm2/wDjNfGdFAH2Z/w8L/bQ/wCira1/3zbf/GaP+Hhf7aH/AEVbWv8Avm2/+M18Z0UAfZn/AA8L/bQ/6KtrX/fNt/8AGaP+Hhf7aH/RVta/75tv/jNfGdFAH2Z/w8L/AG0P+ira1/3zbf8Axmj/AIeF/tof9FW1r/vm2/8AjNfGdFAH63/sVftq/tTfEb9qb4deCfG3xF1TVtD1bVGgvbKdYBHPGIJW2ttiVsblB4I6V/UbX8Z//BPT/k9D4U/9hpv/AEmmr+zCgAooooAKKKKACiiigAooooAKKKKACiiigD+M/wD4eF/tof8ARVta/wC+bb/4zR/w8L/bQ/6KtrX/AHzbf/Ga+M6KAPsz/h4X+2h/0VbWv++bb/4zR/w8L/bQ/wCira1/3zbf/Ga+M6KAPsz/AIeF/tof9FW1r/vm2/8AjNH/AA8L/bQ/6KtrX/fNt/8AGa+M6KAPsz/h4X+2h/0VbWv++bb/AOM0f8PC/wBtD/oq2tf9823/AMZr4zooA+zP+Hhf7aH/AEVbWv8Avm2/+M0f8PC/20P+ira1/wB823/xmvjOigD7M/4eF/tof9FW1r/vm2/+M0f8PC/20P8Aoq2tf9823/xmvjOigD7M/wCHhf7aH/RVta/75tv/AIzR/wAPC/20P+ira1/3zbf/ABmvjOigD7M/4eF/tof9FW1r/vm2/wDjNH/Dwv8AbQ/6KtrX/fNt/wDGa+M6KAPsz/h4X+2h/wBFW1r/AL5tv/jNH/Dwv9tD/oq2tf8AfNt/8Zr4zooA+zP+Hhf7aH/RVta/75tv/jNH/Dwv9tD/AKKtrX/fNt/8Zr4zooA+zP8Ah4X+2h/0VbWv++bb/wCM0f8ADwv9tD/oq2tf9823/wAZr4zooA+zP+Hhf7aH/RVta/75tv8A4zR/w8L/AG0P+ira1/3zbf8AxmvjOigD7M/4eF/tof8ARVta/wC+bb/4zR/w8L/bQ/6KtrX/AHzbf/Ga+M6KAP6tv+CUnxr+Kfxx+CnizxH8WPEV14k1Kx8UyWVvcXYQPHbiytZBGPLRBje7HkZya/Uavxn/AOCJv/JvXjf/ALHOX/032dfsxQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAf//X/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAr8Z/+C2X/JvXgj/sc4v/AE33lfsxX4z/APBbL/k3rwR/2OcX/pvvKAP5m6KKKACiiigAooooAKKKKACiiigAooooA+zP+Cen/J6Hwp/7DTf+k01f2YV/Gf8A8E9P+T0PhT/2Gm/9Jpq/swoAKKKKACiiigAooooAKKKKACiiigAooooA/gDooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA/pk/4Im/8m9eN/8Asc5f/TfZ1+zFfjP/AMETf+TevG//AGOcv/pvs6/ZigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA/9D9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACvxn/4LZf8m9eCP+xzi/8ATfeV+zFfjP8A8Fsv+TevBH/Y5xf+m+8oA/mbooooAKKKKACiiigAooooAKKKKACiiigD7M/4J6f8nofCn/sNN/6TTV/ZhX8Z/wDwT0/5PQ+FP/Yab/0mmr+zCgAooooAKKKKACiiigAooooAKKKKACiiigD+AOiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD+mT/gib/yb143/wCxzl/9N9nX7MV+M/8AwRN/5N68b/8AY5y/+m+zr9mKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/0f38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAK/Gf/gtl/yb14I/7HOL/wBN95X7MV+M/wDwWy/5N68Ef9jnF/6b7ygD+ZuiiigAooooAKKKKACiiigAooooAKKKKAPsz/gnp/yeh8Kf+w03/pNNX9mFfxn/APBPT/k9D4U/9hpv/Saav7MKACiiigAooooAKKKKACiiigAooooAKKKKAP4A6KKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP6ZP+CJv/JvXjf/ALHOX/032dfsxX4z/wDBE3/k3rxv/wBjnL/6b7Ov2YoAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/S/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAr8Z/+C2X/JvXgj/sc4v/AE33lfsxX4z/APBbL/k3rwR/2OcX/pvvKAP5m6KKKACiiigAooooAKKKKACiiigAooooA+zP+Cen/J6Hwp/7DTf+k01f2YV/Gf8A8E9P+T0PhT/2Gm/9Jpq/swoAKKKKACiiigAooooAKKKKACiiigAooooA/gDooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA/pk/4Im/8m9eN/8Asc5f/TfZ1+zFfjP/AMETf+TevG//AGOcv/pvs6/ZigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA/9P9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACvxn/4LZf8m9eCP+xzi/8ATfeV+zFfjP8A8Fsv+TevBH/Y5xf+m+8oA/mbooooAKKKKACiiigAooooAKKKKACiiigD7M/4J6f8nofCn/sNN/6TTV/ZhX8Z/wDwT0/5PQ+FP/Yab/0mmr+zCgAooooAKKKKACiiigAooooAKKKKACiiigD+AOiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD+mT/gib/yb143/wCxzl/9N9nX7MV+M/8AwRN/5N68b/8AY5y/+m+zr9mKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/1P38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAK/Gf/gtl/yb14I/7HOL/wBN95X7MV+M/wDwWy/5N68Ef9jnF/6b7ygD+ZuiiigAooooAKKKKACiiigAooooAKKKKAPsz/gnp/yeh8Kf+w03/pNNX9mFfwq/BT4r638Dvin4d+LHhy0tb7UvDd0bu3t70ObeRzG0eJBGyPjDnowOa/Ub/h9l+0L/ANCR4M/79ah/8m0Af0yUV/M3/wAPsv2hf+hI8Gf9+tQ/+TaP+H2X7Qv/AEJHgz/v1qH/AMm0Af0yUV/M3/w+y/aF/wChI8Gf9+tQ/wDk2j/h9l+0L/0JHgz/AL9ah/8AJtAH9MlFfzN/8Psv2hf+hI8Gf9+tQ/8Ak2j/AIfZftC/9CR4M/79ah/8m0Af0yUV/M3/AMPsv2hf+hI8Gf8AfrUP/k2j/h9l+0L/ANCR4M/79ah/8m0Af0yUV/M3/wAPsv2hf+hI8Gf9+tQ/+TaP+H2X7Qv/AEJHgz/v1qH/AMm0Af0yUV/M3/w+y/aF/wChI8Gf9+tQ/wDk2j/h9l+0L/0JHgz/AL9ah/8AJtAH4z0V/TJ/w5N/Z6/6Hfxn/wB/dP8A/kKj/hyb+z1/0O/jP/v7p/8A8hUAfzN0V/TJ/wAOTf2ev+h38Z/9/dP/APkKj/hyb+z1/wBDv4z/AO/un/8AyFQB/M3RX9Mn/Dk39nr/AKHfxn/390//AOQqP+HJv7PX/Q7+M/8Av7p//wAhUAfzN0V/TJ/w5N/Z6/6Hfxn/AN/dP/8AkKj/AIcm/s9f9Dv4z/7+6f8A/IVAH8zdFf0yf8OTf2ev+h38Z/8Af3T/AP5Co/4cm/s9f9Dv4z/7+6f/APIVAH8zdFf0yf8ADk39nr/od/Gf/f3T/wD5Co/4cm/s9f8AQ7+M/wDv7p//AMhUAfzN0V/TJ/w5N/Z6/wCh38Z/9/dP/wDkKvwV/ag+FGifA74++M/hP4cu7q+03w3fi0t7i9KG4kQxRyZkMaomcueigYoA8FooooAKKKKACiiigAooooAKKKKACiiigD+mT/gib/yb143/AOxzl/8ATfZ1+zFfjP8A8ETf+TevG/8A2Ocv/pvs6/ZigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//9X9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACvxn/4LZf8m9eCP+xzi/8ATfeV+zFfjP8A8Fsv+TevBH/Y5xf+m+8oA/mbooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA/v8ooooAKKKKACiiigAooooAKKKKACiiigAr+M//goX/wAnofFb/sNL/wCk0Nf2YV/Gf/wUL/5PQ+K3/YaX/wBJoaAPjOiiigAooooAKKKKACiiigAooooAKKKKAP6ZP+CJv/JvXjf/ALHOX/032dfsxX4z/wDBE3/k3rxv/wBjnL/6b7Ov2YoAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/W/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAr8Z/+C2X/JvXgj/sc4v/AE33lfsxX4z/APBbL/k3rwR/2OcX/pvvKAP5m6KKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP7/KKKKACiiigAooooAKKKKACiiigAooooAK/jP/4KF/8AJ6HxW/7DS/8ApNDX9mFfxn/8FC/+T0Pit/2Gl/8ASaGgD4zooooAKKKKACiiigAooooAKKKKACiiigD+mT/gib/yb143/wCxzl/9N9nX7MV+M/8AwRN/5N68b/8AY5y/+m+zr9mKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/1/38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAK/Gf/gtl/yb14I/7HOL/wBN95X7MV+M/wDwWy/5N68Ef9jnF/6b7ygD+ZuiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD+/yiiigAooooAKKKKACiiigAooooAKKKKACv4z/+Chf/ACeh8Vv+w0v/AKTQ1/ZhX8Z//BQv/k9D4rf9hpf/AEmhoA+M6KKKACiiigAooooAKKKKACiiigAooooA/pk/4Im/8m9eN/8Asc5f/TfZ1+zFfjP/AMETf+TevG//AGOcv/pvs6/ZigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA/9D9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACvxn/4LZf8m9eCP+xzi/8ATfeV+zFfjP8A8Fsv+TevBH/Y5xf+m+8oA/mbooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA/v8ooooAKKKKACiiigAooooAKKKKACiiigAr+M//goX/wAnofFb/sNL/wCk0Nf2YV/Gf/wUL/5PQ+K3/YaX/wBJoaAPjOiiigAooooAKKKKACiiigAooooAKKKKAP6ZP+CJv/JvXjf/ALHOX/032dfsxX4z/wDBE3/k3rxv/wBjnL/6b7Ov2YoAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/R/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAr8Z/+C2X/JvXgj/sc4v/AE33lfsxX4z/APBbL/k3rwR/2OcX/pvvKAP5m6KKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP7/KKKKACiiigAooooAKKKKACiiigAooooAK/jP/4KF/8AJ6HxW/7DS/8ApNDX9mFfxn/8FC/+T0Pit/2Gl/8ASaGgD4zooooAKKKKACiiigAooooAKKKKACiiigD+mT/gib/yb143/wCxzl/9N9nX7MV+M/8AwRN/5N68b/8AY5y/+m+zr9mKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/0v38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAK/Gf/gtl/yb14I/7HOL/wBN95X7MV+M/wDwWy/5N68Ef9jnF/6b7ygD+ZuiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD+/yiiigAooooAKKKKACiiigAooooAKKKKACv4z/+Chf/ACeh8Vv+w0v/AKTQ1/ZhX8Z//BQv/k9D4rf9hpf/AEmhoA+M6KKKACiiigAooooAKKKKACiiigAooooA/pk/4Im/8m9eN/8Asc5f/TfZ1+zFfjP/AMETf+TevG//AGOcv/pvs6/ZigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA/9P9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACvxn/4LZf8m9eCP+xzi/8ATfeV+zFfjP8A8Fsv+TevBH/Y5xf+m+8oA/mbooooAKKKKACiiigAooooAKKKKACiiigD1L4KfCjW/jj8U/Dvwn8OXdrY6l4kujaW9xelxbxuI2kzIY1d8YQ9FJzX6jf8OTf2hf8Aod/Bn/f3UP8A5Cr4z/4J6f8AJ6Hwp/7DTf8ApNNX9mFAH8zf/Dk39oX/AKHfwZ/391D/AOQqP+HJv7Qv/Q7+DP8Av7qH/wAhV/TJRQB/M3/w5N/aF/6HfwZ/391D/wCQqP8Ahyb+0L/0O/gz/v7qH/yFX9MlFAH8zf8Aw5N/aF/6HfwZ/wB/dQ/+QqP+HJv7Qv8A0O/gz/v7qH/yFX9MlFAH8zf/AA5N/aF/6HfwZ/391D/5Co/4cm/tC/8AQ7+DP+/uof8AyFX9MlFAH8zf/Dk39oX/AKHfwZ/391D/AOQqP+HJv7Qv/Q7+DP8Av7qH/wAhV/TJRQB/M3/w5N/aF/6HfwZ/391D/wCQqP8Ahyb+0L/0O/gz/v7qH/yFX9MlFAH4z/8AD7L9nr/oSPGf/frT/wD5No/4fZfs9f8AQkeM/wDv1p//AMm1/M3RQB/TJ/w+y/Z6/wChI8Z/9+tP/wDk2j/h9l+z1/0JHjP/AL9af/8AJtfzN0UAf0yf8Psv2ev+hI8Z/wDfrT//AJNo/wCH2X7PX/QkeM/+/Wn/APybX8zdFAH9Mn/D7L9nr/oSPGf/AH60/wD+TaP+H2X7PX/QkeM/+/Wn/wDybX8zdFAH9Mn/AA+y/Z6/6Ejxn/360/8A+TaP+H2X7PX/AEJHjP8A79af/wDJtfzN0UAf0yf8Psv2ev8AoSPGf/frT/8A5No/4fZfs9f9CR4z/wC/Wn//ACbX8zdFAH9Mn/D7L9nr/oSPGf8A360//wCTa/BX9qD4r6J8cfj74z+LHhy0urHTfEl+Lu3t70ILiNBFHHiQRs6Zyh6MRivBaKACiiigAooooAKKKKACiiigAooooAKKKKAP6ZP+CJv/ACb143/7HOX/ANN9nX7MV+M//BE3/k3rxv8A9jnL/wCm+zr9mKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD//U/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAr8Z/+C2X/JvXgj/sc4v/AE33lfsxX4z/APBbL/k3rwR/2OcX/pvvKAP5m6KKKACiiigAooooAKKKKACiiigAooooA+zP+Cen/J6Hwp/7DTf+k01f2YV/Gf8A8E9P+T0PhT/2Gm/9Jpq/swoAKKKKACiiigAooooAKKKKACiiigAooooA/gDooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA/pk/4Im/8m9eN/8Asc5f/TfZ1+zFfjP/AMETf+TevG//AGOcv/pvs6/ZigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA/9X9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACvxn/4LZf8m9eCP+xzi/8ATfeV+zFfjP8A8Fsv+TevBH/Y5xf+m+8oA/mbooooAKKKKACiiigAooooAKKKKACiiigD7M/4J6f8nofCn/sNN/6TTV/ZhX8Z/wDwT0/5PQ+FP/Yab/0mmr+zCgAooooAKKKKACiiigAooooAKKKKACiiigD+AOiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD+mT/gib/yb143/wCxzl/9N9nX7MV+M/8AwRN/5N68b/8AY5y/+m+zr9mKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/1v38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAK/Gf/gtl/yb14I/7HOL/wBN95X7MV+M/wDwWy/5N68Ef9jnF/6b7ygD+ZuiiigAooooAKKKKACiiigAooooAKKKKAPsz/gnp/yeh8Kf+w03/pNNX9mFfxn/APBPT/k9D4U/9hpv/Saav7MKACiiigAooooAKKKKACiiigAooooAKKKKAP4A6KKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP6ZP+CJv/JvXjf/ALHOX/032dfsxX4z/wDBE3/k3rxv/wBjnL/6b7Ov2YoAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/X/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAr8Z/+C2X/JvXgj/sc4v/AE33lfsxX4z/APBbL/k3rwR/2OcX/pvvKAP5m6KKKACiiigAooooAKKKKACiiigAooooA+zP+Cen/J6Hwp/7DTf+k01f2YV/Gf8A8E9P+T0PhT/2Gm/9Jpq/swoAKKKKACiiigAooooAKKKKACiiigAooooA/gDooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA/pk/4Im/8m9eN/8Asc5f/TfZ1+zFfjP/AMETf+TevG//AGOcv/pvs6/ZigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA/9D9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACvxn/4LZf8m9eCP+xzi/8ATfeV+zFfjP8A8Fsv+TevBH/Y5xf+m+8oA/mbooooAKKKKACiiigAooooAKKKKACiiigD7M/4J6f8nofCn/sNN/6TTV/ZhX8Z/wDwT0/5PQ+FP/Yab/0mmr+zCgAooooAKKKKACiiigAooooAKKKKACiiigD+AOiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD+mT/gib/yb143/wCxzl/9N9nX7MV+M/8AwRN/5N68b/8AY5y/+m+zr9mKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/0f38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAK/Gf/gtl/yb14I/7HOL/wBN95X7MV+XP/BVv4KfFP44/BTwn4c+E/h268SalY+KY724t7QoHjtxZXUZkPmOgxvdRwc5NAH8pNFfZn/DvT9tD/olOtf99W3/AMeo/wCHen7aH/RKda/76tv/AI9QB8Z0V9mf8O9P20P+iU61/wB9W3/x6j/h3p+2h/0SnWv++rb/AOPUAfGdFfZn/DvT9tD/AKJTrX/fVt/8eo/4d6ftof8ARKda/wC+rb/49QB8Z0V9mf8ADvT9tD/olOtf99W3/wAeo/4d6ftof9Ep1r/vq2/+PUAfGdFfZn/DvT9tD/olOtf99W3/AMeo/wCHen7aH/RKda/76tv/AI9QB8Z0V9mf8O9P20P+iU61/wB9W3/x6j/h3p+2h/0SnWv++rb/AOPUAH/BPT/k9D4U/wDYab/0mmr+zCv5cv2Kv2Kv2pvhz+1N8OvG3jb4dappOh6TqjT3t7O0BjgjMEq7m2ys2NzAcA9a/qNoAKKKKACiiigAooooAKKKKACiiigAooooA/gDor7M/wCHen7aH/RKda/76tv/AI9R/wAO9P20P+iU61/31bf/AB6gD4zor7M/4d6ftof9Ep1r/vq2/wDj1H/DvT9tD/olOtf99W3/AMeoA+M6K+zP+Hen7aH/AESnWv8Avq2/+PUf8O9P20P+iU61/wB9W3/x6gD4zor7M/4d6ftof9Ep1r/vq2/+PUf8O9P20P8AolOtf99W3/x6gD4zor7M/wCHen7aH/RKda/76tv/AI9R/wAO9P20P+iU61/31bf/AB6gD4zor7M/4d6ftof9Ep1r/vq2/wDj1H/DvT9tD/olOtf99W3/AMeoA+M6K+zP+Hen7aH/AESnWv8Avq2/+PUf8O9P20P+iU61/wB9W3/x6gD4zor7M/4d6ftof9Ep1r/vq2/+PUf8O9P20P8AolOtf99W3/x6gD4zor7M/wCHen7aH/RKda/76tv/AI9R/wAO9P20P+iU61/31bf/AB6gD4zor7M/4d6ftof9Ep1r/vq2/wDj1H/DvT9tD/olOtf99W3/AMeoA+M6K+zP+Hen7aH/AESnWv8Avq2/+PUf8O9P20P+iU61/wB9W3/x6gD4zor7M/4d6ftof9Ep1r/vq2/+PUf8O9P20P8AolOtf99W3/x6gD4zor7M/wCHen7aH/RKda/76tv/AI9R/wAO9P20P+iU61/31bf/AB6gD9mP+CJv/JvXjf8A7HOX/wBN9nX7MV+XP/BKT4KfFP4HfBTxZ4c+LHh268N6lfeKZL23t7soXktzZWsYkHlu4xvRhyc5FfqNQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAFFFFABRRRQAUUUUAf/9L9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//T/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/1P38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/9X9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//W/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/1/38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/9D9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//R/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/0v38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/9P9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//U/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/1f38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/9b9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//X/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/0P38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/9H9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//S/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/0/38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/9T9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//V/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/1v38ooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigD/9f9/KKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooA//Q/fyiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKACiiigAooooAKKKKAP/2Q=="/>
</defs>
</svg>
`;

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/open-api/index.mjs
var getHTML = (apiReference, theme, nonce) => {
  const nonceAttr = nonce ? `nonce="${nonce}"` : "";
  return `<!doctype html>
<html>
  <head>
    <title>Scalar API Reference</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, initial-scale=1" />
  </head>
  <body>
    <script
      id="api-reference"
      type="application/json">
    ${JSON.stringify(apiReference)}
    <\/script>
	 <script ${nonceAttr}>
      var configuration = {
	  	favicon: "data:image/svg+xml;utf8,${encodeURIComponent(logo)}",
	   	theme: "${theme || "default"}",
        metaData: {
			title: "Better Auth API",
			description: "API Reference for your Better Auth Instance",
		}
      }

      document.getElementById('api-reference').dataset.configuration =
        JSON.stringify(configuration)
    <\/script>
	  <script src="https://cdn.jsdelivr.net/npm/@scalar/api-reference" ${nonceAttr}><\/script>
  </body>
</html>`;
};
var openAPI = (options) => {
  const path = options?.path ?? "/reference";
  return {
    id: "open-api",
    endpoints: {
      generateOpenAPISchema: createAuthEndpoint("/open-api/generate-schema", { method: "GET" }, async (ctx) => {
        const schema9 = await generator(ctx.context, ctx.context.options);
        return ctx.json(schema9);
      }),
      openAPIReference: createAuthEndpoint(path, {
        method: "GET",
        metadata: HIDE_METADATA
      }, async (ctx) => {
        if (options?.disableDefaultReference) throw new APIError("NOT_FOUND");
        const schema9 = await generator(ctx.context, ctx.context.options);
        return new Response(getHTML(schema9, options?.theme, options?.nonce), { headers: { "Content-Type": "text/html" } });
      })
    },
    options
  };
};

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/organization/adapter.mjs
var getOrgAdapter = (context, options) => {
  const baseAdapter = context.adapter;
  return {
    findOrganizationBySlug: async (slug) => {
      return await (await getCurrentAdapter(baseAdapter)).findOne({
        model: "organization",
        where: [{
          field: "slug",
          value: slug
        }]
      });
    },
    createOrganization: async (data) => {
      const organization2 = await (await getCurrentAdapter(baseAdapter)).create({
        model: "organization",
        data: {
          ...data.organization,
          metadata: data.organization.metadata ? JSON.stringify(data.organization.metadata) : void 0
        },
        forceAllowId: true
      });
      return {
        ...organization2,
        metadata: organization2.metadata && typeof organization2.metadata === "string" ? JSON.parse(organization2.metadata) : void 0
      };
    },
    findMemberByEmail: async (data) => {
      const adapter = await getCurrentAdapter(baseAdapter);
      const user = await adapter.findOne({
        model: "user",
        where: [{
          field: "email",
          value: data.email.toLowerCase()
        }]
      });
      if (!user) return null;
      const member = await adapter.findOne({
        model: "member",
        where: [{
          field: "organizationId",
          value: data.organizationId
        }, {
          field: "userId",
          value: user.id
        }]
      });
      if (!member) return null;
      return {
        ...member,
        user: {
          id: user.id,
          name: user.name,
          email: user.email,
          image: user.image
        }
      };
    },
    listMembers: async (data) => {
      const adapter = await getCurrentAdapter(baseAdapter);
      const members = await Promise.all([adapter.findMany({
        model: "member",
        where: [{
          field: "organizationId",
          value: data.organizationId
        }, ...data.filter?.field ? [{
          field: data.filter?.field,
          value: data.filter?.value,
          ...data.filter.operator ? { operator: data.filter.operator } : {}
        }] : []],
        limit: data.limit || options?.membershipLimit || 100,
        offset: data.offset || 0,
        sortBy: data.sortBy ? {
          field: data.sortBy,
          direction: data.sortOrder || "asc"
        } : void 0
      }), adapter.count({
        model: "member",
        where: [{
          field: "organizationId",
          value: data.organizationId
        }, ...data.filter?.field ? [{
          field: data.filter?.field,
          value: data.filter?.value,
          ...data.filter.operator ? { operator: data.filter.operator } : {}
        }] : []]
      })]);
      const users = await adapter.findMany({
        model: "user",
        where: [{
          field: "id",
          value: members[0].map((member) => member.userId),
          operator: "in"
        }]
      });
      return {
        members: members[0].map((member) => {
          const user = users.find((user$1) => user$1.id === member.userId);
          if (!user) throw new BetterAuthError("Unexpected error: User not found for member");
          return {
            ...member,
            user: {
              id: user.id,
              name: user.name,
              email: user.email,
              image: user.image
            }
          };
        }),
        total: members[1]
      };
    },
    findMemberByOrgId: async (data) => {
      const result = await (await getCurrentAdapter(baseAdapter)).findOne({
        model: "member",
        where: [{
          field: "userId",
          value: data.userId
        }, {
          field: "organizationId",
          value: data.organizationId
        }],
        join: { user: true }
      });
      if (!result || !result.user) return null;
      const { user, ...member } = result;
      return {
        ...member,
        user: {
          id: user.id,
          name: user.name,
          email: user.email,
          image: user.image
        }
      };
    },
    findMemberById: async (memberId) => {
      const result = await (await getCurrentAdapter(baseAdapter)).findOne({
        model: "member",
        where: [{
          field: "id",
          value: memberId
        }],
        join: { user: true }
      });
      if (!result) return null;
      const { user, ...member } = result;
      return {
        ...member,
        user: {
          id: user.id,
          name: user.name,
          email: user.email,
          image: user.image
        }
      };
    },
    createMember: async (data) => {
      return await (await getCurrentAdapter(baseAdapter)).create({
        model: "member",
        data: {
          ...data,
          createdAt: /* @__PURE__ */ new Date()
        }
      });
    },
    updateMember: async (memberId, role2) => {
      return await (await getCurrentAdapter(baseAdapter)).update({
        model: "member",
        where: [{
          field: "id",
          value: memberId
        }],
        update: { role: role2 }
      });
    },
    deleteMember: async ({ memberId, organizationId, userId: _userId }) => {
      const adapter = await getCurrentAdapter(baseAdapter);
      let userId;
      if (!_userId) {
        const member$1 = await adapter.findOne({
          model: "member",
          where: [{
            field: "id",
            value: memberId
          }]
        });
        if (!member$1) throw new BetterAuthError("Member not found");
        userId = member$1.userId;
      } else userId = _userId;
      const member = await adapter.delete({
        model: "member",
        where: [{
          field: "id",
          value: memberId
        }]
      });
      if (options?.teams?.enabled) {
        const teams = await adapter.findMany({
          model: "team",
          where: [{
            field: "organizationId",
            value: organizationId
          }]
        });
        await Promise.all(teams.map((team) => adapter.deleteMany({
          model: "teamMember",
          where: [{
            field: "teamId",
            value: team.id
          }, {
            field: "userId",
            value: userId
          }]
        })));
      }
      return member;
    },
    updateOrganization: async (organizationId, data) => {
      const organization2 = await (await getCurrentAdapter(baseAdapter)).update({
        model: "organization",
        where: [{
          field: "id",
          value: organizationId
        }],
        update: {
          ...data,
          metadata: typeof data.metadata === "object" ? JSON.stringify(data.metadata) : data.metadata
        }
      });
      if (!organization2) return null;
      return {
        ...organization2,
        metadata: organization2.metadata ? parseJSON(organization2.metadata) : void 0
      };
    },
    deleteOrganization: async (organizationId) => {
      const adapter = await getCurrentAdapter(baseAdapter);
      await adapter.deleteMany({
        model: "member",
        where: [{
          field: "organizationId",
          value: organizationId
        }]
      });
      await adapter.deleteMany({
        model: "invitation",
        where: [{
          field: "organizationId",
          value: organizationId
        }]
      });
      await adapter.delete({
        model: "organization",
        where: [{
          field: "id",
          value: organizationId
        }]
      });
      return organizationId;
    },
    setActiveOrganization: async (sessionToken, organizationId, ctx) => {
      return await context.internalAdapter.updateSession(sessionToken, { activeOrganizationId: organizationId });
    },
    findOrganizationById: async (organizationId) => {
      return await (await getCurrentAdapter(baseAdapter)).findOne({
        model: "organization",
        where: [{
          field: "id",
          value: organizationId
        }]
      });
    },
    checkMembership: async ({ userId, organizationId }) => {
      return await (await getCurrentAdapter(baseAdapter)).findOne({
        model: "member",
        where: [{
          field: "userId",
          value: userId
        }, {
          field: "organizationId",
          value: organizationId
        }]
      });
    },
    findFullOrganization: async ({ organizationId, isSlug, includeTeams, membersLimit }) => {
      const adapter = await getCurrentAdapter(baseAdapter);
      const result = await adapter.findOne({
        model: "organization",
        where: [{
          field: isSlug ? "slug" : "id",
          value: organizationId
        }],
        join: {
          invitation: true,
          member: membersLimit ? { limit: membersLimit } : true,
          ...includeTeams ? { team: true } : {}
        }
      });
      if (!result) return null;
      const { invitation: invitations, member: members, team: teams, ...org } = result;
      const userIds = members.map((member) => member.userId);
      const users = userIds.length > 0 ? await adapter.findMany({
        model: "user",
        where: [{
          field: "id",
          value: userIds,
          operator: "in"
        }],
        limit: options?.membershipLimit || 100
      }) : [];
      const userMap = new Map(users.map((user) => [user.id, user]));
      const membersWithUsers = members.map((member) => {
        const user = userMap.get(member.userId);
        if (!user) throw new BetterAuthError("Unexpected error: User not found for member");
        return {
          ...member,
          user: {
            id: user.id,
            name: user.name,
            email: user.email,
            image: user.image
          }
        };
      });
      return {
        ...org,
        invitations,
        members: membersWithUsers,
        teams
      };
    },
    listOrganizations: async (userId) => {
      const result = await (await getCurrentAdapter(baseAdapter)).findMany({
        model: "member",
        where: [{
          field: "userId",
          value: userId
        }],
        join: { organization: true }
      });
      if (!result || result.length === 0) return [];
      return result.map((member) => member.organization);
    },
    createTeam: async (data) => {
      return await (await getCurrentAdapter(baseAdapter)).create({
        model: "team",
        data
      });
    },
    findTeamById: async ({ teamId, organizationId, includeTeamMembers }) => {
      const result = await (await getCurrentAdapter(baseAdapter)).findOne({
        model: "team",
        where: [{
          field: "id",
          value: teamId
        }, ...organizationId ? [{
          field: "organizationId",
          value: organizationId
        }] : []],
        join: { ...includeTeamMembers ? { teamMember: true } : {} }
      });
      if (!result) return null;
      const { teamMember, ...team } = result;
      return {
        ...team,
        ...includeTeamMembers ? { members: teamMember } : {}
      };
    },
    updateTeam: async (teamId, data) => {
      const adapter = await getCurrentAdapter(baseAdapter);
      if ("id" in data) data.id = void 0;
      return await adapter.update({
        model: "team",
        where: [{
          field: "id",
          value: teamId
        }],
        update: { ...data }
      });
    },
    deleteTeam: async (teamId) => {
      const adapter = await getCurrentAdapter(baseAdapter);
      await adapter.deleteMany({
        model: "teamMember",
        where: [{
          field: "teamId",
          value: teamId
        }]
      });
      return await adapter.delete({
        model: "team",
        where: [{
          field: "id",
          value: teamId
        }]
      });
    },
    listTeams: async (organizationId) => {
      return await (await getCurrentAdapter(baseAdapter)).findMany({
        model: "team",
        where: [{
          field: "organizationId",
          value: organizationId
        }]
      });
    },
    createTeamInvitation: async ({ email: email2, role: role2, teamId, organizationId, inviterId, expiresIn = 1e3 * 60 * 60 * 48 }) => {
      const adapter = await getCurrentAdapter(baseAdapter);
      const expiresAt = getDate(expiresIn);
      return await adapter.create({
        model: "invitation",
        data: {
          email: email2,
          role: role2,
          organizationId,
          teamId,
          inviterId,
          status: "pending",
          expiresAt
        }
      });
    },
    setActiveTeam: async (sessionToken, teamId, ctx) => {
      return await context.internalAdapter.updateSession(sessionToken, { activeTeamId: teamId });
    },
    listTeamMembers: async (data) => {
      return await (await getCurrentAdapter(baseAdapter)).findMany({
        model: "teamMember",
        where: [{
          field: "teamId",
          value: data.teamId
        }]
      });
    },
    countTeamMembers: async (data) => {
      return await (await getCurrentAdapter(baseAdapter)).count({
        model: "teamMember",
        where: [{
          field: "teamId",
          value: data.teamId
        }]
      });
    },
    countMembers: async (data) => {
      return await (await getCurrentAdapter(baseAdapter)).count({
        model: "member",
        where: [{
          field: "organizationId",
          value: data.organizationId
        }]
      });
    },
    listTeamsByUser: async (data) => {
      return (await (await getCurrentAdapter(baseAdapter)).findMany({
        model: "teamMember",
        where: [{
          field: "userId",
          value: data.userId
        }],
        join: { team: true }
      })).map((result) => result.team);
    },
    findTeamMember: async (data) => {
      return await (await getCurrentAdapter(baseAdapter)).findOne({
        model: "teamMember",
        where: [{
          field: "teamId",
          value: data.teamId
        }, {
          field: "userId",
          value: data.userId
        }]
      });
    },
    findOrCreateTeamMember: async (data) => {
      const adapter = await getCurrentAdapter(baseAdapter);
      const member = await adapter.findOne({
        model: "teamMember",
        where: [{
          field: "teamId",
          value: data.teamId
        }, {
          field: "userId",
          value: data.userId
        }]
      });
      if (member) return member;
      return await adapter.create({
        model: "teamMember",
        data: {
          teamId: data.teamId,
          userId: data.userId,
          createdAt: /* @__PURE__ */ new Date()
        }
      });
    },
    removeTeamMember: async (data) => {
      await (await getCurrentAdapter(baseAdapter)).deleteMany({
        model: "teamMember",
        where: [{
          field: "teamId",
          value: data.teamId
        }, {
          field: "userId",
          value: data.userId
        }]
      });
    },
    findInvitationsByTeamId: async (teamId) => {
      return await (await getCurrentAdapter(baseAdapter)).findMany({
        model: "invitation",
        where: [{
          field: "teamId",
          value: teamId
        }]
      });
    },
    listUserInvitations: async (email2) => {
      return (await (await getCurrentAdapter(baseAdapter)).findMany({
        model: "invitation",
        where: [{
          field: "email",
          value: email2.toLowerCase()
        }],
        join: { organization: true }
      })).map(({ organization: organization2, ...inv }) => ({
        ...inv,
        organizationName: organization2.name
      }));
    },
    createInvitation: async ({ invitation, user }) => {
      const adapter = await getCurrentAdapter(baseAdapter);
      const expiresAt = getDate(options?.invitationExpiresIn || 3600 * 48, "sec");
      return await adapter.create({
        model: "invitation",
        data: {
          status: "pending",
          expiresAt,
          createdAt: /* @__PURE__ */ new Date(),
          inviterId: user.id,
          ...invitation,
          teamId: invitation.teamIds.length > 0 ? invitation.teamIds.join(",") : null
        }
      });
    },
    findInvitationById: async (id) => {
      return await (await getCurrentAdapter(baseAdapter)).findOne({
        model: "invitation",
        where: [{
          field: "id",
          value: id
        }]
      });
    },
    findPendingInvitation: async (data) => {
      return (await (await getCurrentAdapter(baseAdapter)).findMany({
        model: "invitation",
        where: [
          {
            field: "email",
            value: data.email.toLowerCase()
          },
          {
            field: "organizationId",
            value: data.organizationId
          },
          {
            field: "status",
            value: "pending"
          }
        ]
      })).filter((invite) => new Date(invite.expiresAt) > /* @__PURE__ */ new Date());
    },
    findPendingInvitations: async (data) => {
      return (await (await getCurrentAdapter(baseAdapter)).findMany({
        model: "invitation",
        where: [{
          field: "organizationId",
          value: data.organizationId
        }, {
          field: "status",
          value: "pending"
        }]
      })).filter((invite) => new Date(invite.expiresAt) > /* @__PURE__ */ new Date());
    },
    listInvitations: async (data) => {
      return await (await getCurrentAdapter(baseAdapter)).findMany({
        model: "invitation",
        where: [{
          field: "organizationId",
          value: data.organizationId
        }]
      });
    },
    updateInvitation: async (data) => {
      return await (await getCurrentAdapter(baseAdapter)).update({
        model: "invitation",
        where: [{
          field: "id",
          value: data.invitationId
        }],
        update: { status: data.status }
      });
    }
  };
};

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/organization/access/statement.mjs
var defaultStatements = {
  organization: ["update", "delete"],
  member: [
    "create",
    "update",
    "delete"
  ],
  invitation: ["create", "cancel"],
  team: [
    "create",
    "update",
    "delete"
  ],
  ac: [
    "create",
    "read",
    "update",
    "delete"
  ]
};
var defaultAc = createAccessControl(defaultStatements);
var adminAc = defaultAc.newRole({
  organization: ["update"],
  invitation: ["create", "cancel"],
  member: [
    "create",
    "update",
    "delete"
  ],
  team: [
    "create",
    "update",
    "delete"
  ],
  ac: [
    "create",
    "read",
    "update",
    "delete"
  ]
});
var ownerAc = defaultAc.newRole({
  organization: ["update", "delete"],
  member: [
    "create",
    "update",
    "delete"
  ],
  invitation: ["create", "cancel"],
  team: [
    "create",
    "update",
    "delete"
  ],
  ac: [
    "create",
    "read",
    "update",
    "delete"
  ]
});
var memberAc = defaultAc.newRole({
  organization: [],
  member: [],
  invitation: [],
  team: [],
  ac: ["read"]
});
var defaultRoles2 = {
  admin: adminAc,
  owner: ownerAc,
  member: memberAc
};

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/utils/shim.mjs
var shimContext = (originalObject, newContext) => {
  const shimmedObj = {};
  for (const [key, value] of Object.entries(originalObject)) {
    shimmedObj[key] = (ctx) => {
      return value({
        ...ctx,
        context: {
          ...newContext,
          ...ctx.context
        }
      });
    };
    shimmedObj[key].path = value.path;
    shimmedObj[key].method = value.method;
    shimmedObj[key].options = value.options;
    shimmedObj[key].headers = value.headers;
  }
  return shimmedObj;
};

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/organization/call.mjs
var orgMiddleware = createAuthMiddleware(async () => {
  return {};
});
var orgSessionMiddleware = createAuthMiddleware({ use: [sessionMiddleware] }, async (ctx) => {
  return { session: ctx.context.session };
});

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/organization/error-codes.mjs
var ORGANIZATION_ERROR_CODES = defineErrorCodes({
  YOU_ARE_NOT_ALLOWED_TO_CREATE_A_NEW_ORGANIZATION: "You are not allowed to create a new organization",
  YOU_HAVE_REACHED_THE_MAXIMUM_NUMBER_OF_ORGANIZATIONS: "You have reached the maximum number of organizations",
  ORGANIZATION_ALREADY_EXISTS: "Organization already exists",
  ORGANIZATION_SLUG_ALREADY_TAKEN: "Organization slug already taken",
  ORGANIZATION_NOT_FOUND: "Organization not found",
  USER_IS_NOT_A_MEMBER_OF_THE_ORGANIZATION: "User is not a member of the organization",
  YOU_ARE_NOT_ALLOWED_TO_UPDATE_THIS_ORGANIZATION: "You are not allowed to update this organization",
  YOU_ARE_NOT_ALLOWED_TO_DELETE_THIS_ORGANIZATION: "You are not allowed to delete this organization",
  NO_ACTIVE_ORGANIZATION: "No active organization",
  USER_IS_ALREADY_A_MEMBER_OF_THIS_ORGANIZATION: "User is already a member of this organization",
  MEMBER_NOT_FOUND: "Member not found",
  ROLE_NOT_FOUND: "Role not found",
  YOU_ARE_NOT_ALLOWED_TO_CREATE_A_NEW_TEAM: "You are not allowed to create a new team",
  TEAM_ALREADY_EXISTS: "Team already exists",
  TEAM_NOT_FOUND: "Team not found",
  YOU_CANNOT_LEAVE_THE_ORGANIZATION_AS_THE_ONLY_OWNER: "You cannot leave the organization as the only owner",
  YOU_CANNOT_LEAVE_THE_ORGANIZATION_WITHOUT_AN_OWNER: "You cannot leave the organization without an owner",
  YOU_ARE_NOT_ALLOWED_TO_DELETE_THIS_MEMBER: "You are not allowed to delete this member",
  YOU_ARE_NOT_ALLOWED_TO_INVITE_USERS_TO_THIS_ORGANIZATION: "You are not allowed to invite users to this organization",
  USER_IS_ALREADY_INVITED_TO_THIS_ORGANIZATION: "User is already invited to this organization",
  INVITATION_NOT_FOUND: "Invitation not found",
  YOU_ARE_NOT_THE_RECIPIENT_OF_THE_INVITATION: "You are not the recipient of the invitation",
  EMAIL_VERIFICATION_REQUIRED_BEFORE_ACCEPTING_OR_REJECTING_INVITATION: "Email verification required before accepting or rejecting invitation",
  YOU_ARE_NOT_ALLOWED_TO_CANCEL_THIS_INVITATION: "You are not allowed to cancel this invitation",
  INVITER_IS_NO_LONGER_A_MEMBER_OF_THE_ORGANIZATION: "Inviter is no longer a member of the organization",
  YOU_ARE_NOT_ALLOWED_TO_INVITE_USER_WITH_THIS_ROLE: "You are not allowed to invite a user with this role",
  FAILED_TO_RETRIEVE_INVITATION: "Failed to retrieve invitation",
  YOU_HAVE_REACHED_THE_MAXIMUM_NUMBER_OF_TEAMS: "You have reached the maximum number of teams",
  UNABLE_TO_REMOVE_LAST_TEAM: "Unable to remove last team",
  YOU_ARE_NOT_ALLOWED_TO_UPDATE_THIS_MEMBER: "You are not allowed to update this member",
  ORGANIZATION_MEMBERSHIP_LIMIT_REACHED: "Organization membership limit reached",
  YOU_ARE_NOT_ALLOWED_TO_CREATE_TEAMS_IN_THIS_ORGANIZATION: "You are not allowed to create teams in this organization",
  YOU_ARE_NOT_ALLOWED_TO_DELETE_TEAMS_IN_THIS_ORGANIZATION: "You are not allowed to delete teams in this organization",
  YOU_ARE_NOT_ALLOWED_TO_UPDATE_THIS_TEAM: "You are not allowed to update this team",
  YOU_ARE_NOT_ALLOWED_TO_DELETE_THIS_TEAM: "You are not allowed to delete this team",
  INVITATION_LIMIT_REACHED: "Invitation limit reached",
  TEAM_MEMBER_LIMIT_REACHED: "Team member limit reached",
  USER_IS_NOT_A_MEMBER_OF_THE_TEAM: "User is not a member of the team",
  YOU_CAN_NOT_ACCESS_THE_MEMBERS_OF_THIS_TEAM: "You are not allowed to list the members of this team",
  YOU_DO_NOT_HAVE_AN_ACTIVE_TEAM: "You do not have an active team",
  YOU_ARE_NOT_ALLOWED_TO_CREATE_A_NEW_TEAM_MEMBER: "You are not allowed to create a new member",
  YOU_ARE_NOT_ALLOWED_TO_REMOVE_A_TEAM_MEMBER: "You are not allowed to remove a team member",
  YOU_ARE_NOT_ALLOWED_TO_ACCESS_THIS_ORGANIZATION: "You are not allowed to access this organization as an owner",
  YOU_ARE_NOT_A_MEMBER_OF_THIS_ORGANIZATION: "You are not a member of this organization",
  MISSING_AC_INSTANCE: "Dynamic Access Control requires a pre-defined ac instance on the server auth plugin. Read server logs for more information",
  YOU_MUST_BE_IN_AN_ORGANIZATION_TO_CREATE_A_ROLE: "You must be in an organization to create a role",
  YOU_ARE_NOT_ALLOWED_TO_CREATE_A_ROLE: "You are not allowed to create a role",
  YOU_ARE_NOT_ALLOWED_TO_UPDATE_A_ROLE: "You are not allowed to update a role",
  YOU_ARE_NOT_ALLOWED_TO_DELETE_A_ROLE: "You are not allowed to delete a role",
  YOU_ARE_NOT_ALLOWED_TO_READ_A_ROLE: "You are not allowed to read a role",
  YOU_ARE_NOT_ALLOWED_TO_LIST_A_ROLE: "You are not allowed to list a role",
  YOU_ARE_NOT_ALLOWED_TO_GET_A_ROLE: "You are not allowed to get a role",
  TOO_MANY_ROLES: "This organization has too many roles",
  INVALID_RESOURCE: "The provided permission includes an invalid resource",
  ROLE_NAME_IS_ALREADY_TAKEN: "That role name is already taken",
  CANNOT_DELETE_A_PRE_DEFINED_ROLE: "Cannot delete a pre-defined role"
});

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/organization/permission.mjs
var hasPermissionFn = (input, acRoles) => {
  if (!input.permissions && !input.permission) return false;
  const roles = input.role.split(",");
  const creatorRole = input.options.creatorRole || "owner";
  const isCreator = roles.includes(creatorRole);
  const allowCreatorsAllPermissions = input.allowCreatorAllPermissions || false;
  if (isCreator && allowCreatorsAllPermissions) return true;
  for (const role2 of roles) if (acRoles[role2]?.authorize(input.permissions ?? input.permission)?.success) return true;
  return false;
};
var cacheAllRoles = /* @__PURE__ */ new Map();

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/organization/has-permission.mjs
var hasPermission2 = async (input, ctx) => {
  let acRoles = { ...input.options.roles || defaultRoles2 };
  if (ctx && input.organizationId && input.options.dynamicAccessControl?.enabled && input.options.ac && !input.useMemoryCache) {
    const roles = await ctx.context.adapter.findMany({
      model: "organizationRole",
      where: [{
        field: "organizationId",
        value: input.organizationId
      }]
    });
    for (const { role: role2, permission: permissionsString } of roles) {
      if (role2 in acRoles) continue;
      const result = record(string(), array(string())).safeParse(JSON.parse(permissionsString));
      if (!result.success) {
        ctx.context.logger.error("[hasPermission] Invalid permissions for role " + role2, { permissions: JSON.parse(permissionsString) });
        throw new APIError("INTERNAL_SERVER_ERROR", { message: "Invalid permissions for role " + role2 });
      }
      acRoles[role2] = input.options.ac.newRole(result.data);
    }
  }
  if (input.useMemoryCache) acRoles = cacheAllRoles.get(input.organizationId) || acRoles;
  cacheAllRoles.set(input.organizationId, acRoles);
  return hasPermissionFn(input, acRoles);
};

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/organization/routes/crud-access-control.mjs
var normalizeRoleName = (role2) => role2.toLowerCase();
var DEFAULT_MAXIMUM_ROLES_PER_ORGANIZATION = Number.POSITIVE_INFINITY;
var getAdditionalFields = (options, shouldBePartial = false) => {
  let additionalFields = options?.schema?.organizationRole?.additionalFields || {};
  if (shouldBePartial) for (const key in additionalFields) additionalFields[key].required = false;
  return {
    additionalFieldsSchema: toZodSchema({
      fields: additionalFields,
      isClientSide: true
    }),
    $AdditionalFields: {},
    $ReturnAdditionalFields: {}
  };
};
var baseCreateOrgRoleSchema = object({
  organizationId: string().optional().meta({ description: "The id of the organization to create the role in. If not provided, the user's active organization will be used." }),
  role: string().meta({ description: "The name of the role to create" }),
  permission: record(string(), array(string())).meta({ description: "The permission to assign to the role" })
});
var createOrgRole = (options) => {
  const { additionalFieldsSchema, $AdditionalFields, $ReturnAdditionalFields } = getAdditionalFields(options, false);
  return createAuthEndpoint("/organization/create-role", {
    method: "POST",
    body: baseCreateOrgRoleSchema.safeExtend({ additionalFields: object({ ...additionalFieldsSchema.shape }).optional() }),
    metadata: { $Infer: { body: {} } },
    requireHeaders: true,
    use: [orgSessionMiddleware]
  }, async (ctx) => {
    const { session, user } = ctx.context.session;
    let roleName = ctx.body.role;
    const permission = ctx.body.permission;
    const additionalFields = ctx.body.additionalFields;
    const ac = options.ac;
    if (!ac) {
      ctx.context.logger.error(`[Dynamic Access Control] The organization plugin is missing a pre-defined ac instance.`, `
Please refer to the documentation here: https://better-auth.com/docs/plugins/organization#dynamic-access-control`);
      throw new APIError("NOT_IMPLEMENTED", { message: ORGANIZATION_ERROR_CODES.MISSING_AC_INSTANCE });
    }
    const organizationId = ctx.body.organizationId ?? session.activeOrganizationId;
    if (!organizationId) {
      ctx.context.logger.error(`[Dynamic Access Control] The session is missing an active organization id to create a role. Either set an active org id, or pass an organizationId in the request body.`);
      throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.YOU_MUST_BE_IN_AN_ORGANIZATION_TO_CREATE_A_ROLE });
    }
    roleName = normalizeRoleName(roleName);
    await checkIfRoleNameIsTakenByPreDefinedRole({
      role: roleName,
      organizationId,
      options,
      ctx
    });
    const member = await ctx.context.adapter.findOne({
      model: "member",
      where: [{
        field: "organizationId",
        value: organizationId,
        operator: "eq",
        connector: "AND"
      }, {
        field: "userId",
        value: user.id,
        operator: "eq",
        connector: "AND"
      }]
    });
    if (!member) {
      ctx.context.logger.error(`[Dynamic Access Control] The user is not a member of the organization to create a role.`, {
        userId: user.id,
        organizationId
      });
      throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_A_MEMBER_OF_THIS_ORGANIZATION });
    }
    if (!await hasPermission2({
      options,
      organizationId,
      permissions: { ac: ["create"] },
      role: member.role
    }, ctx)) {
      ctx.context.logger.error(`[Dynamic Access Control] The user is not permitted to create a role. If this is unexpected, please make sure the role associated to that member has the "ac" resource with the "create" permission.`, {
        userId: user.id,
        organizationId,
        role: member.role
      });
      throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_CREATE_A_ROLE });
    }
    const maximumRolesPerOrganization = typeof options.dynamicAccessControl?.maximumRolesPerOrganization === "function" ? await options.dynamicAccessControl.maximumRolesPerOrganization(organizationId) : options.dynamicAccessControl?.maximumRolesPerOrganization ?? DEFAULT_MAXIMUM_ROLES_PER_ORGANIZATION;
    const rolesInDB = await ctx.context.adapter.count({
      model: "organizationRole",
      where: [{
        field: "organizationId",
        value: organizationId,
        operator: "eq",
        connector: "AND"
      }]
    });
    if (rolesInDB >= maximumRolesPerOrganization) {
      ctx.context.logger.error(`[Dynamic Access Control] Failed to create a new role, the organization has too many roles. Maximum allowed roles is ${maximumRolesPerOrganization}.`, {
        organizationId,
        maximumRolesPerOrganization,
        rolesInDB
      });
      throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.TOO_MANY_ROLES });
    }
    await checkForInvalidResources({
      ac,
      ctx,
      permission
    });
    await checkIfMemberHasPermission({
      ctx,
      member,
      options,
      organizationId,
      permissionRequired: permission,
      user,
      action: "create"
    });
    await checkIfRoleNameIsTakenByRoleInDB({
      ctx,
      organizationId,
      role: roleName
    });
    const newRole = ac.newRole(permission);
    const data = {
      ...await ctx.context.adapter.create({
        model: "organizationRole",
        data: {
          createdAt: /* @__PURE__ */ new Date(),
          organizationId,
          permission: JSON.stringify(permission),
          role: roleName,
          ...additionalFields
        }
      }),
      permission
    };
    return ctx.json({
      success: true,
      roleData: data,
      statements: newRole.statements
    });
  });
};
var deleteOrgRoleBodySchema = object({ organizationId: string().optional().meta({ description: "The id of the organization to create the role in. If not provided, the user's active organization will be used." }) }).and(union([object({ roleName: string().nonempty().meta({ description: "The name of the role to delete" }) }), object({ roleId: string().nonempty().meta({ description: "The id of the role to delete" }) })]));
var deleteOrgRole = (options) => {
  return createAuthEndpoint("/organization/delete-role", {
    method: "POST",
    body: deleteOrgRoleBodySchema,
    requireHeaders: true,
    use: [orgSessionMiddleware],
    metadata: { $Infer: { body: {} } }
  }, async (ctx) => {
    const { session, user } = ctx.context.session;
    const organizationId = ctx.body.organizationId ?? session.activeOrganizationId;
    if (!organizationId) {
      ctx.context.logger.error(`[Dynamic Access Control] The session is missing an active organization id to delete a role. Either set an active org id, or pass an organizationId in the request body.`);
      throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.NO_ACTIVE_ORGANIZATION });
    }
    const member = await ctx.context.adapter.findOne({
      model: "member",
      where: [{
        field: "organizationId",
        value: organizationId,
        operator: "eq",
        connector: "AND"
      }, {
        field: "userId",
        value: user.id,
        operator: "eq",
        connector: "AND"
      }]
    });
    if (!member) {
      ctx.context.logger.error(`[Dynamic Access Control] The user is not a member of the organization to delete a role.`, {
        userId: user.id,
        organizationId
      });
      throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_A_MEMBER_OF_THIS_ORGANIZATION });
    }
    if (!await hasPermission2({
      options,
      organizationId,
      permissions: { ac: ["delete"] },
      role: member.role
    }, ctx)) {
      ctx.context.logger.error(`[Dynamic Access Control] The user is not permitted to delete a role. If this is unexpected, please make sure the role associated to that member has the "ac" resource with the "delete" permission.`, {
        userId: user.id,
        organizationId,
        role: member.role
      });
      throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_DELETE_A_ROLE });
    }
    if (ctx.body.roleName) {
      const roleName = ctx.body.roleName;
      const defaultRoles4 = options.roles ? Object.keys(options.roles) : [
        "owner",
        "admin",
        "member"
      ];
      if (defaultRoles4.includes(roleName)) {
        ctx.context.logger.error(`[Dynamic Access Control] Cannot delete a pre-defined role.`, {
          roleName,
          organizationId,
          defaultRoles: defaultRoles4
        });
        throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.CANNOT_DELETE_A_PRE_DEFINED_ROLE });
      }
    }
    let condition;
    if (ctx.body.roleName) condition = {
      field: "role",
      value: ctx.body.roleName,
      operator: "eq",
      connector: "AND"
    };
    else if (ctx.body.roleId) condition = {
      field: "id",
      value: ctx.body.roleId,
      operator: "eq",
      connector: "AND"
    };
    else {
      ctx.context.logger.error(`[Dynamic Access Control] The role name/id is not provided in the request body.`);
      throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.ROLE_NOT_FOUND });
    }
    const existingRoleInDB = await ctx.context.adapter.findOne({
      model: "organizationRole",
      where: [{
        field: "organizationId",
        value: organizationId,
        operator: "eq",
        connector: "AND"
      }, condition]
    });
    if (!existingRoleInDB) {
      ctx.context.logger.error(`[Dynamic Access Control] The role name/id does not exist in the database.`, {
        ..."roleName" in ctx.body ? { roleName: ctx.body.roleName } : { roleId: ctx.body.roleId },
        organizationId
      });
      throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.ROLE_NOT_FOUND });
    }
    existingRoleInDB.permission = JSON.parse(existingRoleInDB.permission);
    await ctx.context.adapter.delete({
      model: "organizationRole",
      where: [{
        field: "organizationId",
        value: organizationId,
        operator: "eq",
        connector: "AND"
      }, condition]
    });
    return ctx.json({ success: true });
  });
};
var listOrgRolesQuerySchema = object({ organizationId: string().optional().meta({ description: "The id of the organization to list roles for. If not provided, the user's active organization will be used." }) }).optional();
var listOrgRoles = (options) => {
  const { $ReturnAdditionalFields } = getAdditionalFields(options, false);
  return createAuthEndpoint("/organization/list-roles", {
    method: "GET",
    requireHeaders: true,
    use: [orgSessionMiddleware],
    query: listOrgRolesQuerySchema
  }, async (ctx) => {
    const { session, user } = ctx.context.session;
    const organizationId = ctx.query?.organizationId ?? session.activeOrganizationId;
    if (!organizationId) {
      ctx.context.logger.error(`[Dynamic Access Control] The session is missing an active organization id to list roles. Either set an active org id, or pass an organizationId in the request query.`);
      throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.NO_ACTIVE_ORGANIZATION });
    }
    const member = await ctx.context.adapter.findOne({
      model: "member",
      where: [{
        field: "organizationId",
        value: organizationId,
        operator: "eq",
        connector: "AND"
      }, {
        field: "userId",
        value: user.id,
        operator: "eq",
        connector: "AND"
      }]
    });
    if (!member) {
      ctx.context.logger.error(`[Dynamic Access Control] The user is not a member of the organization to list roles.`, {
        userId: user.id,
        organizationId
      });
      throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_A_MEMBER_OF_THIS_ORGANIZATION });
    }
    if (!await hasPermission2({
      options,
      organizationId,
      permissions: { ac: ["read"] },
      role: member.role
    }, ctx)) {
      ctx.context.logger.error(`[Dynamic Access Control] The user is not permitted to list roles.`, {
        userId: user.id,
        organizationId,
        role: member.role
      });
      throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_LIST_A_ROLE });
    }
    let roles = await ctx.context.adapter.findMany({
      model: "organizationRole",
      where: [{
        field: "organizationId",
        value: organizationId,
        operator: "eq",
        connector: "AND"
      }]
    });
    roles = roles.map((x) => ({
      ...x,
      permission: JSON.parse(x.permission)
    }));
    return ctx.json(roles);
  });
};
var getOrgRoleQuerySchema = object({ organizationId: string().optional().meta({ description: "The id of the organization to read a role for. If not provided, the user's active organization will be used." }) }).and(union([object({ roleName: string().nonempty().meta({ description: "The name of the role to read" }) }), object({ roleId: string().nonempty().meta({ description: "The id of the role to read" }) })])).optional();
var getOrgRole = (options) => {
  const { $ReturnAdditionalFields } = getAdditionalFields(options, false);
  return createAuthEndpoint("/organization/get-role", {
    method: "GET",
    requireHeaders: true,
    use: [orgSessionMiddleware],
    query: getOrgRoleQuerySchema,
    metadata: { $Infer: { query: {} } }
  }, async (ctx) => {
    const { session, user } = ctx.context.session;
    const organizationId = ctx.query?.organizationId ?? session.activeOrganizationId;
    if (!organizationId) {
      ctx.context.logger.error(`[Dynamic Access Control] The session is missing an active organization id to read a role. Either set an active org id, or pass an organizationId in the request query.`);
      throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.NO_ACTIVE_ORGANIZATION });
    }
    const member = await ctx.context.adapter.findOne({
      model: "member",
      where: [{
        field: "organizationId",
        value: organizationId,
        operator: "eq",
        connector: "AND"
      }, {
        field: "userId",
        value: user.id,
        operator: "eq",
        connector: "AND"
      }]
    });
    if (!member) {
      ctx.context.logger.error(`[Dynamic Access Control] The user is not a member of the organization to read a role.`, {
        userId: user.id,
        organizationId
      });
      throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_A_MEMBER_OF_THIS_ORGANIZATION });
    }
    if (!await hasPermission2({
      options,
      organizationId,
      permissions: { ac: ["read"] },
      role: member.role
    }, ctx)) {
      ctx.context.logger.error(`[Dynamic Access Control] The user is not permitted to read a role.`, {
        userId: user.id,
        organizationId,
        role: member.role
      });
      throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_READ_A_ROLE });
    }
    let condition;
    if (ctx.query.roleName) condition = {
      field: "role",
      value: ctx.query.roleName,
      operator: "eq",
      connector: "AND"
    };
    else if (ctx.query.roleId) condition = {
      field: "id",
      value: ctx.query.roleId,
      operator: "eq",
      connector: "AND"
    };
    else {
      ctx.context.logger.error(`[Dynamic Access Control] The role name/id is not provided in the request query.`);
      throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.ROLE_NOT_FOUND });
    }
    let role2 = await ctx.context.adapter.findOne({
      model: "organizationRole",
      where: [{
        field: "organizationId",
        value: organizationId,
        operator: "eq",
        connector: "AND"
      }, condition]
    });
    if (!role2) {
      ctx.context.logger.error(`[Dynamic Access Control] The role name/id does not exist in the database.`, {
        ..."roleName" in ctx.query ? { roleName: ctx.query.roleName } : { roleId: ctx.query.roleId },
        organizationId
      });
      throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.ROLE_NOT_FOUND });
    }
    role2.permission = JSON.parse(role2.permission);
    return ctx.json(role2);
  });
};
var roleNameOrIdSchema = union([object({ roleName: string().nonempty().meta({ description: "The name of the role to update" }) }), object({ roleId: string().nonempty().meta({ description: "The id of the role to update" }) })]);
var updateOrgRole = (options) => {
  const { additionalFieldsSchema, $AdditionalFields, $ReturnAdditionalFields } = getAdditionalFields(options, true);
  return createAuthEndpoint("/organization/update-role", {
    method: "POST",
    body: object({
      organizationId: string().optional().meta({ description: "The id of the organization to update the role in. If not provided, the user's active organization will be used." }),
      data: object({
        permission: record(string(), array(string())).optional().meta({ description: "The permission to update the role with" }),
        roleName: string().optional().meta({ description: "The name of the role to update" }),
        ...additionalFieldsSchema.shape
      })
    }).and(roleNameOrIdSchema),
    metadata: { $Infer: { body: {} } },
    requireHeaders: true,
    use: [orgSessionMiddleware]
  }, async (ctx) => {
    const { session, user } = ctx.context.session;
    const ac = options.ac;
    if (!ac) {
      ctx.context.logger.error(`[Dynamic Access Control] The organization plugin is missing a pre-defined ac instance.`, `
Please refer to the documentation here: https://better-auth.com/docs/plugins/organization#dynamic-access-control`);
      throw new APIError("NOT_IMPLEMENTED", { message: ORGANIZATION_ERROR_CODES.MISSING_AC_INSTANCE });
    }
    const organizationId = ctx.body.organizationId ?? session.activeOrganizationId;
    if (!organizationId) {
      ctx.context.logger.error(`[Dynamic Access Control] The session is missing an active organization id to update a role. Either set an active org id, or pass an organizationId in the request body.`);
      throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.NO_ACTIVE_ORGANIZATION });
    }
    const member = await ctx.context.adapter.findOne({
      model: "member",
      where: [{
        field: "organizationId",
        value: organizationId,
        operator: "eq",
        connector: "AND"
      }, {
        field: "userId",
        value: user.id,
        operator: "eq",
        connector: "AND"
      }]
    });
    if (!member) {
      ctx.context.logger.error(`[Dynamic Access Control] The user is not a member of the organization to update a role.`, {
        userId: user.id,
        organizationId
      });
      throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_A_MEMBER_OF_THIS_ORGANIZATION });
    }
    if (!await hasPermission2({
      options,
      organizationId,
      role: member.role,
      permissions: { ac: ["update"] }
    }, ctx)) {
      ctx.context.logger.error(`[Dynamic Access Control] The user is not permitted to update a role.`);
      throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_UPDATE_A_ROLE });
    }
    let condition;
    if (ctx.body.roleName) condition = {
      field: "role",
      value: ctx.body.roleName,
      operator: "eq",
      connector: "AND"
    };
    else if (ctx.body.roleId) condition = {
      field: "id",
      value: ctx.body.roleId,
      operator: "eq",
      connector: "AND"
    };
    else {
      ctx.context.logger.error(`[Dynamic Access Control] The role name/id is not provided in the request body.`);
      throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.ROLE_NOT_FOUND });
    }
    let role2 = await ctx.context.adapter.findOne({
      model: "organizationRole",
      where: [{
        field: "organizationId",
        value: organizationId,
        operator: "eq",
        connector: "AND"
      }, condition]
    });
    if (!role2) {
      ctx.context.logger.error(`[Dynamic Access Control] The role name/id does not exist in the database.`, {
        ..."roleName" in ctx.body ? { roleName: ctx.body.roleName } : { roleId: ctx.body.roleId },
        organizationId
      });
      throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.ROLE_NOT_FOUND });
    }
    role2.permission = role2.permission ? JSON.parse(role2.permission) : void 0;
    const { permission: _, roleName: __, ...additionalFields } = ctx.body.data;
    let updateData = { ...additionalFields };
    if (ctx.body.data.permission) {
      let newPermission = ctx.body.data.permission;
      await checkForInvalidResources({
        ac,
        ctx,
        permission: newPermission
      });
      await checkIfMemberHasPermission({
        ctx,
        member,
        options,
        organizationId,
        permissionRequired: newPermission,
        user,
        action: "update"
      });
      updateData.permission = newPermission;
    }
    if (ctx.body.data.roleName) {
      let newRoleName = ctx.body.data.roleName;
      newRoleName = normalizeRoleName(newRoleName);
      await checkIfRoleNameIsTakenByPreDefinedRole({
        role: newRoleName,
        organizationId,
        options,
        ctx
      });
      await checkIfRoleNameIsTakenByRoleInDB({
        role: newRoleName,
        organizationId,
        ctx
      });
      updateData.role = newRoleName;
    }
    const update = {
      ...updateData,
      ...updateData.permission ? { permission: JSON.stringify(updateData.permission) } : {}
    };
    await ctx.context.adapter.update({
      model: "organizationRole",
      where: [{
        field: "organizationId",
        value: organizationId,
        operator: "eq",
        connector: "AND"
      }, condition],
      update
    });
    return ctx.json({
      success: true,
      roleData: {
        ...role2,
        ...update,
        permission: updateData.permission || role2.permission || null
      }
    });
  });
};
async function checkForInvalidResources({ ac, ctx, permission }) {
  const validResources = Object.keys(ac.statements);
  const providedResources = Object.keys(permission);
  if (providedResources.some((r) => !validResources.includes(r))) {
    ctx.context.logger.error(`[Dynamic Access Control] The provided permission includes an invalid resource.`, {
      providedResources,
      validResources
    });
    throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.INVALID_RESOURCE });
  }
}
async function checkIfMemberHasPermission({ ctx, permissionRequired: permission, options, organizationId, member, user, action }) {
  const hasNecessaryPermissions = [];
  const permissionEntries = Object.entries(permission);
  for await (const [resource, permissions] of permissionEntries) for await (const perm of permissions) hasNecessaryPermissions.push({
    resource: { [resource]: [perm] },
    hasPermission: await hasPermission2({
      options,
      organizationId,
      permissions: { [resource]: [perm] },
      useMemoryCache: true,
      role: member.role
    }, ctx)
  });
  const missingPermissions = hasNecessaryPermissions.filter((x) => x.hasPermission === false).map((x) => {
    const key = Object.keys(x.resource)[0];
    return `${key}:${x.resource[key][0]}`;
  });
  if (missingPermissions.length > 0) {
    ctx.context.logger.error(`[Dynamic Access Control] The user is missing permissions necessary to ${action} a role with those set of permissions.
`, {
      userId: user.id,
      organizationId,
      role: member.role,
      missingPermissions
    });
    let errorMessage;
    if (action === "create") errorMessage = ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_CREATE_A_ROLE;
    else if (action === "update") errorMessage = ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_UPDATE_A_ROLE;
    else if (action === "delete") errorMessage = ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_DELETE_A_ROLE;
    else if (action === "read") errorMessage = ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_READ_A_ROLE;
    else if (action === "list") errorMessage = ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_LIST_A_ROLE;
    else errorMessage = ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_GET_A_ROLE;
    throw new APIError("FORBIDDEN", {
      message: errorMessage,
      missingPermissions
    });
  }
}
async function checkIfRoleNameIsTakenByPreDefinedRole({ options, organizationId, role: role2, ctx }) {
  const defaultRoles4 = options.roles ? Object.keys(options.roles) : [
    "owner",
    "admin",
    "member"
  ];
  if (defaultRoles4.includes(role2)) {
    ctx.context.logger.error(`[Dynamic Access Control] The role name "${role2}" is already taken by a pre-defined role.`, {
      role: role2,
      organizationId,
      defaultRoles: defaultRoles4
    });
    throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.ROLE_NAME_IS_ALREADY_TAKEN });
  }
}
async function checkIfRoleNameIsTakenByRoleInDB({ organizationId, role: role2, ctx }) {
  if (await ctx.context.adapter.findOne({
    model: "organizationRole",
    where: [{
      field: "organizationId",
      value: organizationId,
      operator: "eq",
      connector: "AND"
    }, {
      field: "role",
      value: role2,
      operator: "eq",
      connector: "AND"
    }]
  })) {
    ctx.context.logger.error(`[Dynamic Access Control] The role name "${role2}" is already taken by a role in the database.`, {
      role: role2,
      organizationId
    });
    throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.ROLE_NAME_IS_ALREADY_TAKEN });
  }
}

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/organization/routes/crud-invites.mjs
var baseInvitationSchema = object({
  email: string().meta({ description: "The email address of the user to invite" }),
  role: union([string().meta({ description: "The role to assign to the user" }), array(string().meta({ description: "The roles to assign to the user" }))]).meta({ description: 'The role(s) to assign to the user. It can be `admin`, `member`, owner. Eg: "member"' }),
  organizationId: string().meta({ description: "The organization ID to invite the user to" }).optional(),
  resend: boolean().meta({ description: "Resend the invitation email, if the user is already invited. Eg: true" }).optional(),
  teamId: union([string().meta({ description: "The team ID to invite the user to" }).optional(), array(string()).meta({ description: "The team IDs to invite the user to" }).optional()])
});
var createInvitation = (option) => {
  const additionalFieldsSchema = toZodSchema({
    fields: option?.schema?.invitation?.additionalFields || {},
    isClientSide: true
  });
  return createAuthEndpoint("/organization/invite-member", {
    method: "POST",
    requireHeaders: true,
    use: [orgMiddleware, orgSessionMiddleware],
    body: object({
      ...baseInvitationSchema.shape,
      ...additionalFieldsSchema.shape
    }),
    metadata: {
      $Infer: { body: {} },
      openapi: {
        operationId: "createOrganizationInvitation",
        description: "Create an invitation to an organization",
        responses: { "200": {
          description: "Success",
          content: { "application/json": { schema: {
            type: "object",
            properties: {
              id: { type: "string" },
              email: { type: "string" },
              role: { type: "string" },
              organizationId: { type: "string" },
              inviterId: { type: "string" },
              status: { type: "string" },
              expiresAt: { type: "string" },
              createdAt: { type: "string" }
            },
            required: [
              "id",
              "email",
              "role",
              "organizationId",
              "inviterId",
              "status",
              "expiresAt",
              "createdAt"
            ]
          } } }
        } }
      }
    }
  }, async (ctx) => {
    const session = ctx.context.session;
    const organizationId = ctx.body.organizationId || session.session.activeOrganizationId;
    if (!organizationId) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_NOT_FOUND });
    const email2 = ctx.body.email.toLowerCase();
    if (!email().safeParse(email2).success) throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.INVALID_EMAIL });
    const adapter = getOrgAdapter(ctx.context, option);
    const member = await adapter.findMemberByOrgId({
      userId: session.user.id,
      organizationId
    });
    if (!member) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.MEMBER_NOT_FOUND });
    if (!await hasPermission2({
      role: member.role,
      options: ctx.context.orgOptions,
      permissions: { invitation: ["create"] },
      organizationId
    }, ctx)) throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_INVITE_USERS_TO_THIS_ORGANIZATION });
    const creatorRole = ctx.context.orgOptions.creatorRole || "owner";
    const roles = parseRoles2(ctx.body.role);
    const rolesArray = roles.split(",").map((r) => r.trim()).filter(Boolean);
    const defaults = Object.keys(defaultRoles2);
    const customRoles = Object.keys(ctx.context.orgOptions.roles || {});
    const validStaticRoles = /* @__PURE__ */ new Set([...defaults, ...customRoles]);
    const unknownRoles = rolesArray.filter((role2) => !validStaticRoles.has(role2));
    if (unknownRoles.length > 0) if (ctx.context.orgOptions.dynamicAccessControl?.enabled) {
      const foundRoleNames = (await ctx.context.adapter.findMany({
        model: "organizationRole",
        where: [{
          field: "organizationId",
          value: organizationId
        }, {
          field: "role",
          value: unknownRoles,
          operator: "in"
        }]
      })).map((r) => r.role);
      const stillInvalid = unknownRoles.filter((r) => !foundRoleNames.includes(r));
      if (stillInvalid.length > 0) throw new APIError("BAD_REQUEST", { message: `${ORGANIZATION_ERROR_CODES.ROLE_NOT_FOUND}: ${stillInvalid.join(", ")}` });
    } else throw new APIError("BAD_REQUEST", { message: `${ORGANIZATION_ERROR_CODES.ROLE_NOT_FOUND}: ${unknownRoles.join(", ")}` });
    if (member.role !== creatorRole && roles.split(",").includes(creatorRole)) throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_INVITE_USER_WITH_THIS_ROLE });
    if (await adapter.findMemberByEmail({
      email: email2,
      organizationId
    })) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.USER_IS_ALREADY_A_MEMBER_OF_THIS_ORGANIZATION });
    const alreadyInvited = await adapter.findPendingInvitation({
      email: email2,
      organizationId
    });
    if (alreadyInvited.length && !ctx.body.resend) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.USER_IS_ALREADY_INVITED_TO_THIS_ORGANIZATION });
    const organization2 = await adapter.findOrganizationById(organizationId);
    if (!organization2) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_NOT_FOUND });
    if (alreadyInvited.length && ctx.body.resend) {
      const existingInvitation = alreadyInvited[0];
      const newExpiresAt = getDate(ctx.context.orgOptions.invitationExpiresIn || 3600 * 48, "sec");
      await ctx.context.adapter.update({
        model: "invitation",
        where: [{
          field: "id",
          value: existingInvitation.id
        }],
        update: { expiresAt: newExpiresAt }
      });
      const updatedInvitation = {
        ...existingInvitation,
        expiresAt: newExpiresAt
      };
      if (ctx.context.orgOptions.sendInvitationEmail) await ctx.context.runInBackgroundOrAwait(ctx.context.orgOptions.sendInvitationEmail({
        id: updatedInvitation.id,
        role: updatedInvitation.role,
        email: updatedInvitation.email.toLowerCase(),
        organization: organization2,
        inviter: {
          ...member,
          user: session.user
        },
        invitation: updatedInvitation
      }, ctx.request));
      return ctx.json(updatedInvitation);
    }
    if (alreadyInvited.length && ctx.context.orgOptions.cancelPendingInvitationsOnReInvite) await adapter.updateInvitation({
      invitationId: alreadyInvited[0].id,
      status: "canceled"
    });
    const invitationLimit = typeof ctx.context.orgOptions.invitationLimit === "function" ? await ctx.context.orgOptions.invitationLimit({
      user: session.user,
      organization: organization2,
      member
    }, ctx.context) : ctx.context.orgOptions.invitationLimit ?? 100;
    if ((await adapter.findPendingInvitations({ organizationId })).length >= invitationLimit) throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.INVITATION_LIMIT_REACHED });
    if (ctx.context.orgOptions.teams && ctx.context.orgOptions.teams.enabled && typeof ctx.context.orgOptions.teams.maximumMembersPerTeam !== "undefined" && "teamId" in ctx.body && ctx.body.teamId) {
      const teamIds$1 = typeof ctx.body.teamId === "string" ? [ctx.body.teamId] : ctx.body.teamId;
      for (const teamId of teamIds$1) {
        const team = await adapter.findTeamById({
          teamId,
          organizationId,
          includeTeamMembers: true
        });
        if (!team) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.TEAM_NOT_FOUND });
        const maximumMembersPerTeam = typeof ctx.context.orgOptions.teams.maximumMembersPerTeam === "function" ? await ctx.context.orgOptions.teams.maximumMembersPerTeam({
          teamId,
          session,
          organizationId
        }) : ctx.context.orgOptions.teams.maximumMembersPerTeam;
        if (team.members.length >= maximumMembersPerTeam) throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.TEAM_MEMBER_LIMIT_REACHED });
      }
    }
    const teamIds = "teamId" in ctx.body ? typeof ctx.body.teamId === "string" ? [ctx.body.teamId] : ctx.body.teamId ?? [] : [];
    const { email: _, role: __, organizationId: ___, resend: ____, ...additionalFields } = ctx.body;
    let invitationData = {
      role: roles,
      email: email2,
      organizationId,
      teamIds,
      ...additionalFields ? additionalFields : {}
    };
    if (option?.organizationHooks?.beforeCreateInvitation) {
      const response = await option?.organizationHooks.beforeCreateInvitation({
        invitation: {
          ...invitationData,
          inviterId: session.user.id,
          teamId: teamIds.length > 0 ? teamIds[0] : void 0
        },
        inviter: session.user,
        organization: organization2
      });
      if (response && typeof response === "object" && "data" in response) invitationData = {
        ...invitationData,
        ...response.data
      };
    }
    const invitation = await adapter.createInvitation({
      invitation: invitationData,
      user: session.user
    });
    if (ctx.context.orgOptions.sendInvitationEmail) await ctx.context.runInBackgroundOrAwait(ctx.context.orgOptions.sendInvitationEmail({
      id: invitation.id,
      role: invitation.role,
      email: invitation.email.toLowerCase(),
      organization: organization2,
      inviter: {
        ...member,
        user: session.user
      },
      invitation
    }, ctx.request));
    if (option?.organizationHooks?.afterCreateInvitation) await option?.organizationHooks.afterCreateInvitation({
      invitation,
      inviter: session.user,
      organization: organization2
    });
    return ctx.json(invitation);
  });
};
var acceptInvitationBodySchema = object({ invitationId: string().meta({ description: "The ID of the invitation to accept" }) });
var acceptInvitation = (options) => createAuthEndpoint("/organization/accept-invitation", {
  method: "POST",
  body: acceptInvitationBodySchema,
  requireHeaders: true,
  use: [orgMiddleware, orgSessionMiddleware],
  metadata: { openapi: {
    description: "Accept an invitation to an organization",
    responses: { "200": {
      description: "Success",
      content: { "application/json": { schema: {
        type: "object",
        properties: {
          invitation: { type: "object" },
          member: { type: "object" }
        }
      } } }
    } }
  } }
}, async (ctx) => {
  const session = ctx.context.session;
  const adapter = getOrgAdapter(ctx.context, options);
  const invitation = await adapter.findInvitationById(ctx.body.invitationId);
  if (!invitation || invitation.expiresAt < /* @__PURE__ */ new Date() || invitation.status !== "pending") throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.INVITATION_NOT_FOUND });
  if (invitation.email.toLowerCase() !== session.user.email.toLowerCase()) throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_THE_RECIPIENT_OF_THE_INVITATION });
  if (ctx.context.orgOptions.requireEmailVerificationOnInvitation && !session.user.emailVerified) throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.EMAIL_VERIFICATION_REQUIRED_BEFORE_ACCEPTING_OR_REJECTING_INVITATION });
  const membershipLimit = ctx.context.orgOptions?.membershipLimit || 100;
  if (await adapter.countMembers({ organizationId: invitation.organizationId }) >= membershipLimit) throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_MEMBERSHIP_LIMIT_REACHED });
  const organization2 = await adapter.findOrganizationById(invitation.organizationId);
  if (!organization2) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_NOT_FOUND });
  if (options?.organizationHooks?.beforeAcceptInvitation) await options?.organizationHooks.beforeAcceptInvitation({
    invitation,
    user: session.user,
    organization: organization2
  });
  const acceptedI = await adapter.updateInvitation({
    invitationId: ctx.body.invitationId,
    status: "accepted"
  });
  if (!acceptedI) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.FAILED_TO_RETRIEVE_INVITATION });
  if (ctx.context.orgOptions.teams && ctx.context.orgOptions.teams.enabled && "teamId" in acceptedI && acceptedI.teamId) {
    const teamIds = acceptedI.teamId.split(",");
    const onlyOne = teamIds.length === 1;
    for (const teamId of teamIds) {
      await adapter.findOrCreateTeamMember({
        teamId,
        userId: session.user.id
      });
      if (typeof ctx.context.orgOptions.teams.maximumMembersPerTeam !== "undefined") {
        if (await adapter.countTeamMembers({ teamId }) >= (typeof ctx.context.orgOptions.teams.maximumMembersPerTeam === "function" ? await ctx.context.orgOptions.teams.maximumMembersPerTeam({
          teamId,
          session,
          organizationId: invitation.organizationId
        }) : ctx.context.orgOptions.teams.maximumMembersPerTeam)) throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.TEAM_MEMBER_LIMIT_REACHED });
      }
    }
    if (onlyOne) {
      const teamId = teamIds[0];
      await setSessionCookie(ctx, {
        session: await adapter.setActiveTeam(session.session.token, teamId, ctx),
        user: session.user
      });
    }
  }
  const member = await adapter.createMember({
    organizationId: invitation.organizationId,
    userId: session.user.id,
    role: invitation.role,
    createdAt: /* @__PURE__ */ new Date()
  });
  await adapter.setActiveOrganization(session.session.token, invitation.organizationId, ctx);
  if (!acceptedI) return ctx.json(null, {
    status: 400,
    body: { message: ORGANIZATION_ERROR_CODES.INVITATION_NOT_FOUND }
  });
  if (options?.organizationHooks?.afterAcceptInvitation) await options?.organizationHooks.afterAcceptInvitation({
    invitation: acceptedI,
    member,
    user: session.user,
    organization: organization2
  });
  return ctx.json({
    invitation: acceptedI,
    member
  });
});
var rejectInvitationBodySchema = object({ invitationId: string().meta({ description: "The ID of the invitation to reject" }) });
var rejectInvitation = (options) => createAuthEndpoint("/organization/reject-invitation", {
  method: "POST",
  body: rejectInvitationBodySchema,
  requireHeaders: true,
  use: [orgMiddleware, orgSessionMiddleware],
  metadata: { openapi: {
    description: "Reject an invitation to an organization",
    responses: { "200": {
      description: "Success",
      content: { "application/json": { schema: {
        type: "object",
        properties: {
          invitation: { type: "object" },
          member: {
            type: "object",
            nullable: true
          }
        }
      } } }
    } }
  } }
}, async (ctx) => {
  const session = ctx.context.session;
  const adapter = getOrgAdapter(ctx.context, ctx.context.orgOptions);
  const invitation = await adapter.findInvitationById(ctx.body.invitationId);
  if (!invitation || invitation.expiresAt < /* @__PURE__ */ new Date() || invitation.status !== "pending") throw new APIError("BAD_REQUEST", { message: "Invitation not found!" });
  if (invitation.email.toLowerCase() !== session.user.email.toLowerCase()) throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_THE_RECIPIENT_OF_THE_INVITATION });
  if (ctx.context.orgOptions.requireEmailVerificationOnInvitation && !session.user.emailVerified) throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.EMAIL_VERIFICATION_REQUIRED_BEFORE_ACCEPTING_OR_REJECTING_INVITATION });
  const organization2 = await adapter.findOrganizationById(invitation.organizationId);
  if (!organization2) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_NOT_FOUND });
  if (options?.organizationHooks?.beforeRejectInvitation) await options?.organizationHooks.beforeRejectInvitation({
    invitation,
    user: session.user,
    organization: organization2
  });
  const rejectedI = await adapter.updateInvitation({
    invitationId: ctx.body.invitationId,
    status: "rejected"
  });
  if (options?.organizationHooks?.afterRejectInvitation) await options?.organizationHooks.afterRejectInvitation({
    invitation: rejectedI || invitation,
    user: session.user,
    organization: organization2
  });
  return ctx.json({
    invitation: rejectedI,
    member: null
  });
});
var cancelInvitationBodySchema = object({ invitationId: string().meta({ description: "The ID of the invitation to cancel" }) });
var cancelInvitation = (options) => createAuthEndpoint("/organization/cancel-invitation", {
  method: "POST",
  body: cancelInvitationBodySchema,
  requireHeaders: true,
  use: [orgMiddleware, orgSessionMiddleware],
  openapi: {
    operationId: "cancelOrganizationInvitation",
    description: "Cancel an invitation to an organization",
    responses: { "200": {
      description: "Success",
      content: { "application/json": { schema: {
        type: "object",
        properties: { invitation: { type: "object" } }
      } } }
    } }
  }
}, async (ctx) => {
  const session = ctx.context.session;
  const adapter = getOrgAdapter(ctx.context, options);
  const invitation = await adapter.findInvitationById(ctx.body.invitationId);
  if (!invitation) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.INVITATION_NOT_FOUND });
  const member = await adapter.findMemberByOrgId({
    userId: session.user.id,
    organizationId: invitation.organizationId
  });
  if (!member) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.MEMBER_NOT_FOUND });
  if (!await hasPermission2({
    role: member.role,
    options: ctx.context.orgOptions,
    permissions: { invitation: ["cancel"] },
    organizationId: invitation.organizationId
  }, ctx)) throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_CANCEL_THIS_INVITATION });
  const organization2 = await adapter.findOrganizationById(invitation.organizationId);
  if (!organization2) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_NOT_FOUND });
  if (options?.organizationHooks?.beforeCancelInvitation) await options?.organizationHooks.beforeCancelInvitation({
    invitation,
    cancelledBy: session.user,
    organization: organization2
  });
  const canceledI = await adapter.updateInvitation({
    invitationId: ctx.body.invitationId,
    status: "canceled"
  });
  if (options?.organizationHooks?.afterCancelInvitation) await options?.organizationHooks.afterCancelInvitation({
    invitation: canceledI || invitation,
    cancelledBy: session.user,
    organization: organization2
  });
  return ctx.json(canceledI);
});
var getInvitationQuerySchema = object({ id: string().meta({ description: "The ID of the invitation to get" }) });
var getInvitation = (options) => createAuthEndpoint("/organization/get-invitation", {
  method: "GET",
  use: [orgMiddleware],
  requireHeaders: true,
  query: getInvitationQuerySchema,
  metadata: { openapi: {
    description: "Get an invitation by ID",
    responses: { "200": {
      description: "Success",
      content: { "application/json": { schema: {
        type: "object",
        properties: {
          id: { type: "string" },
          email: { type: "string" },
          role: { type: "string" },
          organizationId: { type: "string" },
          inviterId: { type: "string" },
          status: { type: "string" },
          expiresAt: { type: "string" },
          organizationName: { type: "string" },
          organizationSlug: { type: "string" },
          inviterEmail: { type: "string" }
        },
        required: [
          "id",
          "email",
          "role",
          "organizationId",
          "inviterId",
          "status",
          "expiresAt",
          "organizationName",
          "organizationSlug",
          "inviterEmail"
        ]
      } } }
    } }
  } }
}, async (ctx) => {
  const session = await getSessionFromCtx(ctx);
  if (!session) throw new APIError("UNAUTHORIZED", { message: "Not authenticated" });
  const adapter = getOrgAdapter(ctx.context, options);
  const invitation = await adapter.findInvitationById(ctx.query.id);
  if (!invitation || invitation.status !== "pending" || invitation.expiresAt < /* @__PURE__ */ new Date()) throw new APIError("BAD_REQUEST", { message: "Invitation not found!" });
  if (invitation.email.toLowerCase() !== session.user.email.toLowerCase()) throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_THE_RECIPIENT_OF_THE_INVITATION });
  const organization2 = await adapter.findOrganizationById(invitation.organizationId);
  if (!organization2) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_NOT_FOUND });
  const member = await adapter.findMemberByOrgId({
    userId: invitation.inviterId,
    organizationId: invitation.organizationId
  });
  if (!member) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.INVITER_IS_NO_LONGER_A_MEMBER_OF_THE_ORGANIZATION });
  return ctx.json({
    ...invitation,
    organizationName: organization2.name,
    organizationSlug: organization2.slug,
    inviterEmail: member.user.email
  });
});
var listInvitationQuerySchema = object({ organizationId: string().meta({ description: "The ID of the organization to list invitations for" }).optional() }).optional();
var listInvitations = (options) => createAuthEndpoint("/organization/list-invitations", {
  method: "GET",
  requireHeaders: true,
  use: [orgMiddleware, orgSessionMiddleware],
  query: listInvitationQuerySchema
}, async (ctx) => {
  const session = await getSessionFromCtx(ctx);
  if (!session) throw new APIError("UNAUTHORIZED", { message: "Not authenticated" });
  const orgId = ctx.query?.organizationId || session.session.activeOrganizationId;
  if (!orgId) throw new APIError("BAD_REQUEST", { message: "Organization ID is required" });
  const adapter = getOrgAdapter(ctx.context, options);
  if (!await adapter.findMemberByOrgId({
    userId: session.user.id,
    organizationId: orgId
  })) throw new APIError("FORBIDDEN", { message: "You are not a member of this organization" });
  const invitations = await adapter.listInvitations({ organizationId: orgId });
  return ctx.json(invitations);
});
var listUserInvitations = (options) => createAuthEndpoint("/organization/list-user-invitations", {
  method: "GET",
  use: [orgMiddleware],
  query: object({ email: string().meta({ description: "The email of the user to list invitations for. This only works for server side API calls." }).optional() }).optional(),
  metadata: { openapi: {
    description: "List all invitations a user has received",
    responses: { "200": {
      description: "Success",
      content: { "application/json": { schema: {
        type: "array",
        items: {
          type: "object",
          properties: {
            id: { type: "string" },
            email: { type: "string" },
            role: { type: "string" },
            organizationId: { type: "string" },
            organizationName: { type: "string" },
            inviterId: {
              type: "string",
              description: "The ID of the user who created the invitation"
            },
            teamId: {
              type: "string",
              description: "The ID of the team associated with the invitation",
              nullable: true
            },
            status: { type: "string" },
            expiresAt: { type: "string" },
            createdAt: { type: "string" }
          },
          required: [
            "id",
            "email",
            "role",
            "organizationId",
            "organizationName",
            "inviterId",
            "status",
            "expiresAt",
            "createdAt"
          ]
        }
      } } }
    } }
  } }
}, async (ctx) => {
  const session = await getSessionFromCtx(ctx);
  if (ctx.request && ctx.query?.email) throw new APIError("BAD_REQUEST", { message: "User email cannot be passed for client side API calls." });
  const userEmail = session?.user.email || ctx.query?.email;
  if (!userEmail) throw new APIError("BAD_REQUEST", { message: "Missing session headers, or email query parameter." });
  const invitations = await getOrgAdapter(ctx.context, options).listUserInvitations(userEmail);
  return ctx.json(invitations);
});

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/organization/routes/crud-members.mjs
var baseMemberSchema = object({
  userId: coerce_exports.string().meta({ description: 'The user Id which represents the user to be added as a member. If `null` is provided, then it\'s expected to provide session headers. Eg: "user-id"' }),
  role: union([string(), array(string())]).meta({ description: 'The role(s) to assign to the new member. Eg: ["admin", "sale"]' }),
  organizationId: string().meta({ description: `An optional organization ID to pass. If not provided, will default to the user's active organization. Eg: "org-id"` }).optional(),
  teamId: string().meta({ description: 'An optional team ID to add the member to. Eg: "team-id"' }).optional()
});
var addMember = (option) => {
  const additionalFieldsSchema = toZodSchema({
    fields: option?.schema?.member?.additionalFields || {},
    isClientSide: true
  });
  return createAuthEndpoint({
    method: "POST",
    body: object({
      ...baseMemberSchema.shape,
      ...additionalFieldsSchema.shape
    }),
    use: [orgMiddleware],
    metadata: {
      $Infer: { body: {} },
      openapi: {
        operationId: "addOrganizationMember",
        description: "Add a member to an organization"
      }
    }
  }, async (ctx) => {
    const session = ctx.body.userId ? await getSessionFromCtx(ctx).catch((e) => null) : null;
    const orgId = ctx.body.organizationId || session?.session.activeOrganizationId;
    if (!orgId) return ctx.json(null, {
      status: 400,
      body: { message: ORGANIZATION_ERROR_CODES.NO_ACTIVE_ORGANIZATION }
    });
    const teamId = "teamId" in ctx.body ? ctx.body.teamId : void 0;
    if (teamId && !ctx.context.orgOptions.teams?.enabled) {
      ctx.context.logger.error("Teams are not enabled");
      throw new APIError("BAD_REQUEST", { message: "Teams are not enabled" });
    }
    const adapter = getOrgAdapter(ctx.context, option);
    const user = await ctx.context.internalAdapter.findUserById(ctx.body.userId);
    if (!user) throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.USER_NOT_FOUND });
    if (await adapter.findMemberByEmail({
      email: user.email,
      organizationId: orgId
    })) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.USER_IS_ALREADY_A_MEMBER_OF_THIS_ORGANIZATION });
    if (teamId) {
      const team = await adapter.findTeamById({
        teamId,
        organizationId: orgId
      });
      if (!team || team.organizationId !== orgId) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.TEAM_NOT_FOUND });
    }
    const membershipLimit = ctx.context.orgOptions?.membershipLimit || 100;
    if (await adapter.countMembers({ organizationId: orgId }) >= membershipLimit) throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_MEMBERSHIP_LIMIT_REACHED });
    const { role: _, userId: __, organizationId: ___, ...additionalFields } = ctx.body;
    const organization2 = await adapter.findOrganizationById(orgId);
    if (!organization2) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_NOT_FOUND });
    let memberData = {
      organizationId: orgId,
      userId: user.id,
      role: parseRoles2(ctx.body.role),
      createdAt: /* @__PURE__ */ new Date(),
      ...additionalFields ? additionalFields : {}
    };
    if (option?.organizationHooks?.beforeAddMember) {
      const response = await option?.organizationHooks.beforeAddMember({
        member: {
          userId: user.id,
          organizationId: orgId,
          role: parseRoles2(ctx.body.role),
          ...additionalFields
        },
        user,
        organization: organization2
      });
      if (response && typeof response === "object" && "data" in response) memberData = {
        ...memberData,
        ...response.data
      };
    }
    const createdMember = await adapter.createMember(memberData);
    if (teamId) await adapter.findOrCreateTeamMember({
      userId: user.id,
      teamId
    });
    if (option?.organizationHooks?.afterAddMember) await option?.organizationHooks.afterAddMember({
      member: createdMember,
      user,
      organization: organization2
    });
    return ctx.json(createdMember);
  });
};
var removeMemberBodySchema = object({
  memberIdOrEmail: string().meta({ description: "The ID or email of the member to remove" }),
  organizationId: string().meta({ description: 'The ID of the organization to remove the member from. If not provided, the active organization will be used. Eg: "org-id"' }).optional()
});
var removeMember = (options) => createAuthEndpoint("/organization/remove-member", {
  method: "POST",
  body: removeMemberBodySchema,
  requireHeaders: true,
  use: [orgMiddleware, orgSessionMiddleware],
  metadata: { openapi: {
    description: "Remove a member from an organization",
    responses: { "200": {
      description: "Success",
      content: { "application/json": { schema: {
        type: "object",
        properties: { member: {
          type: "object",
          properties: {
            id: { type: "string" },
            userId: { type: "string" },
            organizationId: { type: "string" },
            role: { type: "string" }
          },
          required: [
            "id",
            "userId",
            "organizationId",
            "role"
          ]
        } },
        required: ["member"]
      } } }
    } }
  } }
}, async (ctx) => {
  const session = ctx.context.session;
  const organizationId = ctx.body.organizationId || session.session.activeOrganizationId;
  if (!organizationId) return ctx.json(null, {
    status: 400,
    body: { message: ORGANIZATION_ERROR_CODES.NO_ACTIVE_ORGANIZATION }
  });
  const adapter = getOrgAdapter(ctx.context, options);
  const member = await adapter.findMemberByOrgId({
    userId: session.user.id,
    organizationId
  });
  if (!member) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.MEMBER_NOT_FOUND });
  let toBeRemovedMember = null;
  if (ctx.body.memberIdOrEmail.includes("@")) toBeRemovedMember = await adapter.findMemberByEmail({
    email: ctx.body.memberIdOrEmail,
    organizationId
  });
  else {
    const result = await adapter.findMemberById(ctx.body.memberIdOrEmail);
    if (!result) toBeRemovedMember = null;
    else {
      const { user: _user, ...member$1 } = result;
      toBeRemovedMember = member$1;
    }
  }
  if (!toBeRemovedMember) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.MEMBER_NOT_FOUND });
  const roles = toBeRemovedMember.role.split(",");
  const creatorRole = ctx.context.orgOptions?.creatorRole || "owner";
  if (roles.includes(creatorRole)) {
    if (member.role !== creatorRole) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.YOU_CANNOT_LEAVE_THE_ORGANIZATION_AS_THE_ONLY_OWNER });
    const { members } = await adapter.listMembers({ organizationId });
    if (members.filter((member$1) => {
      return member$1.role.split(",").includes(creatorRole);
    }).length <= 1) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.YOU_CANNOT_LEAVE_THE_ORGANIZATION_AS_THE_ONLY_OWNER });
  }
  if (!await hasPermission2({
    role: member.role,
    options: ctx.context.orgOptions,
    permissions: { member: ["delete"] },
    organizationId
  }, ctx)) throw new APIError("UNAUTHORIZED", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_DELETE_THIS_MEMBER });
  if (toBeRemovedMember?.organizationId !== organizationId) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.MEMBER_NOT_FOUND });
  const organization2 = await adapter.findOrganizationById(organizationId);
  if (!organization2) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_NOT_FOUND });
  const userBeingRemoved = await ctx.context.internalAdapter.findUserById(toBeRemovedMember.userId);
  if (!userBeingRemoved) throw new APIError("BAD_REQUEST", { message: "User not found" });
  if (options?.organizationHooks?.beforeRemoveMember) await options?.organizationHooks.beforeRemoveMember({
    member: toBeRemovedMember,
    user: userBeingRemoved,
    organization: organization2
  });
  await adapter.deleteMember({
    memberId: toBeRemovedMember.id,
    organizationId,
    userId: toBeRemovedMember.userId
  });
  if (session.user.id === toBeRemovedMember.userId && session.session.activeOrganizationId === toBeRemovedMember.organizationId) await adapter.setActiveOrganization(session.session.token, null, ctx);
  if (options?.organizationHooks?.afterRemoveMember) await options?.organizationHooks.afterRemoveMember({
    member: toBeRemovedMember,
    user: userBeingRemoved,
    organization: organization2
  });
  return ctx.json({ member: toBeRemovedMember });
});
var updateMemberRoleBodySchema = object({
  role: union([string(), array(string())]).meta({ description: 'The new role to be applied. This can be a string or array of strings representing the roles. Eg: ["admin", "sale"]' }),
  memberId: string().meta({ description: 'The member id to apply the role update to. Eg: "member-id"' }),
  organizationId: string().meta({ description: 'An optional organization ID which the member is a part of to apply the role update. If not provided, you must provide session headers to get the active organization. Eg: "organization-id"' }).optional()
});
var updateMemberRole = (option) => createAuthEndpoint("/organization/update-member-role", {
  method: "POST",
  body: updateMemberRoleBodySchema,
  use: [orgMiddleware, orgSessionMiddleware],
  requireHeaders: true,
  metadata: {
    $Infer: { body: {} },
    openapi: {
      operationId: "updateOrganizationMemberRole",
      description: "Update the role of a member in an organization",
      responses: { "200": {
        description: "Success",
        content: { "application/json": { schema: {
          type: "object",
          properties: { member: {
            type: "object",
            properties: {
              id: { type: "string" },
              userId: { type: "string" },
              organizationId: { type: "string" },
              role: { type: "string" }
            },
            required: [
              "id",
              "userId",
              "organizationId",
              "role"
            ]
          } },
          required: ["member"]
        } } }
      } }
    }
  }
}, async (ctx) => {
  const session = ctx.context.session;
  if (!ctx.body.role) throw new APIError("BAD_REQUEST");
  const organizationId = ctx.body.organizationId || session.session.activeOrganizationId;
  if (!organizationId) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.NO_ACTIVE_ORGANIZATION });
  const adapter = getOrgAdapter(ctx.context, ctx.context.orgOptions);
  const roleToSet = Array.isArray(ctx.body.role) ? ctx.body.role : ctx.body.role ? [ctx.body.role] : [];
  const member = await adapter.findMemberByOrgId({
    userId: session.user.id,
    organizationId
  });
  if (!member) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.MEMBER_NOT_FOUND });
  const toBeUpdatedMember = member.id !== ctx.body.memberId ? await adapter.findMemberById(ctx.body.memberId) : member;
  if (!toBeUpdatedMember) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.MEMBER_NOT_FOUND });
  if (!(toBeUpdatedMember.organizationId === organizationId)) throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_UPDATE_THIS_MEMBER });
  const creatorRole = ctx.context.orgOptions?.creatorRole || "owner";
  const updatingMemberRoles = member.role.split(",");
  const isUpdatingCreator = toBeUpdatedMember.role.split(",").includes(creatorRole);
  const updaterIsCreator = updatingMemberRoles.includes(creatorRole);
  const isSettingCreatorRole = roleToSet.includes(creatorRole);
  const memberIsUpdatingThemselves = member.id === toBeUpdatedMember.id;
  if (isUpdatingCreator && !updaterIsCreator || isSettingCreatorRole && !updaterIsCreator) throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_UPDATE_THIS_MEMBER });
  if (updaterIsCreator && memberIsUpdatingThemselves) {
    if ((await ctx.context.adapter.findMany({
      model: "member",
      where: [{
        field: "organizationId",
        value: organizationId
      }]
    })).filter((member$1) => {
      return member$1.role.split(",").includes(creatorRole);
    }).length <= 1 && !isSettingCreatorRole) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.YOU_CANNOT_LEAVE_THE_ORGANIZATION_WITHOUT_AN_OWNER });
  }
  if (!await hasPermission2({
    role: member.role,
    options: ctx.context.orgOptions,
    permissions: { member: ["update"] },
    allowCreatorAllPermissions: true,
    organizationId
  }, ctx)) throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_UPDATE_THIS_MEMBER });
  const organization2 = await adapter.findOrganizationById(organizationId);
  if (!organization2) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_NOT_FOUND });
  const userBeingUpdated = await ctx.context.internalAdapter.findUserById(toBeUpdatedMember.userId);
  if (!userBeingUpdated) throw new APIError("BAD_REQUEST", { message: "User not found" });
  const previousRole = toBeUpdatedMember.role;
  const newRole = parseRoles2(ctx.body.role);
  if (option?.organizationHooks?.beforeUpdateMemberRole) {
    const response = await option?.organizationHooks.beforeUpdateMemberRole({
      member: toBeUpdatedMember,
      newRole,
      user: userBeingUpdated,
      organization: organization2
    });
    if (response && typeof response === "object" && "data" in response) {
      const updatedMember$1 = await adapter.updateMember(ctx.body.memberId, response.data.role || newRole);
      if (!updatedMember$1) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.MEMBER_NOT_FOUND });
      if (option?.organizationHooks?.afterUpdateMemberRole) await option?.organizationHooks.afterUpdateMemberRole({
        member: updatedMember$1,
        previousRole,
        user: userBeingUpdated,
        organization: organization2
      });
      return ctx.json(updatedMember$1);
    }
  }
  const updatedMember = await adapter.updateMember(ctx.body.memberId, newRole);
  if (!updatedMember) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.MEMBER_NOT_FOUND });
  if (option?.organizationHooks?.afterUpdateMemberRole) await option?.organizationHooks.afterUpdateMemberRole({
    member: updatedMember,
    previousRole,
    user: userBeingUpdated,
    organization: organization2
  });
  return ctx.json(updatedMember);
});
var getActiveMember = (options) => createAuthEndpoint("/organization/get-active-member", {
  method: "GET",
  use: [orgMiddleware, orgSessionMiddleware],
  requireHeaders: true,
  metadata: { openapi: {
    description: "Get the member details of the active organization",
    responses: { "200": {
      description: "Success",
      content: { "application/json": { schema: {
        type: "object",
        properties: {
          id: { type: "string" },
          userId: { type: "string" },
          organizationId: { type: "string" },
          role: { type: "string" }
        },
        required: [
          "id",
          "userId",
          "organizationId",
          "role"
        ]
      } } }
    } }
  } }
}, async (ctx) => {
  const session = ctx.context.session;
  const organizationId = session.session.activeOrganizationId;
  if (!organizationId) return ctx.json(null, {
    status: 400,
    body: { message: ORGANIZATION_ERROR_CODES.NO_ACTIVE_ORGANIZATION }
  });
  const member = await getOrgAdapter(ctx.context, options).findMemberByOrgId({
    userId: session.user.id,
    organizationId
  });
  if (!member) return ctx.json(null, {
    status: 400,
    body: { message: ORGANIZATION_ERROR_CODES.MEMBER_NOT_FOUND }
  });
  return ctx.json(member);
});
var leaveOrganizationBodySchema = object({ organizationId: string().meta({ description: 'The organization Id for the member to leave. Eg: "organization-id"' }) });
var leaveOrganization = (options) => createAuthEndpoint("/organization/leave", {
  method: "POST",
  body: leaveOrganizationBodySchema,
  requireHeaders: true,
  use: [sessionMiddleware, orgMiddleware]
}, async (ctx) => {
  const session = ctx.context.session;
  const adapter = getOrgAdapter(ctx.context, options);
  const member = await adapter.findMemberByOrgId({
    userId: session.user.id,
    organizationId: ctx.body.organizationId
  });
  if (!member) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.MEMBER_NOT_FOUND });
  const creatorRole = ctx.context.orgOptions?.creatorRole || "owner";
  if (member.role.split(",").includes(creatorRole)) {
    if ((await ctx.context.adapter.findMany({
      model: "member",
      where: [{
        field: "organizationId",
        value: ctx.body.organizationId
      }]
    })).filter((member$1) => member$1.role.split(",").includes(creatorRole)).length <= 1) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.YOU_CANNOT_LEAVE_THE_ORGANIZATION_AS_THE_ONLY_OWNER });
  }
  await adapter.deleteMember({
    memberId: member.id,
    organizationId: ctx.body.organizationId,
    userId: session.user.id
  });
  if (session.session.activeOrganizationId === ctx.body.organizationId) await adapter.setActiveOrganization(session.session.token, null, ctx);
  return ctx.json(member);
});
var listMembers = (options) => createAuthEndpoint("/organization/list-members", {
  method: "GET",
  query: object({
    limit: string().meta({ description: "The number of users to return" }).or(number()).optional(),
    offset: string().meta({ description: "The offset to start from" }).or(number()).optional(),
    sortBy: string().meta({ description: "The field to sort by" }).optional(),
    sortDirection: _enum(["asc", "desc"]).meta({ description: "The direction to sort by" }).optional(),
    filterField: string().meta({ description: "The field to filter by" }).optional(),
    filterValue: string().meta({ description: "The value to filter by" }).or(number()).or(boolean()).optional(),
    filterOperator: _enum([
      "eq",
      "ne",
      "lt",
      "lte",
      "gt",
      "gte",
      "contains"
    ]).meta({ description: "The operator to use for the filter" }).optional(),
    organizationId: string().meta({ description: `The organization ID to list members for. If not provided, will default to the user's active organization. Eg: "organization-id"` }).optional(),
    organizationSlug: string().meta({ description: `The organization slug to list members for. If not provided, will default to the user's active organization. Eg: "organization-slug"` }).optional()
  }).optional(),
  requireHeaders: true,
  use: [orgMiddleware, orgSessionMiddleware]
}, async (ctx) => {
  const session = ctx.context.session;
  let organizationId = ctx.query?.organizationId || session.session.activeOrganizationId;
  const adapter = getOrgAdapter(ctx.context, options);
  if (ctx.query?.organizationSlug) {
    const organization2 = await adapter.findOrganizationBySlug(ctx.query?.organizationSlug);
    if (!organization2) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_NOT_FOUND });
    organizationId = organization2.id;
  }
  if (!organizationId) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.NO_ACTIVE_ORGANIZATION });
  if (!await adapter.findMemberByOrgId({
    userId: session.user.id,
    organizationId
  })) throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_A_MEMBER_OF_THIS_ORGANIZATION });
  const { members, total } = await adapter.listMembers({
    organizationId,
    limit: ctx.query?.limit ? Number(ctx.query.limit) : void 0,
    offset: ctx.query?.offset ? Number(ctx.query.offset) : void 0,
    sortBy: ctx.query?.sortBy,
    sortOrder: ctx.query?.sortDirection,
    filter: ctx.query?.filterField ? {
      field: ctx.query?.filterField,
      operator: ctx.query.filterOperator,
      value: ctx.query.filterValue
    } : void 0
  });
  return ctx.json({
    members,
    total
  });
});
var getActiveMemberRoleQuerySchema = object({
  userId: string().meta({ description: "The user ID to get the role for. If not provided, will default to the current user's" }).optional(),
  organizationId: string().meta({ description: `The organization ID to list members for. If not provided, will default to the user's active organization. Eg: "organization-id"` }).optional(),
  organizationSlug: string().meta({ description: `The organization slug to list members for. If not provided, will default to the user's active organization. Eg: "organization-slug"` }).optional()
}).optional();
var getActiveMemberRole = (options) => createAuthEndpoint("/organization/get-active-member-role", {
  method: "GET",
  query: getActiveMemberRoleQuerySchema,
  requireHeaders: true,
  use: [orgMiddleware, orgSessionMiddleware]
}, async (ctx) => {
  const session = ctx.context.session;
  let organizationId = ctx.query?.organizationId || session.session.activeOrganizationId;
  const adapter = getOrgAdapter(ctx.context, options);
  if (ctx.query?.organizationSlug) {
    const organization2 = await adapter.findOrganizationBySlug(ctx.query?.organizationSlug);
    if (!organization2) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_NOT_FOUND });
    organizationId = organization2.id;
  }
  if (!organizationId) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.NO_ACTIVE_ORGANIZATION });
  const isMember = await adapter.findMemberByOrgId({
    userId: session.user.id,
    organizationId
  });
  if (!isMember) throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_A_MEMBER_OF_THIS_ORGANIZATION });
  if (!ctx.query?.userId) return ctx.json({ role: isMember.role });
  const userIdToGetRole = ctx.query?.userId;
  const member = await adapter.findMemberByOrgId({
    userId: userIdToGetRole,
    organizationId
  });
  if (!member) throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_A_MEMBER_OF_THIS_ORGANIZATION });
  return ctx.json({ role: member?.role });
});

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/organization/routes/crud-org.mjs
var baseOrganizationSchema = object({
  name: string().min(1).meta({ description: "The name of the organization" }),
  slug: string().min(1).meta({ description: "The slug of the organization" }),
  userId: coerce_exports.string().meta({ description: 'The user id of the organization creator. If not provided, the current user will be used. Should only be used by admins or when called by the server. server-only. Eg: "user-id"' }).optional(),
  logo: string().meta({ description: "The logo of the organization" }).optional(),
  metadata: record(string(), any()).meta({ description: "The metadata of the organization" }).optional(),
  keepCurrentActiveOrganization: boolean().meta({ description: "Whether to keep the current active organization active after creating a new one. Eg: true" }).optional()
});
var createOrganization = (options) => {
  const additionalFieldsSchema = toZodSchema({
    fields: options?.schema?.organization?.additionalFields || {},
    isClientSide: true
  });
  return createAuthEndpoint("/organization/create", {
    method: "POST",
    body: object({
      ...baseOrganizationSchema.shape,
      ...additionalFieldsSchema.shape
    }),
    use: [orgMiddleware],
    metadata: {
      $Infer: { body: {} },
      openapi: {
        description: "Create an organization",
        responses: { "200": {
          description: "Success",
          content: { "application/json": { schema: {
            type: "object",
            description: "The organization that was created",
            $ref: "#/components/schemas/Organization"
          } } }
        } }
      }
    }
  }, async (ctx) => {
    const session = await getSessionFromCtx(ctx);
    if (!session && (ctx.request || ctx.headers)) throw new APIError("UNAUTHORIZED");
    let user = session?.user || null;
    if (!user) {
      if (!ctx.body.userId) throw new APIError("UNAUTHORIZED");
      user = await ctx.context.internalAdapter.findUserById(ctx.body.userId);
    }
    if (!user) return ctx.json(null, { status: 401 });
    const options$1 = ctx.context.orgOptions;
    const canCreateOrg = typeof options$1?.allowUserToCreateOrganization === "function" ? await options$1.allowUserToCreateOrganization(user) : options$1?.allowUserToCreateOrganization === void 0 ? true : options$1.allowUserToCreateOrganization;
    const isSystemAction = !session && ctx.body.userId;
    if (!canCreateOrg && !isSystemAction) throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_CREATE_A_NEW_ORGANIZATION });
    const adapter = getOrgAdapter(ctx.context, options$1);
    const userOrganizations = await adapter.listOrganizations(user.id);
    if (typeof options$1.organizationLimit === "number" ? userOrganizations.length >= options$1.organizationLimit : typeof options$1.organizationLimit === "function" ? await options$1.organizationLimit(user) : false) throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.YOU_HAVE_REACHED_THE_MAXIMUM_NUMBER_OF_ORGANIZATIONS });
    if (await adapter.findOrganizationBySlug(ctx.body.slug)) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_ALREADY_EXISTS });
    let { keepCurrentActiveOrganization: _, userId: __, ...orgData } = ctx.body;
    if (options$1.organizationCreation?.beforeCreate) {
      const response = await options$1.organizationCreation.beforeCreate({
        organization: {
          ...orgData,
          createdAt: /* @__PURE__ */ new Date()
        },
        user
      }, ctx.request);
      if (response && typeof response === "object" && "data" in response) orgData = {
        ...ctx.body,
        ...response.data
      };
    }
    if (options$1?.organizationHooks?.beforeCreateOrganization) {
      const response = await options$1?.organizationHooks.beforeCreateOrganization({
        organization: orgData,
        user
      });
      if (response && typeof response === "object" && "data" in response) orgData = {
        ...ctx.body,
        ...response.data
      };
    }
    const organization2 = await adapter.createOrganization({ organization: {
      ...orgData,
      createdAt: /* @__PURE__ */ new Date()
    } });
    let member;
    let teamMember = null;
    let data = {
      userId: user.id,
      organizationId: organization2.id,
      role: ctx.context.orgOptions.creatorRole || "owner"
    };
    if (options$1?.organizationHooks?.beforeAddMember) {
      const response = await options$1?.organizationHooks.beforeAddMember({
        member: {
          userId: user.id,
          organizationId: organization2.id,
          role: ctx.context.orgOptions.creatorRole || "owner"
        },
        user,
        organization: organization2
      });
      if (response && typeof response === "object" && "data" in response) data = {
        ...data,
        ...response.data
      };
    }
    member = await adapter.createMember(data);
    if (options$1?.organizationHooks?.afterAddMember) await options$1?.organizationHooks.afterAddMember({
      member,
      user,
      organization: organization2
    });
    if (options$1?.teams?.enabled && options$1.teams.defaultTeam?.enabled !== false) {
      let teamData = {
        organizationId: organization2.id,
        name: `${organization2.name}`,
        createdAt: /* @__PURE__ */ new Date()
      };
      if (options$1?.organizationHooks?.beforeCreateTeam) {
        const response = await options$1?.organizationHooks.beforeCreateTeam({
          team: {
            organizationId: organization2.id,
            name: `${organization2.name}`
          },
          user,
          organization: organization2
        });
        if (response && typeof response === "object" && "data" in response) teamData = {
          ...teamData,
          ...response.data
        };
      }
      const defaultTeam = await options$1.teams.defaultTeam?.customCreateDefaultTeam?.(organization2, ctx) || await adapter.createTeam(teamData);
      teamMember = await adapter.findOrCreateTeamMember({
        teamId: defaultTeam.id,
        userId: user.id
      });
      if (options$1?.organizationHooks?.afterCreateTeam) await options$1?.organizationHooks.afterCreateTeam({
        team: defaultTeam,
        user,
        organization: organization2
      });
    }
    if (options$1.organizationCreation?.afterCreate) await options$1.organizationCreation.afterCreate({
      organization: organization2,
      user,
      member
    }, ctx.request);
    if (options$1?.organizationHooks?.afterCreateOrganization) await options$1?.organizationHooks.afterCreateOrganization({
      organization: organization2,
      user,
      member
    });
    if (ctx.context.session && !ctx.body.keepCurrentActiveOrganization) await adapter.setActiveOrganization(ctx.context.session.session.token, organization2.id, ctx);
    if (teamMember && ctx.context.session && !ctx.body.keepCurrentActiveOrganization) await adapter.setActiveTeam(ctx.context.session.session.token, teamMember.teamId, ctx);
    return ctx.json({
      ...organization2,
      metadata: organization2.metadata && typeof organization2.metadata === "string" ? JSON.parse(organization2.metadata) : organization2.metadata,
      members: [member]
    });
  });
};
var checkOrganizationSlugBodySchema = object({ slug: string().meta({ description: 'The organization slug to check. Eg: "my-org"' }) });
var checkOrganizationSlug = (options) => createAuthEndpoint("/organization/check-slug", {
  method: "POST",
  body: checkOrganizationSlugBodySchema,
  use: [requestOnlySessionMiddleware, orgMiddleware]
}, async (ctx) => {
  if (!await getOrgAdapter(ctx.context, options).findOrganizationBySlug(ctx.body.slug)) return ctx.json({ status: true });
  throw new APIError("BAD_REQUEST", { message: "slug is taken" });
});
var baseUpdateOrganizationSchema = object({
  name: string().min(1).meta({ description: "The name of the organization" }).optional(),
  slug: string().min(1).meta({ description: "The slug of the organization" }).optional(),
  logo: string().meta({ description: "The logo of the organization" }).optional(),
  metadata: record(string(), any()).meta({ description: "The metadata of the organization" }).optional()
});
var updateOrganization = (options) => {
  const additionalFieldsSchema = toZodSchema({
    fields: options?.schema?.organization?.additionalFields || {},
    isClientSide: true
  });
  return createAuthEndpoint("/organization/update", {
    method: "POST",
    body: object({
      data: object({
        ...additionalFieldsSchema.shape,
        ...baseUpdateOrganizationSchema.shape
      }).partial(),
      organizationId: string().meta({ description: 'The organization ID. Eg: "org-id"' }).optional()
    }),
    requireHeaders: true,
    use: [orgMiddleware],
    metadata: {
      $Infer: { body: {} },
      openapi: {
        description: "Update an organization",
        responses: { "200": {
          description: "Success",
          content: { "application/json": { schema: {
            type: "object",
            description: "The updated organization",
            $ref: "#/components/schemas/Organization"
          } } }
        } }
      }
    }
  }, async (ctx) => {
    const session = await ctx.context.getSession(ctx);
    if (!session) throw new APIError("UNAUTHORIZED", { message: "User not found" });
    const organizationId = ctx.body.organizationId || session.session.activeOrganizationId;
    if (!organizationId) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_NOT_FOUND });
    const adapter = getOrgAdapter(ctx.context, options);
    const member = await adapter.findMemberByOrgId({
      userId: session.user.id,
      organizationId
    });
    if (!member) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.USER_IS_NOT_A_MEMBER_OF_THE_ORGANIZATION });
    if (!await hasPermission2({
      permissions: { organization: ["update"] },
      role: member.role,
      options: ctx.context.orgOptions,
      organizationId
    }, ctx)) throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_UPDATE_THIS_ORGANIZATION });
    if (typeof ctx.body.data.slug === "string") {
      const existingOrganization = await adapter.findOrganizationBySlug(ctx.body.data.slug);
      if (existingOrganization && existingOrganization.id !== organizationId) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_SLUG_ALREADY_TAKEN });
    }
    if (options?.organizationHooks?.beforeUpdateOrganization) {
      const response = await options.organizationHooks.beforeUpdateOrganization({
        organization: ctx.body.data,
        user: session.user,
        member
      });
      if (response && typeof response === "object" && "data" in response) ctx.body.data = {
        ...ctx.body.data,
        ...response.data
      };
    }
    const updatedOrg = await adapter.updateOrganization(organizationId, ctx.body.data);
    if (options?.organizationHooks?.afterUpdateOrganization) await options.organizationHooks.afterUpdateOrganization({
      organization: updatedOrg,
      user: session.user,
      member
    });
    return ctx.json(updatedOrg);
  });
};
var deleteOrganizationBodySchema = object({ organizationId: string().meta({ description: "The organization id to delete" }) });
var deleteOrganization = (options) => {
  return createAuthEndpoint("/organization/delete", {
    method: "POST",
    body: deleteOrganizationBodySchema,
    requireHeaders: true,
    use: [orgMiddleware],
    metadata: { openapi: {
      description: "Delete an organization",
      responses: { "200": {
        description: "Success",
        content: { "application/json": { schema: {
          type: "string",
          description: "The organization id that was deleted"
        } } }
      } }
    } }
  }, async (ctx) => {
    if (ctx.context.orgOptions.organizationDeletion?.disabled || ctx.context.orgOptions.disableOrganizationDeletion) {
      if (ctx.context.orgOptions.organizationDeletion?.disabled) ctx.context.logger.info("`organizationDeletion.disabled` is deprecated. Use `disableOrganizationDeletion` instead");
      throw new APIError("NOT_FOUND", { message: "Organization deletion is disabled" });
    }
    const session = await ctx.context.getSession(ctx);
    if (!session) throw new APIError("UNAUTHORIZED", { status: 401 });
    const organizationId = ctx.body.organizationId;
    if (!organizationId) return ctx.json(null, {
      status: 400,
      body: { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_NOT_FOUND }
    });
    const adapter = getOrgAdapter(ctx.context, options);
    const member = await adapter.findMemberByOrgId({
      userId: session.user.id,
      organizationId
    });
    if (!member) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.USER_IS_NOT_A_MEMBER_OF_THE_ORGANIZATION });
    if (!await hasPermission2({
      role: member.role,
      permissions: { organization: ["delete"] },
      organizationId,
      options: ctx.context.orgOptions
    }, ctx)) throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_DELETE_THIS_ORGANIZATION });
    if (organizationId === session.session.activeOrganizationId)
      await adapter.setActiveOrganization(session.session.token, null, ctx);
    const org = await adapter.findOrganizationById(organizationId);
    if (!org) throw new APIError("BAD_REQUEST");
    if (options?.organizationHooks?.beforeDeleteOrganization) await options.organizationHooks.beforeDeleteOrganization({
      organization: org,
      user: session.user
    });
    await adapter.deleteOrganization(organizationId);
    if (options?.organizationHooks?.afterDeleteOrganization) await options.organizationHooks.afterDeleteOrganization({
      organization: org,
      user: session.user
    });
    return ctx.json(org);
  });
};
var getFullOrganizationQuerySchema = optional(object({
  organizationId: string().meta({ description: "The organization id to get" }).optional(),
  organizationSlug: string().meta({ description: "The organization slug to get" }).optional(),
  membersLimit: number().or(string().transform((val) => parseInt(val))).meta({ description: "The limit of members to get. By default, it uses the membershipLimit option which defaults to 100." }).optional()
}));
var getFullOrganization = (options) => createAuthEndpoint("/organization/get-full-organization", {
  method: "GET",
  query: getFullOrganizationQuerySchema,
  requireHeaders: true,
  use: [orgMiddleware, orgSessionMiddleware],
  metadata: { openapi: {
    operationId: "getOrganization",
    description: "Get the full organization",
    responses: { "200": {
      description: "Success",
      content: { "application/json": { schema: {
        type: "object",
        description: "The organization",
        $ref: "#/components/schemas/Organization"
      } } }
    } }
  } }
}, async (ctx) => {
  const session = ctx.context.session;
  const organizationId = ctx.query?.organizationSlug || ctx.query?.organizationId || session.session.activeOrganizationId;
  if (!organizationId) return ctx.json(null, { status: 200 });
  const adapter = getOrgAdapter(ctx.context, options);
  const organization2 = await adapter.findFullOrganization({
    organizationId,
    isSlug: !!ctx.query?.organizationSlug,
    includeTeams: ctx.context.orgOptions.teams?.enabled,
    membersLimit: ctx.query?.membersLimit
  });
  if (!organization2) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_NOT_FOUND });
  if (!await adapter.checkMembership({
    userId: session.user.id,
    organizationId: organization2.id
  })) {
    await adapter.setActiveOrganization(session.session.token, null, ctx);
    throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.USER_IS_NOT_A_MEMBER_OF_THE_ORGANIZATION });
  }
  return ctx.json(organization2);
});
var setActiveOrganizationBodySchema = object({
  organizationId: string().meta({ description: 'The organization id to set as active. It can be null to unset the active organization. Eg: "org-id"' }).nullable().optional(),
  organizationSlug: string().meta({ description: 'The organization slug to set as active. It can be null to unset the active organization if organizationId is not provided. Eg: "org-slug"' }).optional()
});
var setActiveOrganization = (options) => {
  return createAuthEndpoint("/organization/set-active", {
    method: "POST",
    body: setActiveOrganizationBodySchema,
    use: [orgSessionMiddleware, orgMiddleware],
    requireHeaders: true,
    metadata: { openapi: {
      operationId: "setActiveOrganization",
      description: "Set the active organization",
      responses: { "200": {
        description: "Success",
        content: { "application/json": { schema: {
          type: "object",
          description: "The organization",
          $ref: "#/components/schemas/Organization"
        } } }
      } }
    } }
  }, async (ctx) => {
    const adapter = getOrgAdapter(ctx.context, options);
    const session = ctx.context.session;
    let organizationId = ctx.body.organizationId;
    let organizationSlug = ctx.body.organizationSlug;
    if (organizationId === null) {
      if (!session.session.activeOrganizationId) return ctx.json(null);
      await setSessionCookie(ctx, {
        session: await adapter.setActiveOrganization(session.session.token, null, ctx),
        user: session.user
      });
      return ctx.json(null);
    }
    if (!organizationId && !organizationSlug) {
      const sessionOrgId = session.session.activeOrganizationId;
      if (!sessionOrgId) return ctx.json(null);
      organizationId = sessionOrgId;
    }
    if (organizationSlug && !organizationId) {
      const organization$1 = await adapter.findOrganizationBySlug(organizationSlug);
      if (!organization$1) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_NOT_FOUND });
      organizationId = organization$1.id;
    }
    if (!organizationId) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_NOT_FOUND });
    if (!await adapter.checkMembership({
      userId: session.user.id,
      organizationId
    })) {
      await adapter.setActiveOrganization(session.session.token, null, ctx);
      throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.USER_IS_NOT_A_MEMBER_OF_THE_ORGANIZATION });
    }
    let organization2 = await adapter.findOrganizationById(organizationId);
    if (!organization2) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_NOT_FOUND });
    await setSessionCookie(ctx, {
      session: await adapter.setActiveOrganization(session.session.token, organization2.id, ctx),
      user: session.user
    });
    return ctx.json(organization2);
  });
};
var listOrganizations = (options) => createAuthEndpoint("/organization/list", {
  method: "GET",
  use: [orgMiddleware, orgSessionMiddleware],
  requireHeaders: true,
  metadata: { openapi: {
    description: "List all organizations",
    responses: { "200": {
      description: "Success",
      content: { "application/json": { schema: {
        type: "array",
        items: { $ref: "#/components/schemas/Organization" }
      } } }
    } }
  } }
}, async (ctx) => {
  const organizations = await getOrgAdapter(ctx.context, options).listOrganizations(ctx.context.session.user.id);
  return ctx.json(organizations);
});

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/organization/schema.mjs
var roleSchema = string();
var invitationStatus = _enum([
  "pending",
  "accepted",
  "rejected",
  "canceled"
]).default("pending");
var organizationSchema = object({
  id: string().default(generateId),
  name: string(),
  slug: string(),
  logo: string().nullish().optional(),
  metadata: record(string(), unknown()).or(string().transform((v) => JSON.parse(v))).optional(),
  createdAt: date()
});
var memberSchema = object({
  id: string().default(generateId),
  organizationId: string(),
  userId: coerce_exports.string(),
  role: roleSchema,
  createdAt: date().default(() => /* @__PURE__ */ new Date())
});
var invitationSchema = object({
  id: string().default(generateId),
  organizationId: string(),
  email: string(),
  role: roleSchema,
  status: invitationStatus,
  teamId: string().nullish(),
  inviterId: string(),
  expiresAt: date(),
  createdAt: date().default(() => /* @__PURE__ */ new Date())
});
var teamSchema = object({
  id: string().default(generateId),
  name: string().min(1),
  organizationId: string(),
  createdAt: date(),
  updatedAt: date().optional()
});
var teamMemberSchema = object({
  id: string().default(generateId),
  teamId: string(),
  userId: string(),
  createdAt: date().default(() => /* @__PURE__ */ new Date())
});
var organizationRoleSchema = object({
  id: string().default(generateId),
  organizationId: string(),
  role: string(),
  permission: record(string(), array(string())),
  createdAt: date().default(() => /* @__PURE__ */ new Date()),
  updatedAt: date().optional()
});
var defaultRoles3 = [
  "admin",
  "member",
  "owner"
];
var defaultRolesSchema = union([_enum(defaultRoles3), array(_enum(defaultRoles3))]);

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/organization/routes/crud-team.mjs
var teamBaseSchema = object({
  name: string().meta({ description: 'The name of the team. Eg: "my-team"' }),
  organizationId: string().meta({ description: 'The organization ID which the team will be created in. Defaults to the active organization. Eg: "organization-id"' }).optional()
});
var createTeam = (options) => {
  const additionalFieldsSchema = toZodSchema({
    fields: options?.schema?.team?.additionalFields ?? {},
    isClientSide: true
  });
  return createAuthEndpoint("/organization/create-team", {
    method: "POST",
    body: object({
      ...teamBaseSchema.shape,
      ...additionalFieldsSchema.shape
    }),
    use: [orgMiddleware],
    metadata: {
      $Infer: { body: {} },
      openapi: {
        description: "Create a new team within an organization",
        responses: { "200": {
          description: "Team created successfully",
          content: { "application/json": { schema: {
            type: "object",
            properties: {
              id: {
                type: "string",
                description: "Unique identifier of the created team"
              },
              name: {
                type: "string",
                description: "Name of the team"
              },
              organizationId: {
                type: "string",
                description: "ID of the organization the team belongs to"
              },
              createdAt: {
                type: "string",
                format: "date-time",
                description: "Timestamp when the team was created"
              },
              updatedAt: {
                type: "string",
                format: "date-time",
                description: "Timestamp when the team was last updated"
              }
            },
            required: [
              "id",
              "name",
              "organizationId",
              "createdAt",
              "updatedAt"
            ]
          } } }
        } }
      }
    }
  }, async (ctx) => {
    const session = await getSessionFromCtx(ctx);
    const organizationId = ctx.body.organizationId || session?.session.activeOrganizationId;
    if (!session && (ctx.request || ctx.headers)) throw new APIError("UNAUTHORIZED");
    if (!organizationId) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.NO_ACTIVE_ORGANIZATION });
    const adapter = getOrgAdapter(ctx.context, options);
    if (session) {
      const member = await adapter.findMemberByOrgId({
        userId: session.user.id,
        organizationId
      });
      if (!member) throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_INVITE_USERS_TO_THIS_ORGANIZATION });
      if (!await hasPermission2({
        role: member.role,
        options: ctx.context.orgOptions,
        permissions: { team: ["create"] },
        organizationId
      }, ctx)) throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_CREATE_TEAMS_IN_THIS_ORGANIZATION });
    }
    const existingTeams = await adapter.listTeams(organizationId);
    const maximum = typeof ctx.context.orgOptions.teams?.maximumTeams === "function" ? await ctx.context.orgOptions.teams?.maximumTeams({
      organizationId,
      session
    }, ctx) : ctx.context.orgOptions.teams?.maximumTeams;
    if (maximum ? existingTeams.length >= maximum : false) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.YOU_HAVE_REACHED_THE_MAXIMUM_NUMBER_OF_TEAMS });
    const { name, organizationId: _, ...additionalFields } = ctx.body;
    const organization2 = await adapter.findOrganizationById(organizationId);
    if (!organization2) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_NOT_FOUND });
    let teamData = {
      name,
      organizationId,
      createdAt: /* @__PURE__ */ new Date(),
      updatedAt: /* @__PURE__ */ new Date(),
      ...additionalFields
    };
    if (options?.organizationHooks?.beforeCreateTeam) {
      const response = await options?.organizationHooks.beforeCreateTeam({
        team: {
          name,
          organizationId,
          ...additionalFields
        },
        user: session?.user,
        organization: organization2
      });
      if (response && typeof response === "object" && "data" in response) teamData = {
        ...teamData,
        ...response.data
      };
    }
    const createdTeam = await adapter.createTeam(teamData);
    if (options?.organizationHooks?.afterCreateTeam) await options?.organizationHooks.afterCreateTeam({
      team: createdTeam,
      user: session?.user,
      organization: organization2
    });
    return ctx.json(createdTeam);
  });
};
var removeTeamBodySchema = object({
  teamId: string().meta({ description: `The team ID of the team to remove. Eg: "team-id"` }),
  organizationId: string().meta({ description: `The organization ID which the team falls under. If not provided, it will default to the user's active organization. Eg: "organization-id"` }).optional()
});
var removeTeam = (options) => createAuthEndpoint("/organization/remove-team", {
  method: "POST",
  body: removeTeamBodySchema,
  use: [orgMiddleware],
  metadata: { openapi: {
    description: "Remove a team from an organization",
    responses: { "200": {
      description: "Team removed successfully",
      content: { "application/json": { schema: {
        type: "object",
        properties: { message: {
          type: "string",
          description: "Confirmation message indicating successful removal",
          enum: ["Team removed successfully."]
        } },
        required: ["message"]
      } } }
    } }
  } }
}, async (ctx) => {
  const session = await getSessionFromCtx(ctx);
  const organizationId = ctx.body.organizationId || session?.session.activeOrganizationId;
  if (!organizationId) return ctx.json(null, {
    status: 400,
    body: { message: ORGANIZATION_ERROR_CODES.NO_ACTIVE_ORGANIZATION }
  });
  if (!session && (ctx.request || ctx.headers)) throw new APIError("UNAUTHORIZED");
  const adapter = getOrgAdapter(ctx.context, options);
  if (session) {
    const member = await adapter.findMemberByOrgId({
      userId: session.user.id,
      organizationId
    });
    if (!member || session.session?.activeTeamId === ctx.body.teamId) throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_DELETE_THIS_TEAM });
    if (!await hasPermission2({
      role: member.role,
      options: ctx.context.orgOptions,
      permissions: { team: ["delete"] },
      organizationId
    }, ctx)) throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_DELETE_TEAMS_IN_THIS_ORGANIZATION });
  }
  const team = await adapter.findTeamById({
    teamId: ctx.body.teamId,
    organizationId
  });
  if (!team || team.organizationId !== organizationId) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.TEAM_NOT_FOUND });
  if (!ctx.context.orgOptions.teams?.allowRemovingAllTeams) {
    if ((await adapter.listTeams(organizationId)).length <= 1) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.UNABLE_TO_REMOVE_LAST_TEAM });
  }
  const organization2 = await adapter.findOrganizationById(organizationId);
  if (!organization2) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_NOT_FOUND });
  if (options?.organizationHooks?.beforeDeleteTeam) await options?.organizationHooks.beforeDeleteTeam({
    team,
    user: session?.user,
    organization: organization2
  });
  await adapter.deleteTeam(team.id);
  if (options?.organizationHooks?.afterDeleteTeam) await options?.organizationHooks.afterDeleteTeam({
    team,
    user: session?.user,
    organization: organization2
  });
  return ctx.json({ message: "Team removed successfully." });
});
var updateTeam = (options) => {
  const additionalFieldsSchema = toZodSchema({
    fields: options?.schema?.team?.additionalFields ?? {},
    isClientSide: true
  });
  return createAuthEndpoint("/organization/update-team", {
    method: "POST",
    body: object({
      teamId: string().meta({ description: `The ID of the team to be updated. Eg: "team-id"` }),
      data: object({
        ...teamSchema.shape,
        ...additionalFieldsSchema.shape
      }).partial()
    }),
    requireHeaders: true,
    use: [orgMiddleware, orgSessionMiddleware],
    metadata: {
      $Infer: { body: {} },
      openapi: {
        description: "Update an existing team in an organization",
        responses: { "200": {
          description: "Team updated successfully",
          content: { "application/json": { schema: {
            type: "object",
            properties: {
              id: {
                type: "string",
                description: "Unique identifier of the updated team"
              },
              name: {
                type: "string",
                description: "Updated name of the team"
              },
              organizationId: {
                type: "string",
                description: "ID of the organization the team belongs to"
              },
              createdAt: {
                type: "string",
                format: "date-time",
                description: "Timestamp when the team was created"
              },
              updatedAt: {
                type: "string",
                format: "date-time",
                description: "Timestamp when the team was last updated"
              }
            },
            required: [
              "id",
              "name",
              "organizationId",
              "createdAt",
              "updatedAt"
            ]
          } } }
        } }
      }
    }
  }, async (ctx) => {
    const session = ctx.context.session;
    const organizationId = ctx.body.data.organizationId || session.session.activeOrganizationId;
    if (!organizationId) return ctx.json(null, {
      status: 400,
      body: { message: ORGANIZATION_ERROR_CODES.NO_ACTIVE_ORGANIZATION }
    });
    const adapter = getOrgAdapter(ctx.context, options);
    const member = await adapter.findMemberByOrgId({
      userId: session.user.id,
      organizationId
    });
    if (!member) throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_UPDATE_THIS_TEAM });
    if (!await hasPermission2({
      role: member.role,
      options: ctx.context.orgOptions,
      permissions: { team: ["update"] },
      organizationId
    }, ctx)) throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_UPDATE_THIS_TEAM });
    const team = await adapter.findTeamById({
      teamId: ctx.body.teamId,
      organizationId
    });
    if (!team || team.organizationId !== organizationId) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.TEAM_NOT_FOUND });
    const { name, organizationId: __, ...additionalFields } = ctx.body.data;
    const organization2 = await adapter.findOrganizationById(organizationId);
    if (!organization2) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_NOT_FOUND });
    const updates = {
      name,
      ...additionalFields
    };
    if (options?.organizationHooks?.beforeUpdateTeam) {
      const response = await options?.organizationHooks.beforeUpdateTeam({
        team,
        updates,
        user: session.user,
        organization: organization2
      });
      if (response && typeof response === "object" && "data" in response) {
        const modifiedUpdates = response.data;
        const updatedTeam$1 = await adapter.updateTeam(team.id, modifiedUpdates);
        if (options?.organizationHooks?.afterUpdateTeam) await options?.organizationHooks.afterUpdateTeam({
          team: updatedTeam$1,
          user: session.user,
          organization: organization2
        });
        return ctx.json(updatedTeam$1);
      }
    }
    const updatedTeam = await adapter.updateTeam(team.id, updates);
    if (options?.organizationHooks?.afterUpdateTeam) await options?.organizationHooks.afterUpdateTeam({
      team: updatedTeam,
      user: session.user,
      organization: organization2
    });
    return ctx.json(updatedTeam);
  });
};
var listOrganizationTeamsQuerySchema = optional(object({ organizationId: string().meta({ description: `The organization ID which the teams are under to list. Defaults to the users active organization. Eg: "organization-id"` }).optional() }));
var listOrganizationTeams = (options) => createAuthEndpoint("/organization/list-teams", {
  method: "GET",
  query: listOrganizationTeamsQuerySchema,
  metadata: { openapi: {
    description: "List all teams in an organization",
    responses: { "200": {
      description: "Teams retrieved successfully",
      content: { "application/json": { schema: {
        type: "array",
        items: {
          type: "object",
          properties: {
            id: {
              type: "string",
              description: "Unique identifier of the team"
            },
            name: {
              type: "string",
              description: "Name of the team"
            },
            organizationId: {
              type: "string",
              description: "ID of the organization the team belongs to"
            },
            createdAt: {
              type: "string",
              format: "date-time",
              description: "Timestamp when the team was created"
            },
            updatedAt: {
              type: "string",
              format: "date-time",
              description: "Timestamp when the team was last updated"
            }
          },
          required: [
            "id",
            "name",
            "organizationId",
            "createdAt",
            "updatedAt"
          ]
        },
        description: "Array of team objects within the organization"
      } } }
    } }
  } },
  requireHeaders: true,
  use: [orgMiddleware, orgSessionMiddleware]
}, async (ctx) => {
  const session = ctx.context.session;
  const organizationId = ctx.query?.organizationId || session?.session.activeOrganizationId;
  if (!organizationId) throw ctx.error("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.NO_ACTIVE_ORGANIZATION });
  const adapter = getOrgAdapter(ctx.context, options);
  if (!await adapter.findMemberByOrgId({
    userId: session.user.id,
    organizationId: organizationId || ""
  })) throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_ACCESS_THIS_ORGANIZATION });
  const teams = await adapter.listTeams(organizationId);
  return ctx.json(teams);
});
var setActiveTeamBodySchema = object({ teamId: string().meta({ description: "The team id to set as active. It can be null to unset the active team" }).nullable().optional() });
var setActiveTeam = (options) => createAuthEndpoint("/organization/set-active-team", {
  method: "POST",
  body: setActiveTeamBodySchema,
  requireHeaders: true,
  use: [orgSessionMiddleware, orgMiddleware],
  metadata: { openapi: {
    description: "Set the active team",
    responses: { "200": {
      description: "Success",
      content: { "application/json": { schema: {
        type: "object",
        description: "The team",
        $ref: "#/components/schemas/Team"
      } } }
    } }
  } }
}, async (ctx) => {
  const adapter = getOrgAdapter(ctx.context, ctx.context.orgOptions);
  const session = ctx.context.session;
  if (ctx.body.teamId === null) {
    if (!session.session.activeTeamId) return ctx.json(null);
    await setSessionCookie(ctx, {
      session: await adapter.setActiveTeam(session.session.token, null, ctx),
      user: session.user
    });
    return ctx.json(null);
  }
  let teamId;
  if (!ctx.body.teamId) {
    const sessionTeamId = session.session.activeTeamId;
    if (!sessionTeamId) return ctx.json(null);
    else teamId = sessionTeamId;
  } else teamId = ctx.body.teamId;
  const team = await adapter.findTeamById({ teamId });
  if (!team) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.TEAM_NOT_FOUND });
  if (!await adapter.findTeamMember({
    teamId,
    userId: session.user.id
  })) throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.USER_IS_NOT_A_MEMBER_OF_THE_TEAM });
  await setSessionCookie(ctx, {
    session: await adapter.setActiveTeam(session.session.token, team.id, ctx),
    user: session.user
  });
  return ctx.json(team);
});
var listUserTeams = (options) => createAuthEndpoint("/organization/list-user-teams", {
  method: "GET",
  metadata: { openapi: {
    description: "List all teams that the current user is a part of.",
    responses: { "200": {
      description: "Teams retrieved successfully",
      content: { "application/json": { schema: {
        type: "array",
        items: {
          type: "object",
          description: "The team",
          $ref: "#/components/schemas/Team"
        },
        description: "Array of team objects within the organization"
      } } }
    } }
  } },
  requireHeaders: true,
  use: [orgMiddleware, orgSessionMiddleware]
}, async (ctx) => {
  const session = ctx.context.session;
  const teams = await getOrgAdapter(ctx.context, ctx.context.orgOptions).listTeamsByUser({ userId: session.user.id });
  return ctx.json(teams);
});
var listTeamMembersQuerySchema = optional(object({ teamId: string().optional().meta({ description: "The team whose members we should return. If this is not provided the members of the current active team get returned." }) }));
var listTeamMembers = (options) => createAuthEndpoint("/organization/list-team-members", {
  method: "GET",
  query: listTeamMembersQuerySchema,
  metadata: { openapi: {
    description: "List the members of the given team.",
    responses: { "200": {
      description: "Teams retrieved successfully",
      content: { "application/json": { schema: {
        type: "array",
        items: {
          type: "object",
          description: "The team member",
          properties: {
            id: {
              type: "string",
              description: "Unique identifier of the team member"
            },
            userId: {
              type: "string",
              description: "The user ID of the team member"
            },
            teamId: {
              type: "string",
              description: "The team ID of the team the team member is in"
            },
            createdAt: {
              type: "string",
              format: "date-time",
              description: "Timestamp when the team member was created"
            }
          },
          required: [
            "id",
            "userId",
            "teamId",
            "createdAt"
          ]
        },
        description: "Array of team member objects within the team"
      } } }
    } }
  } },
  requireHeaders: true,
  use: [orgMiddleware, orgSessionMiddleware]
}, async (ctx) => {
  const session = ctx.context.session;
  const adapter = getOrgAdapter(ctx.context, ctx.context.orgOptions);
  let teamId = ctx.query?.teamId || session?.session.activeTeamId;
  if (!teamId) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.YOU_DO_NOT_HAVE_AN_ACTIVE_TEAM });
  if (!await adapter.findTeamMember({
    userId: session.user.id,
    teamId
  })) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.USER_IS_NOT_A_MEMBER_OF_THE_TEAM });
  const members = await adapter.listTeamMembers({ teamId });
  return ctx.json(members);
});
var addTeamMemberBodySchema = object({
  teamId: string().meta({ description: "The team the user should be a member of." }),
  userId: coerce_exports.string().meta({ description: "The user Id which represents the user to be added as a member." })
});
var addTeamMember = (options) => createAuthEndpoint("/organization/add-team-member", {
  method: "POST",
  body: addTeamMemberBodySchema,
  metadata: { openapi: {
    description: "The newly created member",
    responses: { "200": {
      description: "Team member created successfully",
      content: { "application/json": { schema: {
        type: "object",
        description: "The team member",
        properties: {
          id: {
            type: "string",
            description: "Unique identifier of the team member"
          },
          userId: {
            type: "string",
            description: "The user ID of the team member"
          },
          teamId: {
            type: "string",
            description: "The team ID of the team the team member is in"
          },
          createdAt: {
            type: "string",
            format: "date-time",
            description: "Timestamp when the team member was created"
          }
        },
        required: [
          "id",
          "userId",
          "teamId",
          "createdAt"
        ]
      } } }
    } }
  } },
  requireHeaders: true,
  use: [orgMiddleware, orgSessionMiddleware]
}, async (ctx) => {
  const session = ctx.context.session;
  const adapter = getOrgAdapter(ctx.context, ctx.context.orgOptions);
  if (!session.session.activeOrganizationId) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.NO_ACTIVE_ORGANIZATION });
  const currentMember = await adapter.findMemberByOrgId({
    userId: session.user.id,
    organizationId: session.session.activeOrganizationId
  });
  if (!currentMember) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.USER_IS_NOT_A_MEMBER_OF_THE_ORGANIZATION });
  if (!await hasPermission2({
    role: currentMember.role,
    options: ctx.context.orgOptions,
    permissions: { member: ["update"] },
    organizationId: session.session.activeOrganizationId
  }, ctx)) throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_CREATE_A_NEW_TEAM_MEMBER });
  if (!await adapter.findMemberByOrgId({
    userId: ctx.body.userId,
    organizationId: session.session.activeOrganizationId
  })) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.USER_IS_NOT_A_MEMBER_OF_THE_ORGANIZATION });
  const team = await adapter.findTeamById({
    teamId: ctx.body.teamId,
    organizationId: session.session.activeOrganizationId
  });
  if (!team) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.TEAM_NOT_FOUND });
  const organization2 = await adapter.findOrganizationById(session.session.activeOrganizationId);
  if (!organization2) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_NOT_FOUND });
  const userBeingAdded = await ctx.context.internalAdapter.findUserById(ctx.body.userId);
  if (!userBeingAdded) throw new APIError("BAD_REQUEST", { message: "User not found" });
  if (options?.organizationHooks?.beforeAddTeamMember) {
    const response = await options?.organizationHooks.beforeAddTeamMember({
      teamMember: {
        teamId: ctx.body.teamId,
        userId: ctx.body.userId
      },
      team,
      user: userBeingAdded,
      organization: organization2
    });
    if (response && typeof response === "object" && "data" in response) {
    }
  }
  const teamMember = await adapter.findOrCreateTeamMember({
    teamId: ctx.body.teamId,
    userId: ctx.body.userId
  });
  if (options?.organizationHooks?.afterAddTeamMember) await options?.organizationHooks.afterAddTeamMember({
    teamMember,
    team,
    user: userBeingAdded,
    organization: organization2
  });
  return ctx.json(teamMember);
});
var removeTeamMemberBodySchema = object({
  teamId: string().meta({ description: "The team the user should be removed from." }),
  userId: coerce_exports.string().meta({ description: "The user which should be removed from the team." })
});
var removeTeamMember = (options) => createAuthEndpoint("/organization/remove-team-member", {
  method: "POST",
  body: removeTeamMemberBodySchema,
  metadata: { openapi: {
    description: "Remove a member from a team",
    responses: { "200": {
      description: "Team member removed successfully",
      content: { "application/json": { schema: {
        type: "object",
        properties: { message: {
          type: "string",
          description: "Confirmation message indicating successful removal",
          enum: ["Team member removed successfully."]
        } },
        required: ["message"]
      } } }
    } }
  } },
  requireHeaders: true,
  use: [orgMiddleware, orgSessionMiddleware]
}, async (ctx) => {
  const session = ctx.context.session;
  const adapter = getOrgAdapter(ctx.context, ctx.context.orgOptions);
  if (!session.session.activeOrganizationId) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.NO_ACTIVE_ORGANIZATION });
  const currentMember = await adapter.findMemberByOrgId({
    userId: session.user.id,
    organizationId: session.session.activeOrganizationId
  });
  if (!currentMember) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.USER_IS_NOT_A_MEMBER_OF_THE_ORGANIZATION });
  if (!await hasPermission2({
    role: currentMember.role,
    options: ctx.context.orgOptions,
    permissions: { member: ["delete"] },
    organizationId: session.session.activeOrganizationId
  }, ctx)) throw new APIError("FORBIDDEN", { message: ORGANIZATION_ERROR_CODES.YOU_ARE_NOT_ALLOWED_TO_REMOVE_A_TEAM_MEMBER });
  if (!await adapter.findMemberByOrgId({
    userId: ctx.body.userId,
    organizationId: session.session.activeOrganizationId
  })) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.USER_IS_NOT_A_MEMBER_OF_THE_ORGANIZATION });
  const team = await adapter.findTeamById({
    teamId: ctx.body.teamId,
    organizationId: session.session.activeOrganizationId
  });
  if (!team) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.TEAM_NOT_FOUND });
  const organization2 = await adapter.findOrganizationById(session.session.activeOrganizationId);
  if (!organization2) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.ORGANIZATION_NOT_FOUND });
  const userBeingRemoved = await ctx.context.internalAdapter.findUserById(ctx.body.userId);
  if (!userBeingRemoved) throw new APIError("BAD_REQUEST", { message: "User not found" });
  const teamMember = await adapter.findTeamMember({
    teamId: ctx.body.teamId,
    userId: ctx.body.userId
  });
  if (!teamMember) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.USER_IS_NOT_A_MEMBER_OF_THE_TEAM });
  if (options?.organizationHooks?.beforeRemoveTeamMember) await options?.organizationHooks.beforeRemoveTeamMember({
    teamMember,
    team,
    user: userBeingRemoved,
    organization: organization2
  });
  await adapter.removeTeamMember({
    teamId: ctx.body.teamId,
    userId: ctx.body.userId
  });
  if (options?.organizationHooks?.afterRemoveTeamMember) await options?.organizationHooks.afterRemoveTeamMember({
    teamMember,
    team,
    user: userBeingRemoved,
    organization: organization2
  });
  return ctx.json({ message: "Team member removed successfully." });
});

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/organization/organization.mjs
function parseRoles2(roles) {
  return Array.isArray(roles) ? roles.join(",") : roles;
}
var createHasPermissionBodySchema = object({ organizationId: string().optional() }).and(union([object({
  permission: record(string(), array(string())),
  permissions: _undefined()
}), object({
  permission: _undefined(),
  permissions: record(string(), array(string()))
})]));
var createHasPermission = (options) => {
  return createAuthEndpoint("/organization/has-permission", {
    method: "POST",
    requireHeaders: true,
    body: createHasPermissionBodySchema,
    use: [orgSessionMiddleware],
    metadata: {
      $Infer: { body: {} },
      openapi: {
        description: "Check if the user has permission",
        requestBody: { content: { "application/json": { schema: {
          type: "object",
          properties: {
            permission: {
              type: "object",
              description: "The permission to check",
              deprecated: true
            },
            permissions: {
              type: "object",
              description: "The permission to check"
            }
          },
          required: ["permissions"]
        } } } },
        responses: { "200": {
          description: "Success",
          content: { "application/json": { schema: {
            type: "object",
            properties: {
              error: { type: "string" },
              success: { type: "boolean" }
            },
            required: ["success"]
          } } }
        } }
      }
    }
  }, async (ctx) => {
    const activeOrganizationId = ctx.body.organizationId || ctx.context.session.session.activeOrganizationId;
    if (!activeOrganizationId) throw new APIError("BAD_REQUEST", { message: ORGANIZATION_ERROR_CODES.NO_ACTIVE_ORGANIZATION });
    const member = await getOrgAdapter(ctx.context, options).findMemberByOrgId({
      userId: ctx.context.session.user.id,
      organizationId: activeOrganizationId
    });
    if (!member) throw new APIError("UNAUTHORIZED", { message: ORGANIZATION_ERROR_CODES.USER_IS_NOT_A_MEMBER_OF_THE_ORGANIZATION });
    const result = await hasPermission2({
      role: member.role,
      options: options || {},
      permissions: ctx.body.permissions ?? ctx.body.permission,
      organizationId: activeOrganizationId
    }, ctx);
    return ctx.json({
      error: null,
      success: result
    });
  });
};
function organization(options) {
  let endpoints = {
    createOrganization: createOrganization(options),
    updateOrganization: updateOrganization(options),
    deleteOrganization: deleteOrganization(options),
    setActiveOrganization: setActiveOrganization(options),
    getFullOrganization: getFullOrganization(options),
    listOrganizations: listOrganizations(options),
    createInvitation: createInvitation(options),
    cancelInvitation: cancelInvitation(options),
    acceptInvitation: acceptInvitation(options),
    getInvitation: getInvitation(options),
    rejectInvitation: rejectInvitation(options),
    listInvitations: listInvitations(options),
    getActiveMember: getActiveMember(options),
    checkOrganizationSlug: checkOrganizationSlug(options),
    addMember: addMember(options),
    removeMember: removeMember(options),
    updateMemberRole: updateMemberRole(options),
    leaveOrganization: leaveOrganization(options),
    listUserInvitations: listUserInvitations(options),
    listMembers: listMembers(options),
    getActiveMemberRole: getActiveMemberRole(options)
  };
  const teamSupport = options?.teams?.enabled;
  const teamEndpoints = {
    createTeam: createTeam(options),
    listOrganizationTeams: listOrganizationTeams(options),
    removeTeam: removeTeam(options),
    updateTeam: updateTeam(options),
    setActiveTeam: setActiveTeam(options),
    listUserTeams: listUserTeams(options),
    listTeamMembers: listTeamMembers(options),
    addTeamMember: addTeamMember(options),
    removeTeamMember: removeTeamMember(options)
  };
  if (teamSupport) endpoints = {
    ...endpoints,
    ...teamEndpoints
  };
  const dynamicAccessControlEndpoints = {
    createOrgRole: createOrgRole(options),
    deleteOrgRole: deleteOrgRole(options),
    listOrgRoles: listOrgRoles(options),
    getOrgRole: getOrgRole(options),
    updateOrgRole: updateOrgRole(options)
  };
  if (options?.dynamicAccessControl?.enabled) endpoints = {
    ...endpoints,
    ...dynamicAccessControlEndpoints
  };
  const roles = {
    ...defaultRoles2,
    ...options?.roles
  };
  const teamSchema2 = teamSupport ? {
    team: {
      modelName: options?.schema?.team?.modelName,
      fields: {
        name: {
          type: "string",
          required: true,
          fieldName: options?.schema?.team?.fields?.name
        },
        organizationId: {
          type: "string",
          required: true,
          references: {
            model: "organization",
            field: "id"
          },
          fieldName: options?.schema?.team?.fields?.organizationId,
          index: true
        },
        createdAt: {
          type: "date",
          required: true,
          fieldName: options?.schema?.team?.fields?.createdAt
        },
        updatedAt: {
          type: "date",
          required: false,
          fieldName: options?.schema?.team?.fields?.updatedAt,
          onUpdate: () => /* @__PURE__ */ new Date()
        },
        ...options?.schema?.team?.additionalFields || {}
      }
    },
    teamMember: {
      modelName: options?.schema?.teamMember?.modelName,
      fields: {
        teamId: {
          type: "string",
          required: true,
          references: {
            model: "team",
            field: "id"
          },
          fieldName: options?.schema?.teamMember?.fields?.teamId,
          index: true
        },
        userId: {
          type: "string",
          required: true,
          references: {
            model: "user",
            field: "id"
          },
          fieldName: options?.schema?.teamMember?.fields?.userId,
          index: true
        },
        createdAt: {
          type: "date",
          required: false,
          fieldName: options?.schema?.teamMember?.fields?.createdAt
        }
      }
    }
  } : {};
  const organizationRoleSchema2 = options?.dynamicAccessControl?.enabled ? { organizationRole: {
    fields: {
      organizationId: {
        type: "string",
        required: true,
        references: {
          model: "organization",
          field: "id"
        },
        fieldName: options?.schema?.organizationRole?.fields?.organizationId,
        index: true
      },
      role: {
        type: "string",
        required: true,
        fieldName: options?.schema?.organizationRole?.fields?.role,
        index: true
      },
      permission: {
        type: "string",
        required: true,
        fieldName: options?.schema?.organizationRole?.fields?.permission
      },
      createdAt: {
        type: "date",
        required: true,
        defaultValue: () => /* @__PURE__ */ new Date(),
        fieldName: options?.schema?.organizationRole?.fields?.createdAt
      },
      updatedAt: {
        type: "date",
        required: false,
        fieldName: options?.schema?.organizationRole?.fields?.updatedAt,
        onUpdate: () => /* @__PURE__ */ new Date()
      },
      ...options?.schema?.organizationRole?.additionalFields || {}
    },
    modelName: options?.schema?.organizationRole?.modelName
  } } : {};
  const schema9 = {
    organization: {
      modelName: options?.schema?.organization?.modelName,
      fields: {
        name: {
          type: "string",
          required: true,
          sortable: true,
          fieldName: options?.schema?.organization?.fields?.name
        },
        slug: {
          type: "string",
          required: true,
          unique: true,
          sortable: true,
          fieldName: options?.schema?.organization?.fields?.slug,
          index: true
        },
        logo: {
          type: "string",
          required: false,
          fieldName: options?.schema?.organization?.fields?.logo
        },
        createdAt: {
          type: "date",
          required: true,
          fieldName: options?.schema?.organization?.fields?.createdAt
        },
        metadata: {
          type: "string",
          required: false,
          fieldName: options?.schema?.organization?.fields?.metadata
        },
        ...options?.schema?.organization?.additionalFields || {}
      }
    },
    ...organizationRoleSchema2,
    ...teamSchema2,
    member: {
      modelName: options?.schema?.member?.modelName,
      fields: {
        organizationId: {
          type: "string",
          required: true,
          references: {
            model: "organization",
            field: "id"
          },
          fieldName: options?.schema?.member?.fields?.organizationId,
          index: true
        },
        userId: {
          type: "string",
          required: true,
          fieldName: options?.schema?.member?.fields?.userId,
          references: {
            model: "user",
            field: "id"
          },
          index: true
        },
        role: {
          type: "string",
          required: true,
          sortable: true,
          defaultValue: "member",
          fieldName: options?.schema?.member?.fields?.role
        },
        createdAt: {
          type: "date",
          required: true,
          fieldName: options?.schema?.member?.fields?.createdAt
        },
        ...options?.schema?.member?.additionalFields || {}
      }
    },
    invitation: {
      modelName: options?.schema?.invitation?.modelName,
      fields: {
        organizationId: {
          type: "string",
          required: true,
          references: {
            model: "organization",
            field: "id"
          },
          fieldName: options?.schema?.invitation?.fields?.organizationId,
          index: true
        },
        email: {
          type: "string",
          required: true,
          sortable: true,
          fieldName: options?.schema?.invitation?.fields?.email,
          index: true
        },
        role: {
          type: "string",
          required: false,
          sortable: true,
          fieldName: options?.schema?.invitation?.fields?.role
        },
        ...teamSupport ? { teamId: {
          type: "string",
          required: false,
          sortable: true,
          fieldName: options?.schema?.invitation?.fields?.teamId
        } } : {},
        status: {
          type: "string",
          required: true,
          sortable: true,
          defaultValue: "pending",
          fieldName: options?.schema?.invitation?.fields?.status
        },
        expiresAt: {
          type: "date",
          required: true,
          fieldName: options?.schema?.invitation?.fields?.expiresAt
        },
        createdAt: {
          type: "date",
          required: true,
          fieldName: options?.schema?.invitation?.fields?.createdAt,
          defaultValue: () => /* @__PURE__ */ new Date()
        },
        inviterId: {
          type: "string",
          references: {
            model: "user",
            field: "id"
          },
          fieldName: options?.schema?.invitation?.fields?.inviterId,
          required: true
        },
        ...options?.schema?.invitation?.additionalFields || {}
      }
    }
  };
  return {
    id: "organization",
    endpoints: {
      ...shimContext(endpoints, {
        orgOptions: options || {},
        roles,
        getSession: async (context) => {
          return await getSessionFromCtx(context);
        }
      }),
      hasPermission: createHasPermission(options)
    },
    schema: {
      ...schema9,
      session: { fields: {
        activeOrganizationId: {
          type: "string",
          required: false,
          fieldName: options?.schema?.session?.fields?.activeOrganizationId
        },
        ...teamSupport ? { activeTeamId: {
          type: "string",
          required: false,
          fieldName: options?.schema?.session?.fields?.activeTeamId
        } } : {}
      } }
    },
    $Infer: {
      Organization: {},
      Invitation: {},
      Member: {},
      Team: teamSupport ? {} : {},
      TeamMember: teamSupport ? {} : {},
      ActiveOrganization: {}
    },
    $ERROR_CODES: ORGANIZATION_ERROR_CODES,
    options
  };
}

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/phone-number/error-codes.mjs
var PHONE_NUMBER_ERROR_CODES = defineErrorCodes({
  INVALID_PHONE_NUMBER: "Invalid phone number",
  PHONE_NUMBER_EXIST: "Phone number already exists",
  PHONE_NUMBER_NOT_EXIST: "phone number isn't registered",
  INVALID_PHONE_NUMBER_OR_PASSWORD: "Invalid phone number or password",
  UNEXPECTED_ERROR: "Unexpected error",
  OTP_NOT_FOUND: "OTP not found",
  OTP_EXPIRED: "OTP expired",
  INVALID_OTP: "Invalid OTP",
  PHONE_NUMBER_NOT_VERIFIED: "Phone number not verified",
  PHONE_NUMBER_CANNOT_BE_UPDATED: "Phone number cannot be updated",
  SEND_OTP_NOT_IMPLEMENTED: "sendOTP not implemented",
  TOO_MANY_ATTEMPTS: "Too many attempts"
});

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/phone-number/routes.mjs
var signInPhoneNumberBodySchema = object({
  phoneNumber: string().meta({ description: 'Phone number to sign in. Eg: "+1234567890"' }),
  password: string().meta({ description: "Password to use for sign in." }),
  rememberMe: boolean().meta({ description: "Remember the session. Eg: true" }).optional()
});
var signInPhoneNumber = (opts) => createAuthEndpoint("/sign-in/phone-number", {
  method: "POST",
  body: signInPhoneNumberBodySchema,
  metadata: { openapi: {
    summary: "Sign in with phone number",
    description: "Use this endpoint to sign in with phone number",
    responses: {
      200: {
        description: "Success",
        content: { "application/json": { schema: {
          type: "object",
          properties: {
            user: { $ref: "#/components/schemas/User" },
            session: { $ref: "#/components/schemas/Session" }
          }
        } } }
      },
      400: { description: "Invalid phone number or password" }
    }
  } }
}, async (ctx) => {
  const { password, phoneNumber: phoneNumber2 } = ctx.body;
  if (opts.phoneNumberValidator) {
    if (!await opts.phoneNumberValidator(ctx.body.phoneNumber)) throw new APIError("BAD_REQUEST", { message: PHONE_NUMBER_ERROR_CODES.INVALID_PHONE_NUMBER });
  }
  const user = await ctx.context.adapter.findOne({
    model: "user",
    where: [{
      field: "phoneNumber",
      value: phoneNumber2
    }]
  });
  if (!user) throw new APIError("UNAUTHORIZED", { message: PHONE_NUMBER_ERROR_CODES.INVALID_PHONE_NUMBER_OR_PASSWORD });
  if (opts.requireVerification) {
    if (!user.phoneNumberVerified) {
      const otp = generateOTP(opts.otpLength);
      await ctx.context.internalAdapter.createVerificationValue({
        value: otp,
        identifier: phoneNumber2,
        expiresAt: getDate(opts.expiresIn, "sec")
      });
      if (opts.sendOTP) await ctx.context.runInBackgroundOrAwait(opts.sendOTP({
        phoneNumber: phoneNumber2,
        code: otp
      }, ctx));
      throw new APIError("UNAUTHORIZED", { message: PHONE_NUMBER_ERROR_CODES.PHONE_NUMBER_NOT_VERIFIED });
    }
  }
  const credentialAccount = (await ctx.context.internalAdapter.findAccountByUserId(user.id)).find((a) => a.providerId === "credential");
  if (!credentialAccount) {
    ctx.context.logger.error("Credential account not found", { phoneNumber: phoneNumber2 });
    throw new APIError("UNAUTHORIZED", { message: PHONE_NUMBER_ERROR_CODES.INVALID_PHONE_NUMBER_OR_PASSWORD });
  }
  const currentPassword = credentialAccount?.password;
  if (!currentPassword) {
    ctx.context.logger.error("Password not found", { phoneNumber: phoneNumber2 });
    throw new APIError("UNAUTHORIZED", { message: PHONE_NUMBER_ERROR_CODES.UNEXPECTED_ERROR });
  }
  if (!await ctx.context.password.verify({
    hash: currentPassword,
    password
  })) {
    ctx.context.logger.error("Invalid password");
    throw new APIError("UNAUTHORIZED", { message: PHONE_NUMBER_ERROR_CODES.INVALID_PHONE_NUMBER_OR_PASSWORD });
  }
  const session = await ctx.context.internalAdapter.createSession(user.id, ctx.body.rememberMe === false);
  if (!session) {
    ctx.context.logger.error("Failed to create session");
    throw new APIError("UNAUTHORIZED", { message: BASE_ERROR_CODES.FAILED_TO_CREATE_SESSION });
  }
  await setSessionCookie(ctx, {
    session,
    user
  }, ctx.body.rememberMe === false);
  return ctx.json({
    token: session.token,
    user: {
      id: user.id,
      email: user.email,
      emailVerified: user.emailVerified,
      name: user.name,
      image: user.image,
      phoneNumber: user.phoneNumber,
      phoneNumberVerified: user.phoneNumberVerified,
      createdAt: user.createdAt,
      updatedAt: user.updatedAt
    }
  });
});
var sendPhoneNumberOTPBodySchema = object({ phoneNumber: string().meta({ description: 'Phone number to send OTP. Eg: "+1234567890"' }) });
var sendPhoneNumberOTP = (opts) => createAuthEndpoint("/phone-number/send-otp", {
  method: "POST",
  body: sendPhoneNumberOTPBodySchema,
  metadata: { openapi: {
    summary: "Send OTP to phone number",
    description: "Use this endpoint to send OTP to phone number",
    responses: { 200: {
      description: "Success",
      content: { "application/json": { schema: {
        type: "object",
        properties: { message: { type: "string" } }
      } } }
    } }
  } }
}, async (ctx) => {
  if (!opts?.sendOTP) {
    ctx.context.logger.warn("sendOTP not implemented");
    throw new APIError("NOT_IMPLEMENTED", { message: PHONE_NUMBER_ERROR_CODES.SEND_OTP_NOT_IMPLEMENTED });
  }
  if (opts.phoneNumberValidator) {
    if (!await opts.phoneNumberValidator(ctx.body.phoneNumber)) throw new APIError("BAD_REQUEST", { message: PHONE_NUMBER_ERROR_CODES.INVALID_PHONE_NUMBER });
  }
  const code = generateOTP(opts.otpLength);
  await ctx.context.internalAdapter.createVerificationValue({
    value: `${code}:0`,
    identifier: ctx.body.phoneNumber,
    expiresAt: getDate(opts.expiresIn, "sec")
  });
  await ctx.context.runInBackgroundOrAwait(opts.sendOTP({
    phoneNumber: ctx.body.phoneNumber,
    code
  }, ctx));
  return ctx.json({ message: "code sent" });
});
var verifyPhoneNumberBodySchema = object({
  phoneNumber: string().meta({ description: 'Phone number to verify. Eg: "+1234567890"' }),
  code: string().meta({ description: 'OTP code. Eg: "123456"' }),
  disableSession: boolean().meta({ description: "Disable session creation after verification. Eg: false" }).optional(),
  updatePhoneNumber: boolean().meta({ description: "Check if there is a session and update the phone number. Eg: true" }).optional()
});
var verifyPhoneNumber = (opts) => createAuthEndpoint("/phone-number/verify", {
  method: "POST",
  body: verifyPhoneNumberBodySchema,
  metadata: { openapi: {
    summary: "Verify phone number",
    description: "Use this endpoint to verify phone number",
    responses: {
      "200": {
        description: "Phone number verified successfully",
        content: { "application/json": { schema: {
          type: "object",
          properties: {
            status: {
              type: "boolean",
              description: "Indicates if the verification was successful",
              enum: [true]
            },
            token: {
              type: "string",
              nullable: true,
              description: "Session token if session is created, null if disableSession is true or no session is created"
            },
            user: {
              type: "object",
              nullable: true,
              properties: {
                id: {
                  type: "string",
                  description: "Unique identifier of the user"
                },
                email: {
                  type: "string",
                  format: "email",
                  nullable: true,
                  description: "User's email address"
                },
                emailVerified: {
                  type: "boolean",
                  nullable: true,
                  description: "Whether the email is verified"
                },
                name: {
                  type: "string",
                  nullable: true,
                  description: "User's name"
                },
                image: {
                  type: "string",
                  format: "uri",
                  nullable: true,
                  description: "User's profile image URL"
                },
                phoneNumber: {
                  type: "string",
                  description: "User's phone number"
                },
                phoneNumberVerified: {
                  type: "boolean",
                  description: "Whether the phone number is verified"
                },
                createdAt: {
                  type: "string",
                  format: "date-time",
                  description: "Timestamp when the user was created"
                },
                updatedAt: {
                  type: "string",
                  format: "date-time",
                  description: "Timestamp when the user was last updated"
                }
              },
              required: [
                "id",
                "phoneNumber",
                "phoneNumberVerified",
                "createdAt",
                "updatedAt"
              ],
              description: "User object with phone number details, null if no user is created or found"
            }
          },
          required: ["status"]
        } } }
      },
      400: { description: "Invalid OTP" }
    }
  } }
}, async (ctx) => {
  if (opts?.verifyOTP) {
    if (!await opts.verifyOTP({
      phoneNumber: ctx.body.phoneNumber,
      code: ctx.body.code
    }, ctx)) throw new APIError("BAD_REQUEST", { message: PHONE_NUMBER_ERROR_CODES.INVALID_OTP });
    const otp = await ctx.context.internalAdapter.findVerificationValue(ctx.body.phoneNumber);
    if (otp) await ctx.context.internalAdapter.deleteVerificationValue(otp.id);
  } else {
    const otp = await ctx.context.internalAdapter.findVerificationValue(ctx.body.phoneNumber);
    if (!otp || otp.expiresAt < /* @__PURE__ */ new Date()) {
      if (otp && otp.expiresAt < /* @__PURE__ */ new Date()) throw new APIError("BAD_REQUEST", { message: PHONE_NUMBER_ERROR_CODES.OTP_EXPIRED });
      throw new APIError("BAD_REQUEST", { message: PHONE_NUMBER_ERROR_CODES.OTP_NOT_FOUND });
    }
    const [otpValue, attempts] = otp.value.split(":");
    const allowedAttempts = opts?.allowedAttempts || 3;
    if (attempts && parseInt(attempts) >= allowedAttempts) {
      await ctx.context.internalAdapter.deleteVerificationValue(otp.id);
      throw new APIError("FORBIDDEN", { message: PHONE_NUMBER_ERROR_CODES.TOO_MANY_ATTEMPTS });
    }
    if (otpValue !== ctx.body.code) {
      await ctx.context.internalAdapter.updateVerificationValue(otp.id, { value: `${otpValue}:${parseInt(attempts || "0") + 1}` });
      throw new APIError("BAD_REQUEST", { message: PHONE_NUMBER_ERROR_CODES.INVALID_OTP });
    }
    await ctx.context.internalAdapter.deleteVerificationValue(otp.id);
  }
  if (ctx.body.updatePhoneNumber) {
    const session = await getSessionFromCtx(ctx);
    if (!session) throw new APIError("UNAUTHORIZED", { message: BASE_ERROR_CODES.USER_NOT_FOUND });
    if ((await ctx.context.adapter.findMany({
      model: "user",
      where: [{
        field: "phoneNumber",
        value: ctx.body.phoneNumber
      }]
    })).length) throw ctx.error("BAD_REQUEST", { message: PHONE_NUMBER_ERROR_CODES.PHONE_NUMBER_EXIST });
    let user$1 = await ctx.context.internalAdapter.updateUser(session.user.id, {
      [opts.phoneNumber]: ctx.body.phoneNumber,
      [opts.phoneNumberVerified]: true
    });
    return ctx.json({
      status: true,
      token: session.session.token,
      user: {
        id: user$1.id,
        email: user$1.email,
        emailVerified: user$1.emailVerified,
        name: user$1.name,
        image: user$1.image,
        phoneNumber: user$1.phoneNumber,
        phoneNumberVerified: user$1.phoneNumberVerified,
        createdAt: user$1.createdAt,
        updatedAt: user$1.updatedAt
      }
    });
  }
  let user = await ctx.context.adapter.findOne({
    model: "user",
    where: [{
      value: ctx.body.phoneNumber,
      field: opts.phoneNumber
    }]
  });
  if (!user) {
    if (opts?.signUpOnVerification) {
      user = await ctx.context.internalAdapter.createUser({
        email: opts.signUpOnVerification.getTempEmail(ctx.body.phoneNumber),
        name: opts.signUpOnVerification.getTempName ? opts.signUpOnVerification.getTempName(ctx.body.phoneNumber) : ctx.body.phoneNumber,
        [opts.phoneNumber]: ctx.body.phoneNumber,
        [opts.phoneNumberVerified]: true
      });
      if (!user) throw new APIError("INTERNAL_SERVER_ERROR", { message: BASE_ERROR_CODES.FAILED_TO_CREATE_USER });
    }
  } else user = await ctx.context.internalAdapter.updateUser(user.id, { [opts.phoneNumberVerified]: true });
  if (!user) throw new APIError("INTERNAL_SERVER_ERROR", { message: BASE_ERROR_CODES.FAILED_TO_UPDATE_USER });
  await opts?.callbackOnVerification?.({
    phoneNumber: ctx.body.phoneNumber,
    user
  }, ctx);
  if (!ctx.body.disableSession) {
    const session = await ctx.context.internalAdapter.createSession(user.id);
    if (!session) throw new APIError("INTERNAL_SERVER_ERROR", { message: BASE_ERROR_CODES.FAILED_TO_CREATE_SESSION });
    await setSessionCookie(ctx, {
      session,
      user
    });
    return ctx.json({
      status: true,
      token: session.token,
      user: {
        id: user.id,
        email: user.email,
        emailVerified: user.emailVerified,
        name: user.name,
        image: user.image,
        phoneNumber: user.phoneNumber,
        phoneNumberVerified: user.phoneNumberVerified,
        createdAt: user.createdAt,
        updatedAt: user.updatedAt
      }
    });
  }
  return ctx.json({
    status: true,
    token: null,
    user: {
      id: user.id,
      email: user.email,
      emailVerified: user.emailVerified,
      name: user.name,
      image: user.image,
      phoneNumber: user.phoneNumber,
      phoneNumberVerified: user.phoneNumberVerified,
      createdAt: user.createdAt,
      updatedAt: user.updatedAt
    }
  });
});
var requestPasswordResetPhoneNumberBodySchema = object({ phoneNumber: string() });
var requestPasswordResetPhoneNumber = (opts) => createAuthEndpoint("/phone-number/request-password-reset", {
  method: "POST",
  body: requestPasswordResetPhoneNumberBodySchema,
  metadata: { openapi: {
    description: "Request OTP for password reset via phone number",
    responses: { "200": {
      description: "OTP sent successfully for password reset",
      content: { "application/json": { schema: {
        type: "object",
        properties: { status: {
          type: "boolean",
          description: "Indicates if the OTP was sent successfully",
          enum: [true]
        } },
        required: ["status"]
      } } }
    } }
  } }
}, async (ctx) => {
  const user = await ctx.context.adapter.findOne({
    model: "user",
    where: [{
      value: ctx.body.phoneNumber,
      field: opts.phoneNumber
    }]
  });
  const code = generateOTP(opts.otpLength);
  await ctx.context.internalAdapter.createVerificationValue({
    value: `${code}:0`,
    identifier: `${ctx.body.phoneNumber}-request-password-reset`,
    expiresAt: getDate(opts.expiresIn, "sec")
  });
  if (!user) return ctx.json({ status: true });
  if (opts.sendPasswordResetOTP) await ctx.context.runInBackgroundOrAwait(opts.sendPasswordResetOTP({
    phoneNumber: ctx.body.phoneNumber,
    code
  }, ctx));
  return ctx.json({ status: true });
});
var resetPasswordPhoneNumberBodySchema = object({
  otp: string().meta({ description: 'The one time password to reset the password. Eg: "123456"' }),
  phoneNumber: string().meta({ description: 'The phone number to the account which intends to reset the password for. Eg: "+1234567890"' }),
  newPassword: string().meta({ description: `The new password. Eg: "new-and-secure-password"` })
});
var resetPasswordPhoneNumber = (opts) => createAuthEndpoint("/phone-number/reset-password", {
  method: "POST",
  body: resetPasswordPhoneNumberBodySchema,
  metadata: { openapi: {
    description: "Reset password using phone number OTP",
    responses: { "200": {
      description: "Password reset successfully",
      content: { "application/json": { schema: {
        type: "object",
        properties: { status: {
          type: "boolean",
          description: "Indicates if the password was reset successfully",
          enum: [true]
        } },
        required: ["status"]
      } } }
    } }
  } }
}, async (ctx) => {
  const verification = await ctx.context.internalAdapter.findVerificationValue(`${ctx.body.phoneNumber}-request-password-reset`);
  if (!verification) throw new APIError("BAD_REQUEST", { message: PHONE_NUMBER_ERROR_CODES.OTP_NOT_FOUND });
  if (verification.expiresAt < /* @__PURE__ */ new Date()) throw new APIError("BAD_REQUEST", { message: PHONE_NUMBER_ERROR_CODES.OTP_EXPIRED });
  const [otpValue, attempts] = verification.value.split(":");
  const allowedAttempts = opts?.allowedAttempts || 3;
  if (attempts && parseInt(attempts) >= allowedAttempts) {
    await ctx.context.internalAdapter.deleteVerificationValue(verification.id);
    throw new APIError("FORBIDDEN", { message: PHONE_NUMBER_ERROR_CODES.TOO_MANY_ATTEMPTS });
  }
  if (ctx.body.otp !== otpValue) {
    await ctx.context.internalAdapter.updateVerificationValue(verification.id, { value: `${otpValue}:${parseInt(attempts || "0") + 1}` });
    throw new APIError("BAD_REQUEST", { message: PHONE_NUMBER_ERROR_CODES.INVALID_OTP });
  }
  const user = await ctx.context.adapter.findOne({
    model: "user",
    where: [{
      field: "phoneNumber",
      value: ctx.body.phoneNumber
    }]
  });
  if (!user) throw new APIError("BAD_REQUEST", { message: PHONE_NUMBER_ERROR_CODES.UNEXPECTED_ERROR });
  const minLength = ctx.context.password.config.minPasswordLength;
  const maxLength = ctx.context.password.config.maxPasswordLength;
  if (ctx.body.newPassword.length < minLength) throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.PASSWORD_TOO_SHORT });
  if (ctx.body.newPassword.length > maxLength) throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.PASSWORD_TOO_LONG });
  const hashedPassword = await ctx.context.password.hash(ctx.body.newPassword);
  await ctx.context.internalAdapter.updatePassword(user.id, hashedPassword);
  await ctx.context.internalAdapter.deleteVerificationValue(verification.id);
  if (ctx.context.options.emailAndPassword?.revokeSessionsOnPasswordReset) await ctx.context.internalAdapter.deleteSessions(user.id);
  return ctx.json({ status: true });
});
function generateOTP(size) {
  return generateRandomString(size, "0-9");
}

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/phone-number/schema.mjs
var schema6 = { user: { fields: {
  phoneNumber: {
    type: "string",
    required: false,
    unique: true,
    sortable: true,
    returned: true
  },
  phoneNumberVerified: {
    type: "boolean",
    required: false,
    returned: true,
    input: false
  }
} } };

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/phone-number/index.mjs
var phoneNumber = (options) => {
  const opts = {
    expiresIn: options?.expiresIn || 300,
    otpLength: options?.otpLength || 6,
    ...options,
    phoneNumber: "phoneNumber",
    phoneNumberVerified: "phoneNumberVerified",
    code: "code",
    createdAt: "createdAt"
  };
  return {
    id: "phone-number",
    hooks: { before: [{
      matcher: (ctx) => ctx.path === "/update-user" && "phoneNumber" in ctx.body,
      handler: createAuthMiddleware(async (_ctx) => {
        throw new APIError("BAD_REQUEST", { message: PHONE_NUMBER_ERROR_CODES.PHONE_NUMBER_CANNOT_BE_UPDATED });
      })
    }] },
    endpoints: {
      signInPhoneNumber: signInPhoneNumber(opts),
      sendPhoneNumberOTP: sendPhoneNumberOTP(opts),
      verifyPhoneNumber: verifyPhoneNumber(opts),
      requestPasswordResetPhoneNumber: requestPasswordResetPhoneNumber(opts),
      resetPasswordPhoneNumber: resetPasswordPhoneNumber(opts)
    },
    schema: mergeSchema(schema6, options?.schema),
    rateLimit: [{
      pathMatcher(path) {
        return path.startsWith("/phone-number");
      },
      window: 60 * 1e3,
      max: 10
    }],
    options,
    $ERROR_CODES: PHONE_NUMBER_ERROR_CODES
  };
};

// ../node_modules/.bun/@noble+hashes@2.0.1/node_modules/@noble/hashes/sha3.js
var _0n = BigInt(0);
var _1n = BigInt(1);
var _2n = BigInt(2);
var _7n = BigInt(7);
var _256n = BigInt(256);
var _0x71n = BigInt(113);
var SHA3_PI = [];
var SHA3_ROTL = [];
var _SHA3_IOTA = [];
for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
  [x, y] = [y, (2 * x + 3 * y) % 5];
  SHA3_PI.push(2 * (5 * y + x));
  SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
  let t = _0n;
  for (let j = 0; j < 7; j++) {
    R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
    if (R & _2n)
      t ^= _1n << (_1n << BigInt(j)) - _1n;
  }
  _SHA3_IOTA.push(t);
}
var IOTAS = split(_SHA3_IOTA, true);
var SHA3_IOTA_H = IOTAS[0];
var SHA3_IOTA_L = IOTAS[1];
var rotlH = (h, l, s) => s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s);
var rotlL = (h, l, s) => s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s);
function keccakP(s, rounds = 24) {
  const B = new Uint32Array(5 * 2);
  for (let round = 24 - rounds; round < 24; round++) {
    for (let x = 0; x < 10; x++)
      B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
    for (let x = 0; x < 10; x += 2) {
      const idx1 = (x + 8) % 10;
      const idx0 = (x + 2) % 10;
      const B0 = B[idx0];
      const B1 = B[idx0 + 1];
      const Th = rotlH(B0, B1, 1) ^ B[idx1];
      const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
      for (let y = 0; y < 50; y += 10) {
        s[x + y] ^= Th;
        s[x + y + 1] ^= Tl;
      }
    }
    let curH = s[2];
    let curL = s[3];
    for (let t = 0; t < 24; t++) {
      const shift = SHA3_ROTL[t];
      const Th = rotlH(curH, curL, shift);
      const Tl = rotlL(curH, curL, shift);
      const PI = SHA3_PI[t];
      curH = s[PI];
      curL = s[PI + 1];
      s[PI] = Th;
      s[PI + 1] = Tl;
    }
    for (let y = 0; y < 50; y += 10) {
      for (let x = 0; x < 10; x++)
        B[x] = s[y + x];
      for (let x = 0; x < 10; x++)
        s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
    }
    s[0] ^= SHA3_IOTA_H[round];
    s[1] ^= SHA3_IOTA_L[round];
  }
  clean(B);
}
var Keccak = class _Keccak {
  state;
  pos = 0;
  posOut = 0;
  finished = false;
  state32;
  destroyed = false;
  blockLen;
  suffix;
  outputLen;
  enableXOF = false;
  rounds;
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
    this.blockLen = blockLen;
    this.suffix = suffix;
    this.outputLen = outputLen;
    this.enableXOF = enableXOF;
    this.rounds = rounds;
    anumber(outputLen, "outputLen");
    if (!(0 < blockLen && blockLen < 200))
      throw new Error("only keccak-f1600 function is supported");
    this.state = new Uint8Array(200);
    this.state32 = u32(this.state);
  }
  clone() {
    return this._cloneInto();
  }
  keccak() {
    swap32IfBE(this.state32);
    keccakP(this.state32, this.rounds);
    swap32IfBE(this.state32);
    this.posOut = 0;
    this.pos = 0;
  }
  update(data) {
    aexists(this);
    abytes(data);
    const { blockLen, state } = this;
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      for (let i = 0; i < take; i++)
        state[this.pos++] ^= data[pos++];
      if (this.pos === blockLen)
        this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    const { state, suffix, pos, blockLen } = this;
    state[pos] ^= suffix;
    if ((suffix & 128) !== 0 && pos === blockLen - 1)
      this.keccak();
    state[blockLen - 1] ^= 128;
    this.keccak();
  }
  writeInto(out) {
    aexists(this, false);
    abytes(out);
    this.finish();
    const bufferOut = this.state;
    const { blockLen } = this;
    for (let pos = 0, len = out.length; pos < len; ) {
      if (this.posOut >= blockLen)
        this.keccak();
      const take = Math.min(blockLen - this.posOut, len - pos);
      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
      this.posOut += take;
      pos += take;
    }
    return out;
  }
  xofInto(out) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(out);
  }
  xof(bytes) {
    anumber(bytes);
    return this.xofInto(new Uint8Array(bytes));
  }
  digestInto(out) {
    aoutput(out, this);
    if (this.finished)
      throw new Error("digest() was already called");
    this.writeInto(out);
    this.destroy();
    return out;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true;
    clean(this.state);
  }
  _cloneInto(to) {
    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
    to ||= new _Keccak(blockLen, suffix, outputLen, enableXOF, rounds);
    to.state32.set(this.state32);
    to.pos = this.pos;
    to.posOut = this.posOut;
    to.finished = this.finished;
    to.rounds = rounds;
    to.suffix = suffix;
    to.outputLen = outputLen;
    to.enableXOF = enableXOF;
    to.destroyed = this.destroyed;
    return to;
  }
};
var genKeccak = (suffix, blockLen, outputLen, info = {}) => createHasher(() => new Keccak(blockLen, suffix, outputLen), info);
var sha3_224 = genKeccak(
  6,
  144,
  28,
  oidNist(7)
);
var sha3_256 = genKeccak(
  6,
  136,
  32,
  oidNist(8)
);
var sha3_384 = genKeccak(
  6,
  104,
  48,
  oidNist(9)
);
var sha3_512 = genKeccak(
  6,
  72,
  64,
  oidNist(10)
);
var keccak_224 = genKeccak(1, 144, 28);
var keccak_256 = genKeccak(1, 136, 32);
var keccak_384 = genKeccak(1, 104, 48);
var keccak_512 = genKeccak(1, 72, 64);
var genShake = (suffix, blockLen, outputLen, info = {}) => createHasher((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true), info);
var shake128 = genShake(31, 168, 16, oidNist(11));
var shake256 = genShake(31, 136, 32, oidNist(12));
var shake128_32 = genShake(31, 168, 32, oidNist(11));
var shake256_64 = genShake(31, 136, 64, oidNist(12));

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/utils/hashing.mjs
function toChecksumAddress(address) {
  address = address.toLowerCase().replace("0x", "");
  const hash = [...keccak_256(utf8ToBytes(address))].map((v) => v.toString(16).padStart(2, "0")).join("");
  let ret = "0x";
  for (let i = 0; i < 40; i++) if (parseInt(hash[i], 16) >= 8) ret += address[i].toUpperCase();
  else ret += address[i];
  return ret;
}

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/siwe/schema.mjs
var schema7 = { walletAddress: { fields: {
  userId: {
    type: "string",
    references: {
      model: "user",
      field: "id"
    },
    required: true,
    index: true
  },
  address: {
    type: "string",
    required: true
  },
  chainId: {
    type: "number",
    required: true
  },
  isPrimary: {
    type: "boolean",
    defaultValue: false
  },
  createdAt: {
    type: "date",
    required: true
  }
} } };

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/siwe/index.mjs
var getSiweNonceBodySchema = object({
  walletAddress: string().regex(/^0[xX][a-fA-F0-9]{40}$/i).length(42),
  chainId: number().int().positive().max(2147483647).optional().default(1)
});
var siwe = (options) => ({
  id: "siwe",
  schema: mergeSchema(schema7, options?.schema),
  endpoints: {
    getSiweNonce: createAuthEndpoint("/siwe/nonce", {
      method: "POST",
      body: getSiweNonceBodySchema
    }, async (ctx) => {
      const { walletAddress: rawWalletAddress, chainId } = ctx.body;
      const walletAddress = toChecksumAddress(rawWalletAddress);
      const nonce = await options.getNonce();
      await ctx.context.internalAdapter.createVerificationValue({
        identifier: `siwe:${walletAddress}:${chainId}`,
        value: nonce,
        expiresAt: new Date(Date.now() + 900 * 1e3)
      });
      return ctx.json({ nonce });
    }),
    verifySiweMessage: createAuthEndpoint("/siwe/verify", {
      method: "POST",
      body: object({
        message: string().min(1),
        signature: string().min(1),
        walletAddress: string().regex(/^0[xX][a-fA-F0-9]{40}$/i).length(42),
        chainId: number().int().positive().max(2147483647).optional().default(1),
        email: email().optional()
      }).refine((data) => options.anonymous !== false || !!data.email, {
        message: "Email is required when the anonymous plugin option is disabled.",
        path: ["email"]
      }),
      requireRequest: true
    }, async (ctx) => {
      const { message, signature, walletAddress: rawWalletAddress, chainId, email: email2 } = ctx.body;
      const walletAddress = toChecksumAddress(rawWalletAddress);
      const isAnon = options.anonymous ?? true;
      if (!isAnon && !email2) throw new APIError("BAD_REQUEST", {
        message: "Email is required when anonymous is disabled.",
        status: 400
      });
      try {
        const verification = await ctx.context.internalAdapter.findVerificationValue(`siwe:${walletAddress}:${chainId}`);
        if (!verification || /* @__PURE__ */ new Date() > verification.expiresAt) throw new APIError("UNAUTHORIZED", {
          message: "Unauthorized: Invalid or expired nonce",
          status: 401,
          code: "UNAUTHORIZED_INVALID_OR_EXPIRED_NONCE"
        });
        const { value: nonce } = verification;
        if (!await options.verifyMessage({
          message,
          signature,
          address: walletAddress,
          chainId,
          cacao: {
            h: { t: "caip122" },
            p: {
              domain: options.domain,
              aud: options.domain,
              nonce,
              iss: options.domain,
              version: "1"
            },
            s: {
              t: "eip191",
              s: signature
            }
          }
        })) throw new APIError("UNAUTHORIZED", {
          message: "Unauthorized: Invalid SIWE signature",
          status: 401
        });
        await ctx.context.internalAdapter.deleteVerificationValue(verification.id);
        let user = null;
        const existingWalletAddress = await ctx.context.adapter.findOne({
          model: "walletAddress",
          where: [{
            field: "address",
            operator: "eq",
            value: walletAddress
          }, {
            field: "chainId",
            operator: "eq",
            value: chainId
          }]
        });
        if (existingWalletAddress) user = await ctx.context.adapter.findOne({
          model: "user",
          where: [{
            field: "id",
            operator: "eq",
            value: existingWalletAddress.userId
          }]
        });
        else {
          const anyWalletAddress = await ctx.context.adapter.findOne({
            model: "walletAddress",
            where: [{
              field: "address",
              operator: "eq",
              value: walletAddress
            }]
          });
          if (anyWalletAddress) user = await ctx.context.adapter.findOne({
            model: "user",
            where: [{
              field: "id",
              operator: "eq",
              value: anyWalletAddress.userId
            }]
          });
        }
        if (!user) {
          const domain = options.emailDomainName ?? getOrigin(ctx.context.baseURL);
          const userEmail = !isAnon && email2 ? email2 : `${walletAddress}@${domain}`;
          const { name, avatar } = await options.ensLookup?.({ walletAddress }) ?? {};
          user = await ctx.context.internalAdapter.createUser({
            name: name ?? walletAddress,
            email: userEmail,
            image: avatar ?? ""
          });
          await ctx.context.adapter.create({
            model: "walletAddress",
            data: {
              userId: user.id,
              address: walletAddress,
              chainId,
              isPrimary: true,
              createdAt: /* @__PURE__ */ new Date()
            }
          });
          await ctx.context.internalAdapter.createAccount({
            userId: user.id,
            providerId: "siwe",
            accountId: `${walletAddress}:${chainId}`,
            createdAt: /* @__PURE__ */ new Date(),
            updatedAt: /* @__PURE__ */ new Date()
          });
        } else if (!existingWalletAddress) {
          await ctx.context.adapter.create({
            model: "walletAddress",
            data: {
              userId: user.id,
              address: walletAddress,
              chainId,
              isPrimary: false,
              createdAt: /* @__PURE__ */ new Date()
            }
          });
          await ctx.context.internalAdapter.createAccount({
            userId: user.id,
            providerId: "siwe",
            accountId: `${walletAddress}:${chainId}`,
            createdAt: /* @__PURE__ */ new Date(),
            updatedAt: /* @__PURE__ */ new Date()
          });
        }
        const session = await ctx.context.internalAdapter.createSession(user.id);
        if (!session) throw new APIError("INTERNAL_SERVER_ERROR", {
          message: "Internal Server Error",
          status: 500
        });
        await setSessionCookie(ctx, {
          session,
          user
        });
        return ctx.json({
          token: session.token,
          success: true,
          user: {
            id: user.id,
            walletAddress,
            chainId
          }
        });
      } catch (error) {
        if (error instanceof APIError) throw error;
        throw new APIError("UNAUTHORIZED", {
          message: "Something went wrong. Please try again later.",
          error: error instanceof Error ? error.message : "Unknown error",
          status: 401
        });
      }
    })
  },
  options
});

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/two-factor/error-code.mjs
var TWO_FACTOR_ERROR_CODES = defineErrorCodes({
  OTP_NOT_ENABLED: "OTP not enabled",
  OTP_HAS_EXPIRED: "OTP has expired",
  TOTP_NOT_ENABLED: "TOTP not enabled",
  TWO_FACTOR_NOT_ENABLED: "Two factor isn't enabled",
  BACKUP_CODES_NOT_ENABLED: "Backup codes aren't enabled",
  INVALID_BACKUP_CODE: "Invalid backup code",
  INVALID_CODE: "Invalid code",
  TOO_MANY_ATTEMPTS_REQUEST_NEW_CODE: "Too many attempts. Please request a new code.",
  INVALID_TWO_FACTOR_COOKIE: "Invalid two factor cookie"
});

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/two-factor/constant.mjs
var TWO_FACTOR_COOKIE_NAME = "two_factor";
var TRUST_DEVICE_COOKIE_NAME = "trust_device";
var TRUST_DEVICE_COOKIE_MAX_AGE = 720 * 60 * 60;

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/two-factor/verify-two-factor.mjs
async function verifyTwoFactor(ctx) {
  const invalid = (errorKey) => {
    throw new APIError("UNAUTHORIZED", { message: TWO_FACTOR_ERROR_CODES[errorKey] });
  };
  const session = await getSessionFromCtx(ctx);
  if (!session) {
    const cookieName = ctx.context.createAuthCookie(TWO_FACTOR_COOKIE_NAME);
    const twoFactorCookie = await ctx.getSignedCookie(cookieName.name, ctx.context.secret);
    if (!twoFactorCookie) throw new APIError("UNAUTHORIZED", { message: TWO_FACTOR_ERROR_CODES.INVALID_TWO_FACTOR_COOKIE });
    const verificationToken = await ctx.context.internalAdapter.findVerificationValue(twoFactorCookie);
    if (!verificationToken) throw new APIError("UNAUTHORIZED", { message: TWO_FACTOR_ERROR_CODES.INVALID_TWO_FACTOR_COOKIE });
    const user = await ctx.context.internalAdapter.findUserById(verificationToken.value);
    if (!user) throw new APIError("UNAUTHORIZED", { message: TWO_FACTOR_ERROR_CODES.INVALID_TWO_FACTOR_COOKIE });
    const dontRememberMe = await ctx.getSignedCookie(ctx.context.authCookies.dontRememberToken.name, ctx.context.secret);
    return {
      valid: async (ctx$1) => {
        const session$1 = await ctx$1.context.internalAdapter.createSession(verificationToken.value, !!dontRememberMe);
        if (!session$1) throw new APIError("INTERNAL_SERVER_ERROR", { message: "failed to create session" });
        await ctx$1.context.internalAdapter.deleteVerificationValue(verificationToken.id);
        await setSessionCookie(ctx$1, {
          session: session$1,
          user
        });
        ctx$1.setCookie(cookieName.name, "", { maxAge: 0 });
        if (ctx$1.body.trustDevice) {
          const trustDeviceCookie = ctx$1.context.createAuthCookie(TRUST_DEVICE_COOKIE_NAME, { maxAge: TRUST_DEVICE_COOKIE_MAX_AGE });
          const token = await createHMAC("SHA-256", "base64urlnopad").sign(ctx$1.context.secret, `${user.id}!${session$1.token}`);
          await ctx$1.setSignedCookie(trustDeviceCookie.name, `${token}!${session$1.token}`, ctx$1.context.secret, trustDeviceCookie.attributes);
          ctx$1.setCookie(ctx$1.context.authCookies.dontRememberToken.name, "", { maxAge: 0 });
        }
        return ctx$1.json({
          token: session$1.token,
          user: {
            id: user.id,
            email: user.email,
            emailVerified: user.emailVerified,
            name: user.name,
            image: user.image,
            createdAt: user.createdAt,
            updatedAt: user.updatedAt
          }
        });
      },
      invalid,
      session: {
        session: null,
        user
      },
      key: twoFactorCookie
    };
  }
  return {
    valid: async (ctx$1) => {
      return ctx$1.json({
        token: session.session.token,
        user: {
          id: session.user.id,
          email: session.user.email,
          emailVerified: session.user.emailVerified,
          name: session.user.name,
          image: session.user.image,
          createdAt: session.user.createdAt,
          updatedAt: session.user.updatedAt
        }
      });
    },
    invalid,
    session,
    key: `${session.user.id}!${session.session.id}`
  };
}

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/two-factor/backup-codes/index.mjs
function generateBackupCodesFn(options) {
  return Array.from({ length: options?.amount ?? 10 }).fill(null).map(() => generateRandomString(options?.length ?? 10, "a-z", "0-9", "A-Z")).map((code) => `${code.slice(0, 5)}-${code.slice(5)}`);
}
async function generateBackupCodes(secret, options) {
  const backupCodes = options?.customBackupCodesGenerate ? options.customBackupCodesGenerate() : generateBackupCodesFn(options);
  if (options?.storeBackupCodes === "encrypted") return {
    backupCodes,
    encryptedBackupCodes: await symmetricEncrypt({
      data: JSON.stringify(backupCodes),
      key: secret
    })
  };
  if (typeof options?.storeBackupCodes === "object" && "encrypt" in options?.storeBackupCodes) return {
    backupCodes,
    encryptedBackupCodes: await options?.storeBackupCodes.encrypt(JSON.stringify(backupCodes))
  };
  return {
    backupCodes,
    encryptedBackupCodes: JSON.stringify(backupCodes)
  };
}
async function verifyBackupCode(data, key, options) {
  const codes = await getBackupCodes(data.backupCodes, key, options);
  if (!codes) return {
    status: false,
    updated: null
  };
  return {
    status: codes.includes(data.code),
    updated: codes.filter((code) => code !== data.code)
  };
}
async function getBackupCodes(backupCodes, key, options) {
  if (options?.storeBackupCodes === "encrypted") return safeJSONParse(await symmetricDecrypt({
    key,
    data: backupCodes
  }));
  if (typeof options?.storeBackupCodes === "object" && "decrypt" in options?.storeBackupCodes) return safeJSONParse(await options?.storeBackupCodes.decrypt(backupCodes));
  return safeJSONParse(backupCodes);
}
var verifyBackupCodeBodySchema = object({
  code: string().meta({ description: `A backup code to verify. Eg: "123456"` }),
  disableSession: boolean().meta({ description: "If true, the session cookie will not be set." }).optional(),
  trustDevice: boolean().meta({ description: "If true, the device will be trusted for 30 days. It'll be refreshed on every sign in request within this time. Eg: true" }).optional()
});
var viewBackupCodesBodySchema = object({ userId: coerce_exports.string().meta({ description: `The user ID to view all backup codes. Eg: "user-id"` }) });
var generateBackupCodesBodySchema = object({ password: string().meta({ description: "The users password." }) });
var backupCode2fa = (opts) => {
  const twoFactorTable = "twoFactor";
  return {
    id: "backup_code",
    endpoints: {
      verifyBackupCode: createAuthEndpoint("/two-factor/verify-backup-code", {
        method: "POST",
        body: verifyBackupCodeBodySchema,
        metadata: { openapi: {
          description: "Verify a backup code for two-factor authentication",
          responses: { "200": {
            description: "Backup code verified successfully",
            content: { "application/json": { schema: {
              type: "object",
              properties: {
                user: {
                  type: "object",
                  properties: {
                    id: {
                      type: "string",
                      description: "Unique identifier of the user"
                    },
                    email: {
                      type: "string",
                      format: "email",
                      nullable: true,
                      description: "User's email address"
                    },
                    emailVerified: {
                      type: "boolean",
                      nullable: true,
                      description: "Whether the email is verified"
                    },
                    name: {
                      type: "string",
                      nullable: true,
                      description: "User's name"
                    },
                    image: {
                      type: "string",
                      format: "uri",
                      nullable: true,
                      description: "User's profile image URL"
                    },
                    twoFactorEnabled: {
                      type: "boolean",
                      description: "Whether two-factor authentication is enabled for the user"
                    },
                    createdAt: {
                      type: "string",
                      format: "date-time",
                      description: "Timestamp when the user was created"
                    },
                    updatedAt: {
                      type: "string",
                      format: "date-time",
                      description: "Timestamp when the user was last updated"
                    }
                  },
                  required: [
                    "id",
                    "twoFactorEnabled",
                    "createdAt",
                    "updatedAt"
                  ],
                  description: "The authenticated user object with two-factor details"
                },
                session: {
                  type: "object",
                  properties: {
                    token: {
                      type: "string",
                      description: "Session token"
                    },
                    userId: {
                      type: "string",
                      description: "ID of the user associated with the session"
                    },
                    createdAt: {
                      type: "string",
                      format: "date-time",
                      description: "Timestamp when the session was created"
                    },
                    expiresAt: {
                      type: "string",
                      format: "date-time",
                      description: "Timestamp when the session expires"
                    }
                  },
                  required: [
                    "token",
                    "userId",
                    "createdAt",
                    "expiresAt"
                  ],
                  description: "The current session object, included unless disableSession is true"
                }
              },
              required: ["user", "session"]
            } } }
          } }
        } }
      }, async (ctx) => {
        const { session, valid } = await verifyTwoFactor(ctx);
        const user = session.user;
        const twoFactor2 = await ctx.context.adapter.findOne({
          model: twoFactorTable,
          where: [{
            field: "userId",
            value: user.id
          }]
        });
        if (!twoFactor2) throw new APIError("BAD_REQUEST", { message: TWO_FACTOR_ERROR_CODES.BACKUP_CODES_NOT_ENABLED });
        const validate = await verifyBackupCode({
          backupCodes: twoFactor2.backupCodes,
          code: ctx.body.code
        }, ctx.context.secret, opts);
        if (!validate.status) throw new APIError("UNAUTHORIZED", { message: TWO_FACTOR_ERROR_CODES.INVALID_BACKUP_CODE });
        const updatedBackupCodes = await symmetricEncrypt({
          key: ctx.context.secret,
          data: JSON.stringify(validate.updated)
        });
        if (!await ctx.context.adapter.updateMany({
          model: twoFactorTable,
          update: { backupCodes: updatedBackupCodes },
          where: [{
            field: "userId",
            value: user.id
          }, {
            field: "backupCodes",
            value: twoFactor2.backupCodes
          }]
        })) throw new APIError("CONFLICT", { message: "Failed to verify backup code. Please try again." });
        if (!ctx.body.disableSession) return valid(ctx);
        return ctx.json({
          token: session.session?.token,
          user: {
            id: session.user?.id,
            email: session.user.email,
            emailVerified: session.user.emailVerified,
            name: session.user.name,
            image: session.user.image,
            createdAt: session.user.createdAt,
            updatedAt: session.user.updatedAt
          }
        });
      }),
      generateBackupCodes: createAuthEndpoint("/two-factor/generate-backup-codes", {
        method: "POST",
        body: generateBackupCodesBodySchema,
        use: [sessionMiddleware],
        metadata: { openapi: {
          description: "Generate new backup codes for two-factor authentication",
          responses: { "200": {
            description: "Backup codes generated successfully",
            content: { "application/json": { schema: {
              type: "object",
              properties: {
                status: {
                  type: "boolean",
                  description: "Indicates if the backup codes were generated successfully",
                  enum: [true]
                },
                backupCodes: {
                  type: "array",
                  items: { type: "string" },
                  description: "Array of generated backup codes in plain text"
                }
              },
              required: ["status", "backupCodes"]
            } } }
          } }
        } }
      }, async (ctx) => {
        const user = ctx.context.session.user;
        if (!user.twoFactorEnabled) throw new APIError("BAD_REQUEST", { message: TWO_FACTOR_ERROR_CODES.TWO_FACTOR_NOT_ENABLED });
        await ctx.context.password.checkPassword(user.id, ctx);
        const backupCodes = await generateBackupCodes(ctx.context.secret, opts);
        await ctx.context.adapter.updateMany({
          model: twoFactorTable,
          update: { backupCodes: backupCodes.encryptedBackupCodes },
          where: [{
            field: "userId",
            value: ctx.context.session.user.id
          }]
        });
        return ctx.json({
          status: true,
          backupCodes: backupCodes.backupCodes
        });
      }),
      viewBackupCodes: createAuthEndpoint({
        method: "POST",
        body: viewBackupCodesBodySchema
      }, async (ctx) => {
        const twoFactor2 = await ctx.context.adapter.findOne({
          model: twoFactorTable,
          where: [{
            field: "userId",
            value: ctx.body.userId
          }]
        });
        if (!twoFactor2) throw new APIError("BAD_REQUEST", { message: TWO_FACTOR_ERROR_CODES.BACKUP_CODES_NOT_ENABLED });
        const decryptedBackupCodes = await getBackupCodes(twoFactor2.backupCodes, ctx.context.secret, opts);
        if (!decryptedBackupCodes) throw new APIError("BAD_REQUEST", { message: TWO_FACTOR_ERROR_CODES.INVALID_BACKUP_CODE });
        return ctx.json({
          status: true,
          backupCodes: decryptedBackupCodes
        });
      })
    }
  };
};

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/two-factor/utils.mjs
var defaultKeyHasher5 = async (token) => {
  const hash = await createHash("SHA-256").digest(new TextEncoder().encode(token));
  return base64Url.encode(new Uint8Array(hash), { padding: false });
};

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/two-factor/otp/index.mjs
var verifyOTPBodySchema = object({
  code: string().meta({ description: 'The otp code to verify. Eg: "012345"' }),
  trustDevice: boolean().optional().meta({ description: "If true, the device will be trusted for 30 days. It'll be refreshed on every sign in request within this time. Eg: true" })
});
var send2FaOTPBodySchema = object({ trustDevice: boolean().optional().meta({ description: "If true, the device will be trusted for 30 days. It'll be refreshed on every sign in request within this time. Eg: true" }) }).optional();
var otp2fa = (options) => {
  const opts = {
    storeOTP: "plain",
    digits: 6,
    ...options,
    period: (options?.period || 3) * 60 * 1e3
  };
  async function storeOTP2(ctx, otp) {
    if (opts.storeOTP === "hashed") return await defaultKeyHasher5(otp);
    if (typeof opts.storeOTP === "object" && "hash" in opts.storeOTP) return await opts.storeOTP.hash(otp);
    if (typeof opts.storeOTP === "object" && "encrypt" in opts.storeOTP) return await opts.storeOTP.encrypt(otp);
    if (opts.storeOTP === "encrypted") return await symmetricEncrypt({
      key: ctx.context.secret,
      data: otp
    });
    return otp;
  }
  async function decryptOTP(ctx, otp) {
    if (opts.storeOTP === "hashed") return await defaultKeyHasher5(otp);
    if (opts.storeOTP === "encrypted") return await symmetricDecrypt({
      key: ctx.context.secret,
      data: otp
    });
    if (typeof opts.storeOTP === "object" && "encrypt" in opts.storeOTP) return await opts.storeOTP.decrypt(otp);
    if (typeof opts.storeOTP === "object" && "hash" in opts.storeOTP) return await opts.storeOTP.hash(otp);
    return otp;
  }
  return {
    id: "otp",
    endpoints: {
      sendTwoFactorOTP: createAuthEndpoint("/two-factor/send-otp", {
        method: "POST",
        body: send2FaOTPBodySchema,
        metadata: { openapi: {
          summary: "Send two factor OTP",
          description: "Send two factor OTP to the user",
          responses: { 200: {
            description: "Successful response",
            content: { "application/json": { schema: {
              type: "object",
              properties: { status: { type: "boolean" } }
            } } }
          } }
        } }
      }, async (ctx) => {
        if (!options || !options.sendOTP) {
          ctx.context.logger.error("send otp isn't configured. Please configure the send otp function on otp options.");
          throw new APIError("BAD_REQUEST", { message: "otp isn't configured" });
        }
        const { session, key } = await verifyTwoFactor(ctx);
        const code = generateRandomString(opts.digits, "0-9");
        const hashedCode = await storeOTP2(ctx, code);
        await ctx.context.internalAdapter.createVerificationValue({
          value: `${hashedCode}:0`,
          identifier: `2fa-otp-${key}`,
          expiresAt: new Date(Date.now() + opts.period)
        });
        const sendOTPResult = options.sendOTP({
          user: session.user,
          otp: code
        }, ctx);
        if (sendOTPResult instanceof Promise) await ctx.context.runInBackgroundOrAwait(sendOTPResult.catch((e) => {
          ctx.context.logger.error("Failed to send two-factor OTP", e);
        }));
        return ctx.json({ status: true });
      }),
      verifyTwoFactorOTP: createAuthEndpoint("/two-factor/verify-otp", {
        method: "POST",
        body: verifyOTPBodySchema,
        metadata: { openapi: {
          summary: "Verify two factor OTP",
          description: "Verify two factor OTP",
          responses: { "200": {
            description: "Two-factor OTP verified successfully",
            content: { "application/json": { schema: {
              type: "object",
              properties: {
                token: {
                  type: "string",
                  description: "Session token for the authenticated session"
                },
                user: {
                  type: "object",
                  properties: {
                    id: {
                      type: "string",
                      description: "Unique identifier of the user"
                    },
                    email: {
                      type: "string",
                      format: "email",
                      nullable: true,
                      description: "User's email address"
                    },
                    emailVerified: {
                      type: "boolean",
                      nullable: true,
                      description: "Whether the email is verified"
                    },
                    name: {
                      type: "string",
                      nullable: true,
                      description: "User's name"
                    },
                    image: {
                      type: "string",
                      format: "uri",
                      nullable: true,
                      description: "User's profile image URL"
                    },
                    createdAt: {
                      type: "string",
                      format: "date-time",
                      description: "Timestamp when the user was created"
                    },
                    updatedAt: {
                      type: "string",
                      format: "date-time",
                      description: "Timestamp when the user was last updated"
                    }
                  },
                  required: [
                    "id",
                    "createdAt",
                    "updatedAt"
                  ],
                  description: "The authenticated user object"
                }
              },
              required: ["token", "user"]
            } } }
          } }
        } }
      }, async (ctx) => {
        const { session, key, valid, invalid } = await verifyTwoFactor(ctx);
        const toCheckOtp = await ctx.context.internalAdapter.findVerificationValue(`2fa-otp-${key}`);
        const [otp, counter] = toCheckOtp?.value?.split(":") ?? [];
        const decryptedOtp = await decryptOTP(ctx, otp);
        if (!toCheckOtp || toCheckOtp.expiresAt < /* @__PURE__ */ new Date()) {
          if (toCheckOtp) await ctx.context.internalAdapter.deleteVerificationValue(toCheckOtp.id);
          throw new APIError("BAD_REQUEST", { message: TWO_FACTOR_ERROR_CODES.OTP_HAS_EXPIRED });
        }
        const allowedAttempts = options?.allowedAttempts || 5;
        if (parseInt(counter) >= allowedAttempts) {
          await ctx.context.internalAdapter.deleteVerificationValue(toCheckOtp.id);
          throw new APIError("BAD_REQUEST", { message: TWO_FACTOR_ERROR_CODES.TOO_MANY_ATTEMPTS_REQUEST_NEW_CODE });
        }
        if (constantTimeEqual(new TextEncoder().encode(decryptedOtp), new TextEncoder().encode(ctx.body.code))) {
          if (!session.user.twoFactorEnabled) {
            if (!session.session) throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.FAILED_TO_CREATE_SESSION });
            const updatedUser = await ctx.context.internalAdapter.updateUser(session.user.id, { twoFactorEnabled: true });
            const newSession = await ctx.context.internalAdapter.createSession(session.user.id, false, session.session);
            await ctx.context.internalAdapter.deleteSession(session.session.token);
            await setSessionCookie(ctx, {
              session: newSession,
              user: updatedUser
            });
            return ctx.json({
              token: newSession.token,
              user: {
                id: updatedUser.id,
                email: updatedUser.email,
                emailVerified: updatedUser.emailVerified,
                name: updatedUser.name,
                image: updatedUser.image,
                createdAt: updatedUser.createdAt,
                updatedAt: updatedUser.updatedAt
              }
            });
          }
          return valid(ctx);
        } else {
          await ctx.context.internalAdapter.updateVerificationValue(toCheckOtp.id, { value: `${otp}:${(parseInt(counter, 10) || 0) + 1}` });
          return invalid("INVALID_CODE");
        }
      })
    }
  };
};

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/two-factor/schema.mjs
var schema8 = {
  user: { fields: { twoFactorEnabled: {
    type: "boolean",
    required: false,
    defaultValue: false,
    input: false
  } } },
  twoFactor: { fields: {
    secret: {
      type: "string",
      required: true,
      returned: false,
      index: true
    },
    backupCodes: {
      type: "string",
      required: true,
      returned: false
    },
    userId: {
      type: "string",
      required: true,
      returned: false,
      references: {
        model: "user",
        field: "id"
      },
      index: true
    }
  } }
};

// ../node_modules/.bun/@better-auth+utils@0.3.0/node_modules/@better-auth/utils/dist/base32.mjs
function getAlphabet(hex) {
  return hex ? "0123456789ABCDEFGHIJKLMNOPQRSTUV" : "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
}
function createDecodeMap(alphabet) {
  const decodeMap = /* @__PURE__ */ new Map();
  for (let i = 0; i < alphabet.length; i++) {
    decodeMap.set(alphabet[i], i);
  }
  return decodeMap;
}
function base32Encode(data, alphabet, padding) {
  let result = "";
  let buffer = 0;
  let shift = 0;
  for (const byte of data) {
    buffer = buffer << 8 | byte;
    shift += 8;
    while (shift >= 5) {
      shift -= 5;
      result += alphabet[buffer >> shift & 31];
    }
  }
  if (shift > 0) {
    result += alphabet[buffer << 5 - shift & 31];
  }
  if (padding) {
    const padCount = (8 - result.length % 8) % 8;
    result += "=".repeat(padCount);
  }
  return result;
}
function base32Decode(data, alphabet) {
  const decodeMap = createDecodeMap(alphabet);
  const result = [];
  let buffer = 0;
  let bitsCollected = 0;
  for (const char of data) {
    if (char === "=")
      break;
    const value = decodeMap.get(char);
    if (value === void 0) {
      throw new Error(`Invalid Base32 character: ${char}`);
    }
    buffer = buffer << 5 | value;
    bitsCollected += 5;
    while (bitsCollected >= 8) {
      bitsCollected -= 8;
      result.push(buffer >> bitsCollected & 255);
    }
  }
  return Uint8Array.from(result);
}
var base32 = {
  /**
   * Encodes data into a Base32 string.
   * @param data - The data to encode (ArrayBuffer, TypedArray, or string).
   * @param options - Encoding options.
   * @returns The Base32 encoded string.
   */
  encode(data, options = {}) {
    const alphabet = getAlphabet(false);
    const buffer = typeof data === "string" ? new TextEncoder().encode(data) : new Uint8Array(data);
    return base32Encode(buffer, alphabet, options.padding ?? true);
  },
  /**
   * Decodes a Base32 string into a Uint8Array.
   * @param data - The Base32 encoded string or ArrayBuffer/TypedArray.
   * @returns The decoded Uint8Array.
   */
  decode(data) {
    if (typeof data !== "string") {
      data = new TextDecoder().decode(data);
    }
    const alphabet = getAlphabet(false);
    return base32Decode(data, alphabet);
  }
};

// ../node_modules/.bun/@better-auth+utils@0.3.0/node_modules/@better-auth/utils/dist/otp.mjs
var defaultPeriod = 30;
var defaultDigits = 6;
async function generateHOTP(secret, {
  counter,
  digits,
  hash = "SHA-1"
}) {
  const _digits = digits ?? defaultDigits;
  if (_digits < 1 || _digits > 8) {
    throw new TypeError("Digits must be between 1 and 8");
  }
  const buffer = new ArrayBuffer(8);
  new DataView(buffer).setBigUint64(0, BigInt(counter), false);
  const bytes = new Uint8Array(buffer);
  const hmacResult = new Uint8Array(await createHMAC(hash).sign(secret, bytes));
  const offset = hmacResult[hmacResult.length - 1] & 15;
  const truncated = (hmacResult[offset] & 127) << 24 | (hmacResult[offset + 1] & 255) << 16 | (hmacResult[offset + 2] & 255) << 8 | hmacResult[offset + 3] & 255;
  const otp = truncated % 10 ** _digits;
  return otp.toString().padStart(_digits, "0");
}
async function generateTOTP(secret, options) {
  const digits = options?.digits ?? defaultDigits;
  const period = options?.period ?? defaultPeriod;
  const milliseconds = period * 1e3;
  const counter = Math.floor(Date.now() / milliseconds);
  return await generateHOTP(secret, { counter, digits, hash: options?.hash });
}
async function verifyTOTP(otp, {
  window = 1,
  digits = defaultDigits,
  secret,
  period = defaultPeriod
}) {
  const milliseconds = period * 1e3;
  const counter = Math.floor(Date.now() / milliseconds);
  for (let i = -window; i <= window; i++) {
    const generatedOTP = await generateHOTP(secret, {
      counter: counter + i,
      digits
    });
    if (otp === generatedOTP) {
      return true;
    }
  }
  return false;
}
function generateQRCode({
  issuer,
  account,
  secret,
  digits = defaultDigits,
  period = defaultPeriod
}) {
  const encodedIssuer = encodeURIComponent(issuer);
  const encodedAccountName = encodeURIComponent(account);
  const baseURI = `otpauth://totp/${encodedIssuer}:${encodedAccountName}`;
  const params = new URLSearchParams({
    secret: base32.encode(secret, {
      padding: false
    }),
    issuer
  });
  if (digits !== void 0) {
    params.set("digits", digits.toString());
  }
  if (period !== void 0) {
    params.set("period", period.toString());
  }
  return `${baseURI}?${params.toString()}`;
}
var createOTP = (secret, opts) => {
  const digits = opts?.digits ?? defaultDigits;
  const period = opts?.period ?? defaultPeriod;
  return {
    hotp: (counter) => generateHOTP(secret, { counter, digits }),
    totp: () => generateTOTP(secret, { digits, period }),
    verify: (otp, options) => verifyTOTP(otp, { secret, digits, period, ...options }),
    url: (issuer, account) => generateQRCode({ issuer, account, secret, digits, period })
  };
};

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/two-factor/totp/index.mjs
var generateTOTPBodySchema = object({ secret: string().meta({ description: "The secret to generate the TOTP code" }) });
var getTOTPURIBodySchema = object({ password: string().meta({ description: "User password" }) });
var verifyTOTPBodySchema = object({
  code: string().meta({ description: 'The otp code to verify. Eg: "012345"' }),
  trustDevice: boolean().meta({ description: "If true, the device will be trusted for 30 days. It'll be refreshed on every sign in request within this time. Eg: true" }).optional()
});
var totp2fa = (options) => {
  const opts = {
    ...options,
    digits: options?.digits || 6,
    period: options?.period || 30
  };
  const twoFactorTable = "twoFactor";
  return {
    id: "totp",
    endpoints: {
      generateTOTP: createAuthEndpoint({
        method: "POST",
        body: generateTOTPBodySchema,
        metadata: { openapi: {
          summary: "Generate TOTP code",
          description: "Use this endpoint to generate a TOTP code",
          responses: { 200: {
            description: "Successful response",
            content: { "application/json": { schema: {
              type: "object",
              properties: { code: { type: "string" } }
            } } }
          } }
        } }
      }, async (ctx) => {
        if (options?.disable) {
          ctx.context.logger.error("totp isn't configured. please pass totp option on two factor plugin to enable totp");
          throw new APIError("BAD_REQUEST", { message: "totp isn't configured" });
        }
        return { code: await createOTP(ctx.body.secret, {
          period: opts.period,
          digits: opts.digits
        }).totp() };
      }),
      getTOTPURI: createAuthEndpoint("/two-factor/get-totp-uri", {
        method: "POST",
        use: [sessionMiddleware],
        body: getTOTPURIBodySchema,
        metadata: { openapi: {
          summary: "Get TOTP URI",
          description: "Use this endpoint to get the TOTP URI",
          responses: { 200: {
            description: "Successful response",
            content: { "application/json": { schema: {
              type: "object",
              properties: { totpURI: { type: "string" } }
            } } }
          } }
        } }
      }, async (ctx) => {
        if (options?.disable) {
          ctx.context.logger.error("totp isn't configured. please pass totp option on two factor plugin to enable totp");
          throw new APIError("BAD_REQUEST", { message: "totp isn't configured" });
        }
        const user = ctx.context.session.user;
        const twoFactor2 = await ctx.context.adapter.findOne({
          model: twoFactorTable,
          where: [{
            field: "userId",
            value: user.id
          }]
        });
        if (!twoFactor2) throw new APIError("BAD_REQUEST", { message: TWO_FACTOR_ERROR_CODES.TOTP_NOT_ENABLED });
        const secret = await symmetricDecrypt({
          key: ctx.context.secret,
          data: twoFactor2.secret
        });
        await ctx.context.password.checkPassword(user.id, ctx);
        return { totpURI: createOTP(secret, {
          digits: opts.digits,
          period: opts.period
        }).url(options?.issuer || ctx.context.appName, user.email) };
      }),
      verifyTOTP: createAuthEndpoint("/two-factor/verify-totp", {
        method: "POST",
        body: verifyTOTPBodySchema,
        metadata: { openapi: {
          summary: "Verify two factor TOTP",
          description: "Verify two factor TOTP",
          responses: { 200: {
            description: "Successful response",
            content: { "application/json": { schema: {
              type: "object",
              properties: { status: { type: "boolean" } }
            } } }
          } }
        } }
      }, async (ctx) => {
        if (options?.disable) {
          ctx.context.logger.error("totp isn't configured. please pass totp option on two factor plugin to enable totp");
          throw new APIError("BAD_REQUEST", { message: "totp isn't configured" });
        }
        const { session, valid, invalid } = await verifyTwoFactor(ctx);
        const user = session.user;
        const twoFactor2 = await ctx.context.adapter.findOne({
          model: twoFactorTable,
          where: [{
            field: "userId",
            value: user.id
          }]
        });
        if (!twoFactor2) throw new APIError("BAD_REQUEST", { message: TWO_FACTOR_ERROR_CODES.TOTP_NOT_ENABLED });
        if (!await createOTP(await symmetricDecrypt({
          key: ctx.context.secret,
          data: twoFactor2.secret
        }), {
          period: opts.period,
          digits: opts.digits
        }).verify(ctx.body.code)) return invalid("INVALID_CODE");
        if (!user.twoFactorEnabled) {
          if (!session.session) throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.FAILED_TO_CREATE_SESSION });
          const updatedUser = await ctx.context.internalAdapter.updateUser(user.id, { twoFactorEnabled: true });
          const newSession = await ctx.context.internalAdapter.createSession(user.id, false, session.session).catch((e) => {
            throw e;
          });
          await ctx.context.internalAdapter.deleteSession(session.session.token);
          await setSessionCookie(ctx, {
            session: newSession,
            user: updatedUser
          });
        }
        return valid(ctx);
      })
    }
  };
};

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/two-factor/index.mjs
var enableTwoFactorBodySchema = object({
  password: string().meta({ description: "User password" }),
  issuer: string().meta({ description: "Custom issuer for the TOTP URI" }).optional()
});
var disableTwoFactorBodySchema = object({ password: string().meta({ description: "User password" }) });
var twoFactor = (options) => {
  const opts = { twoFactorTable: "twoFactor" };
  const backupCodeOptions = {
    storeBackupCodes: "encrypted",
    ...options?.backupCodeOptions
  };
  const totp = totp2fa(options?.totpOptions);
  const backupCode = backupCode2fa(backupCodeOptions);
  const otp = otp2fa(options?.otpOptions);
  return {
    id: "two-factor",
    endpoints: {
      ...totp.endpoints,
      ...otp.endpoints,
      ...backupCode.endpoints,
      enableTwoFactor: createAuthEndpoint("/two-factor/enable", {
        method: "POST",
        body: enableTwoFactorBodySchema,
        use: [sessionMiddleware],
        metadata: { openapi: {
          summary: "Enable two factor authentication",
          description: "Use this endpoint to enable two factor authentication. This will generate a TOTP URI and backup codes. Once the user verifies the TOTP URI, the two factor authentication will be enabled.",
          responses: { 200: {
            description: "Successful response",
            content: { "application/json": { schema: {
              type: "object",
              properties: {
                totpURI: {
                  type: "string",
                  description: "TOTP URI"
                },
                backupCodes: {
                  type: "array",
                  items: { type: "string" },
                  description: "Backup codes"
                }
              }
            } } }
          } }
        } }
      }, async (ctx) => {
        const user = ctx.context.session.user;
        const { password, issuer } = ctx.body;
        if (!await validatePassword(ctx, {
          password,
          userId: user.id
        })) throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.INVALID_PASSWORD });
        const secret = generateRandomString(32);
        const encryptedSecret = await symmetricEncrypt({
          key: ctx.context.secret,
          data: secret
        });
        const backupCodes = await generateBackupCodes(ctx.context.secret, backupCodeOptions);
        if (options?.skipVerificationOnEnable) {
          const updatedUser = await ctx.context.internalAdapter.updateUser(user.id, { twoFactorEnabled: true });
          await setSessionCookie(ctx, {
            session: await ctx.context.internalAdapter.createSession(updatedUser.id, false, ctx.context.session.session),
            user: updatedUser
          });
          await ctx.context.internalAdapter.deleteSession(ctx.context.session.session.token);
        }
        await ctx.context.adapter.deleteMany({
          model: opts.twoFactorTable,
          where: [{
            field: "userId",
            value: user.id
          }]
        });
        await ctx.context.adapter.create({
          model: opts.twoFactorTable,
          data: {
            secret: encryptedSecret,
            backupCodes: backupCodes.encryptedBackupCodes,
            userId: user.id
          }
        });
        const totpURI = createOTP(secret, {
          digits: options?.totpOptions?.digits || 6,
          period: options?.totpOptions?.period
        }).url(issuer || options?.issuer || ctx.context.appName, user.email);
        return ctx.json({
          totpURI,
          backupCodes: backupCodes.backupCodes
        });
      }),
      disableTwoFactor: createAuthEndpoint("/two-factor/disable", {
        method: "POST",
        body: disableTwoFactorBodySchema,
        use: [sessionMiddleware],
        metadata: { openapi: {
          summary: "Disable two factor authentication",
          description: "Use this endpoint to disable two factor authentication.",
          responses: { 200: {
            description: "Successful response",
            content: { "application/json": { schema: {
              type: "object",
              properties: { status: { type: "boolean" } }
            } } }
          } }
        } }
      }, async (ctx) => {
        const user = ctx.context.session.user;
        const { password } = ctx.body;
        if (!await validatePassword(ctx, {
          password,
          userId: user.id
        })) throw new APIError("BAD_REQUEST", { message: BASE_ERROR_CODES.INVALID_PASSWORD });
        const updatedUser = await ctx.context.internalAdapter.updateUser(user.id, { twoFactorEnabled: false });
        await ctx.context.adapter.delete({
          model: opts.twoFactorTable,
          where: [{
            field: "userId",
            value: updatedUser.id
          }]
        });
        await setSessionCookie(ctx, {
          session: await ctx.context.internalAdapter.createSession(updatedUser.id, false, ctx.context.session.session),
          user: updatedUser
        });
        await ctx.context.internalAdapter.deleteSession(ctx.context.session.session.token);
        return ctx.json({ status: true });
      })
    },
    options,
    hooks: { after: [{
      matcher(context) {
        return context.path === "/sign-in/email" || context.path === "/sign-in/username" || context.path === "/sign-in/phone-number";
      },
      handler: createAuthMiddleware(async (ctx) => {
        const data = ctx.context.newSession;
        if (!data) return;
        if (!data?.user.twoFactorEnabled) return;
        const trustDeviceCookieAttrs = ctx.context.createAuthCookie(TRUST_DEVICE_COOKIE_NAME, { maxAge: TRUST_DEVICE_COOKIE_MAX_AGE });
        const trustDeviceCookie = await ctx.getSignedCookie(trustDeviceCookieAttrs.name, ctx.context.secret);
        if (trustDeviceCookie) {
          const [token, sessionToken] = trustDeviceCookie.split("!");
          if (token === await createHMAC("SHA-256", "base64urlnopad").sign(ctx.context.secret, `${data.user.id}!${sessionToken}`)) {
            const newTrustDeviceCookie = ctx.context.createAuthCookie(TRUST_DEVICE_COOKIE_NAME, { maxAge: TRUST_DEVICE_COOKIE_MAX_AGE });
            const newToken = await createHMAC("SHA-256", "base64urlnopad").sign(ctx.context.secret, `${data.user.id}!${data.session.token}`);
            await ctx.setSignedCookie(newTrustDeviceCookie.name, `${newToken}!${data.session.token}`, ctx.context.secret, trustDeviceCookieAttrs.attributes);
            return;
          }
        }
        deleteSessionCookie(ctx, true);
        await ctx.context.internalAdapter.deleteSession(data.session.token);
        const maxAge = (options?.otpOptions?.period ?? 3) * 60;
        const twoFactorCookie = ctx.context.createAuthCookie(TWO_FACTOR_COOKIE_NAME, { maxAge });
        const identifier = `2fa-${generateRandomString(20)}`;
        await ctx.context.internalAdapter.createVerificationValue({
          value: data.user.id,
          identifier,
          expiresAt: new Date(Date.now() + maxAge * 1e3)
        });
        await ctx.setSignedCookie(twoFactorCookie.name, identifier, ctx.context.secret, twoFactorCookie.attributes);
        return ctx.json({ twoFactorRedirect: true });
      })
    }] },
    schema: mergeSchema(schema8, options?.schema),
    rateLimit: [{
      pathMatcher(path) {
        return path.startsWith("/two-factor/");
      },
      window: 10,
      max: 3
    }],
    $ERROR_CODES: TWO_FACTOR_ERROR_CODES
  };
};

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/username/error-codes.mjs
var USERNAME_ERROR_CODES = defineErrorCodes({
  INVALID_USERNAME_OR_PASSWORD: "Invalid username or password",
  EMAIL_NOT_VERIFIED: "Email not verified",
  UNEXPECTED_ERROR: "Unexpected error",
  USERNAME_IS_ALREADY_TAKEN: "Username is already taken. Please try another.",
  USERNAME_TOO_SHORT: "Username is too short",
  USERNAME_TOO_LONG: "Username is too long",
  INVALID_USERNAME: "Username is invalid",
  INVALID_DISPLAY_USERNAME: "Display username is invalid"
});

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/username/schema.mjs
var getSchema = (normalizer) => {
  return { user: { fields: {
    username: {
      type: "string",
      required: false,
      sortable: true,
      unique: true,
      returned: true,
      transform: { input(value) {
        return typeof value !== "string" ? value : normalizer.username(value);
      } }
    },
    displayUsername: {
      type: "string",
      required: false,
      transform: { input(value) {
        return typeof value !== "string" ? value : normalizer.displayUsername(value);
      } }
    }
  } } };
};

// ../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/dist/plugins/username/index.mjs
function defaultUsernameValidator(username$1) {
  return /^[a-zA-Z0-9_.]+$/.test(username$1);
}
var signInUsernameBodySchema = object({
  username: string().meta({ description: "The username of the user" }),
  password: string().meta({ description: "The password of the user" }),
  rememberMe: boolean().meta({ description: "Remember the user session" }).optional(),
  callbackURL: string().meta({ description: "The URL to redirect to after email verification" }).optional()
});
var isUsernameAvailableBodySchema = object({ username: string().meta({ description: "The username to check" }) });
var username = (options) => {
  const normalizer = (username$1) => {
    if (options?.usernameNormalization === false) return username$1;
    if (options?.usernameNormalization) return options.usernameNormalization(username$1);
    return username$1.toLowerCase();
  };
  const displayUsernameNormalizer = (displayUsername) => {
    return options?.displayUsernameNormalization ? options.displayUsernameNormalization(displayUsername) : displayUsername;
  };
  return {
    id: "username",
    init(ctx) {
      return { options: { databaseHooks: { user: {
        create: { async before(user, context) {
          const username$1 = "username" in user ? user.username : null;
          const displayUsername = "displayUsername" in user ? user.displayUsername : null;
          return { data: {
            ...user,
            ...username$1 ? { username: normalizer(username$1) } : {},
            ...displayUsername ? { displayUsername: displayUsernameNormalizer(displayUsername) } : {}
          } };
        } },
        update: { async before(user, context) {
          const username$1 = "username" in user ? user.username : null;
          const displayUsername = "displayUsername" in user ? user.displayUsername : null;
          return { data: {
            ...user,
            ...username$1 ? { username: normalizer(username$1) } : {},
            ...displayUsername ? { displayUsername: displayUsernameNormalizer(displayUsername) } : {}
          } };
        } }
      } } } };
    },
    endpoints: {
      signInUsername: createAuthEndpoint("/sign-in/username", {
        method: "POST",
        body: signInUsernameBodySchema,
        metadata: { openapi: {
          summary: "Sign in with username",
          description: "Sign in with username",
          responses: {
            200: {
              description: "Success",
              content: { "application/json": { schema: {
                type: "object",
                properties: {
                  token: {
                    type: "string",
                    description: "Session token for the authenticated session"
                  },
                  user: { $ref: "#/components/schemas/User" }
                },
                required: ["token", "user"]
              } } }
            },
            422: {
              description: "Unprocessable Entity. Validation error",
              content: { "application/json": { schema: {
                type: "object",
                properties: { message: { type: "string" } }
              } } }
            }
          }
        } }
      }, async (ctx) => {
        if (!ctx.body.username || !ctx.body.password) {
          ctx.context.logger.error("Username or password not found");
          throw new APIError("UNAUTHORIZED", { message: USERNAME_ERROR_CODES.INVALID_USERNAME_OR_PASSWORD });
        }
        const username$1 = options?.validationOrder?.username === "pre-normalization" ? normalizer(ctx.body.username) : ctx.body.username;
        const minUsernameLength = options?.minUsernameLength || 3;
        const maxUsernameLength = options?.maxUsernameLength || 30;
        if (username$1.length < minUsernameLength) {
          ctx.context.logger.error("Username too short", { username: username$1 });
          throw new APIError("UNPROCESSABLE_ENTITY", {
            code: "USERNAME_TOO_SHORT",
            message: USERNAME_ERROR_CODES.USERNAME_TOO_SHORT
          });
        }
        if (username$1.length > maxUsernameLength) {
          ctx.context.logger.error("Username too long", { username: username$1 });
          throw new APIError("UNPROCESSABLE_ENTITY", { message: USERNAME_ERROR_CODES.USERNAME_TOO_LONG });
        }
        if (!await (options?.usernameValidator || defaultUsernameValidator)(username$1)) throw new APIError("UNPROCESSABLE_ENTITY", { message: USERNAME_ERROR_CODES.INVALID_USERNAME });
        const user = await ctx.context.adapter.findOne({
          model: "user",
          where: [{
            field: "username",
            value: normalizer(username$1)
          }]
        });
        if (!user) {
          await ctx.context.password.hash(ctx.body.password);
          ctx.context.logger.error("User not found", { username: username$1 });
          throw new APIError("UNAUTHORIZED", { message: USERNAME_ERROR_CODES.INVALID_USERNAME_OR_PASSWORD });
        }
        const account = await ctx.context.adapter.findOne({
          model: "account",
          where: [{
            field: "userId",
            value: user.id
          }, {
            field: "providerId",
            value: "credential"
          }]
        });
        if (!account) throw new APIError("UNAUTHORIZED", { message: USERNAME_ERROR_CODES.INVALID_USERNAME_OR_PASSWORD });
        const currentPassword = account?.password;
        if (!currentPassword) {
          ctx.context.logger.error("Password not found", { username: username$1 });
          throw new APIError("UNAUTHORIZED", { message: USERNAME_ERROR_CODES.INVALID_USERNAME_OR_PASSWORD });
        }
        if (!await ctx.context.password.verify({
          hash: currentPassword,
          password: ctx.body.password
        })) {
          ctx.context.logger.error("Invalid password");
          throw new APIError("UNAUTHORIZED", { message: USERNAME_ERROR_CODES.INVALID_USERNAME_OR_PASSWORD });
        }
        if (ctx.context.options?.emailAndPassword?.requireEmailVerification && !user.emailVerified) {
          if (!ctx.context.options?.emailVerification?.sendVerificationEmail) throw new APIError("FORBIDDEN", { message: USERNAME_ERROR_CODES.EMAIL_NOT_VERIFIED });
          if (ctx.context.options?.emailVerification?.sendOnSignIn) {
            const token = await createEmailVerificationToken(ctx.context.secret, user.email, void 0, ctx.context.options.emailVerification?.expiresIn);
            const url = `${ctx.context.baseURL}/verify-email?token=${token}&callbackURL=${ctx.body.callbackURL || "/"}`;
            await ctx.context.runInBackgroundOrAwait(ctx.context.options.emailVerification.sendVerificationEmail({
              user,
              url,
              token
            }, ctx.request));
          }
          throw new APIError("FORBIDDEN", { message: USERNAME_ERROR_CODES.EMAIL_NOT_VERIFIED });
        }
        const session = await ctx.context.internalAdapter.createSession(user.id, ctx.body.rememberMe === false);
        if (!session) return ctx.json(null, {
          status: 500,
          body: { message: BASE_ERROR_CODES.FAILED_TO_CREATE_SESSION }
        });
        await setSessionCookie(ctx, {
          session,
          user
        }, ctx.body.rememberMe === false);
        return ctx.json({
          token: session.token,
          user: {
            id: user.id,
            email: user.email,
            emailVerified: user.emailVerified,
            username: user.username,
            displayUsername: user.displayUsername,
            name: user.name,
            image: user.image,
            createdAt: user.createdAt,
            updatedAt: user.updatedAt
          }
        });
      }),
      isUsernameAvailable: createAuthEndpoint("/is-username-available", {
        method: "POST",
        body: isUsernameAvailableBodySchema
      }, async (ctx) => {
        const username$1 = ctx.body.username;
        if (!username$1) throw new APIError("UNPROCESSABLE_ENTITY", { message: USERNAME_ERROR_CODES.INVALID_USERNAME });
        const minUsernameLength = options?.minUsernameLength || 3;
        const maxUsernameLength = options?.maxUsernameLength || 30;
        if (username$1.length < minUsernameLength) throw new APIError("UNPROCESSABLE_ENTITY", {
          code: "USERNAME_TOO_SHORT",
          message: USERNAME_ERROR_CODES.USERNAME_TOO_SHORT
        });
        if (username$1.length > maxUsernameLength) throw new APIError("UNPROCESSABLE_ENTITY", { message: USERNAME_ERROR_CODES.USERNAME_TOO_LONG });
        if (!await (options?.usernameValidator || defaultUsernameValidator)(username$1)) throw new APIError("UNPROCESSABLE_ENTITY", { message: USERNAME_ERROR_CODES.INVALID_USERNAME });
        if (await ctx.context.adapter.findOne({
          model: "user",
          where: [{
            field: "username",
            value: normalizer(username$1)
          }]
        })) return ctx.json({ available: false });
        return ctx.json({ available: true });
      })
    },
    schema: mergeSchema(getSchema({
      username: normalizer,
      displayUsername: displayUsernameNormalizer
    }), options?.schema),
    hooks: { before: [{
      matcher(context) {
        return context.path === "/sign-up/email" || context.path === "/update-user";
      },
      handler: createAuthMiddleware(async (ctx) => {
        const username$1 = typeof ctx.body.username === "string" && options?.validationOrder?.username === "post-normalization" ? normalizer(ctx.body.username) : ctx.body.username;
        if (username$1 !== void 0 && typeof username$1 === "string") {
          const minUsernameLength = options?.minUsernameLength || 3;
          const maxUsernameLength = options?.maxUsernameLength || 30;
          if (username$1.length < minUsernameLength) throw new APIError("BAD_REQUEST", {
            code: "USERNAME_TOO_SHORT",
            message: USERNAME_ERROR_CODES.USERNAME_TOO_SHORT
          });
          if (username$1.length > maxUsernameLength) throw new APIError("BAD_REQUEST", { message: USERNAME_ERROR_CODES.USERNAME_TOO_LONG });
          if (!await (options?.usernameValidator || defaultUsernameValidator)(username$1)) throw new APIError("BAD_REQUEST", { message: USERNAME_ERROR_CODES.INVALID_USERNAME });
          const user = await ctx.context.adapter.findOne({
            model: "user",
            where: [{
              field: "username",
              value: username$1
            }]
          });
          const blockChangeSignUp = ctx.path === "/sign-up/email" && user;
          const blockChangeUpdateUser = ctx.path === "/update-user" && user && ctx.context.session && user.id !== ctx.context.session.session.userId;
          if (blockChangeSignUp || blockChangeUpdateUser) throw new APIError("BAD_REQUEST", { message: USERNAME_ERROR_CODES.USERNAME_IS_ALREADY_TAKEN });
        }
        const displayUsername = typeof ctx.body.displayUsername === "string" && options?.validationOrder?.displayUsername === "post-normalization" ? displayUsernameNormalizer(ctx.body.displayUsername) : ctx.body.displayUsername;
        if (displayUsername !== void 0 && typeof displayUsername === "string") {
          if (options?.displayUsernameValidator) {
            if (!await options.displayUsernameValidator(displayUsername)) throw new APIError("BAD_REQUEST", { message: USERNAME_ERROR_CODES.INVALID_DISPLAY_USERNAME });
          }
        }
      })
    }, {
      matcher(context) {
        return context.path === "/sign-up/email" || context.path === "/update-user";
      },
      handler: createAuthMiddleware(async (ctx) => {
        if (ctx.body.username && !ctx.body.displayUsername) ctx.body.displayUsername = ctx.body.username;
        if (ctx.body.displayUsername && !ctx.body.username) ctx.body.username = ctx.body.displayUsername;
      })
    }] },
    options,
    $ERROR_CODES: USERNAME_ERROR_CODES
  };
};
export {
  API_KEY_TABLE_NAME,
  ERROR_CODES,
  HIDE_METADATA,
  TWO_FACTOR_ERROR_CODES,
  USERNAME_ERROR_CODES,
  admin,
  anonymous,
  apiKey,
  auth0,
  bearer,
  captcha,
  createAccessControl,
  createAuthEndpoint,
  createAuthMiddleware,
  createJwk,
  customSession,
  defaultKeyHasher,
  deviceAuthorization,
  deviceAuthorizationOptionsSchema,
  emailOTP,
  generateExportedKeyPair,
  genericOAuth,
  getClient,
  getJwtToken,
  getMCPProtectedResourceMetadata,
  getMCPProviderMetadata,
  getMetadata,
  getOrgAdapter,
  haveIBeenPwned,
  hubspot,
  jwt,
  keycloak,
  lastLoginMethod,
  line,
  magicLink,
  mcp,
  microsoftEntraId,
  multiSession,
  oAuthDiscoveryMetadata,
  oAuthProtectedResourceMetadata,
  oAuthProxy,
  oidcProvider,
  okta,
  oneTap,
  oneTimeToken,
  openAPI,
  optionsMiddleware,
  organization,
  parseRoles2 as parseRoles,
  patreon,
  phoneNumber,
  role,
  signJWT,
  siwe,
  slack,
  toExpJWT,
  twoFactor,
  twoFactorClient,
  username,
  verifyJWT,
  withMcpAuth
};
//# sourceMappingURL=better-auth_plugins.js.map
