{
  "version": 3,
  "sources": ["../../../../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/src/adapters/memory-adapter/memory-adapter.ts"],
  "sourcesContent": ["import type { BetterAuthOptions } from \"@better-auth/core\";\nimport type {\n\tCleanedWhere,\n\tDBAdapterDebugLogOption,\n\tJoinConfig,\n} from \"@better-auth/core/db/adapter\";\nimport { createAdapterFactory } from \"@better-auth/core/db/adapter\";\nimport { logger } from \"@better-auth/core/env\";\n\nexport interface MemoryDB {\n\t[key: string]: any[];\n}\n\nexport interface MemoryAdapterConfig {\n\tdebugLogs?: DBAdapterDebugLogOption | undefined;\n}\n\nexport const memoryAdapter = (\n\tdb: MemoryDB,\n\tconfig?: MemoryAdapterConfig | undefined,\n) => {\n\tlet lazyOptions: BetterAuthOptions | null = null;\n\tlet adapterCreator = createAdapterFactory({\n\t\tconfig: {\n\t\t\tadapterId: \"memory\",\n\t\t\tadapterName: \"Memory Adapter\",\n\t\t\tusePlural: false,\n\t\t\tdebugLogs: config?.debugLogs || false,\n\t\t\tsupportsArrays: true,\n\t\t\tcustomTransformInput(props) {\n\t\t\t\tconst useNumberId =\n\t\t\t\t\tprops.options.advanced?.database?.useNumberId ||\n\t\t\t\t\tprops.options.advanced?.database?.generateId === \"serial\";\n\t\t\t\tif (useNumberId && props.field === \"id\" && props.action === \"create\") {\n\t\t\t\t\treturn db[props.model]!.length + 1;\n\t\t\t\t}\n\t\t\t\treturn props.data;\n\t\t\t},\n\t\t\ttransaction: async (cb) => {\n\t\t\t\tlet clone = structuredClone(db);\n\t\t\t\ttry {\n\t\t\t\t\tconst r = await cb(adapterCreator(lazyOptions!));\n\t\t\t\t\treturn r;\n\t\t\t\t} catch (error) {\n\t\t\t\t\t// Rollback changes\n\t\t\t\t\tObject.keys(db).forEach((key) => {\n\t\t\t\t\t\tdb[key] = clone[key]!;\n\t\t\t\t\t});\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\t\t\t},\n\t\t},\n\t\tadapter: ({ getFieldName, options, getModelName }) => {\n\t\t\tconst applySortToRecords = (\n\t\t\t\trecords: any[],\n\t\t\t\tsortBy: { field: string; direction: \"asc\" | \"desc\" } | undefined,\n\t\t\t\tmodel: string,\n\t\t\t) => {\n\t\t\t\tif (!sortBy) return records;\n\t\t\t\treturn records.sort((a: any, b: any) => {\n\t\t\t\t\tconst field = getFieldName({ model, field: sortBy.field });\n\t\t\t\t\tconst aValue = a[field];\n\t\t\t\t\tconst bValue = b[field];\n\n\t\t\t\t\tlet comparison = 0;\n\n\t\t\t\t\t// Handle null/undefined values\n\t\t\t\t\tif (aValue == null && bValue == null) {\n\t\t\t\t\t\tcomparison = 0;\n\t\t\t\t\t} else if (aValue == null) {\n\t\t\t\t\t\tcomparison = -1;\n\t\t\t\t\t} else if (bValue == null) {\n\t\t\t\t\t\tcomparison = 1;\n\t\t\t\t\t}\n\t\t\t\t\t// Handle string comparison\n\t\t\t\t\telse if (typeof aValue === \"string\" && typeof bValue === \"string\") {\n\t\t\t\t\t\tcomparison = aValue.localeCompare(bValue);\n\t\t\t\t\t}\n\t\t\t\t\t// Handle date comparison\n\t\t\t\t\telse if (aValue instanceof Date && bValue instanceof Date) {\n\t\t\t\t\t\tcomparison = aValue.getTime() - bValue.getTime();\n\t\t\t\t\t}\n\t\t\t\t\t// Handle numeric comparison\n\t\t\t\t\telse if (typeof aValue === \"number\" && typeof bValue === \"number\") {\n\t\t\t\t\t\tcomparison = aValue - bValue;\n\t\t\t\t\t}\n\t\t\t\t\t// Handle boolean comparison\n\t\t\t\t\telse if (typeof aValue === \"boolean\" && typeof bValue === \"boolean\") {\n\t\t\t\t\t\tcomparison = aValue === bValue ? 0 : aValue ? 1 : -1;\n\t\t\t\t\t}\n\t\t\t\t\t// Fallback to string comparison\n\t\t\t\t\telse {\n\t\t\t\t\t\tcomparison = String(aValue).localeCompare(String(bValue));\n\t\t\t\t\t}\n\n\t\t\t\t\treturn sortBy.direction === \"asc\" ? comparison : -comparison;\n\t\t\t\t});\n\t\t\t};\n\n\t\t\tfunction convertWhereClause(\n\t\t\t\twhere: CleanedWhere[],\n\t\t\t\tmodel: string,\n\t\t\t\tjoin?: JoinConfig,\n\t\t\t): any[] {\n\t\t\t\tconst execute = (where: CleanedWhere[], model: string) => {\n\t\t\t\t\tconst table = db[model];\n\t\t\t\t\tif (!table) {\n\t\t\t\t\t\tlogger.error(\n\t\t\t\t\t\t\t`[MemoryAdapter] Model ${model} not found in the DB`,\n\t\t\t\t\t\t\tObject.keys(db),\n\t\t\t\t\t\t);\n\t\t\t\t\t\tthrow new Error(`Model ${model} not found`);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst evalClause = (record: any, clause: CleanedWhere): boolean => {\n\t\t\t\t\t\tconst { field, value, operator } = clause;\n\t\t\t\t\t\tswitch (operator) {\n\t\t\t\t\t\t\tcase \"in\":\n\t\t\t\t\t\t\t\tif (!Array.isArray(value)) {\n\t\t\t\t\t\t\t\t\tthrow new Error(\"Value must be an array\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\t\t\t\treturn value.includes(record[field]);\n\t\t\t\t\t\t\tcase \"not_in\":\n\t\t\t\t\t\t\t\tif (!Array.isArray(value)) {\n\t\t\t\t\t\t\t\t\tthrow new Error(\"Value must be an array\");\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\t\t\t\treturn !value.includes(record[field]);\n\t\t\t\t\t\t\tcase \"contains\":\n\t\t\t\t\t\t\t\treturn record[field].includes(value);\n\t\t\t\t\t\t\tcase \"starts_with\":\n\t\t\t\t\t\t\t\treturn record[field].startsWith(value);\n\t\t\t\t\t\t\tcase \"ends_with\":\n\t\t\t\t\t\t\t\treturn record[field].endsWith(value);\n\t\t\t\t\t\t\tcase \"ne\":\n\t\t\t\t\t\t\t\treturn record[field] !== value;\n\t\t\t\t\t\t\tcase \"gt\":\n\t\t\t\t\t\t\t\treturn value != null && Boolean(record[field] > value);\n\t\t\t\t\t\t\tcase \"gte\":\n\t\t\t\t\t\t\t\treturn value != null && Boolean(record[field] >= value);\n\t\t\t\t\t\t\tcase \"lt\":\n\t\t\t\t\t\t\t\treturn value != null && Boolean(record[field] < value);\n\t\t\t\t\t\t\tcase \"lte\":\n\t\t\t\t\t\t\t\treturn value != null && Boolean(record[field] <= value);\n\t\t\t\t\t\t\tdefault:\n\t\t\t\t\t\t\t\treturn record[field] === value;\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\treturn table.filter((record: any) => {\n\t\t\t\t\t\tif (!where.length || where.length === 0) {\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlet result = evalClause(record, where[0]!);\n\t\t\t\t\t\tfor (const clause of where) {\n\t\t\t\t\t\t\tconst clauseResult = evalClause(record, clause);\n\n\t\t\t\t\t\t\tif (clause.connector === \"OR\") {\n\t\t\t\t\t\t\t\tresult = result || clauseResult;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tresult = result && clauseResult;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn result;\n\t\t\t\t\t});\n\t\t\t\t};\n\n\t\t\t\tif (!join) return execute(where, model);\n\n\t\t\t\tconst baseRecords = execute(where, model);\n\n\t\t\t\t// Group results by base model and nest joined data as arrays\n\t\t\t\tconst grouped = new Map<string, any>();\n\t\t\t\t// Track seen IDs per joined model for O(1) deduplication\n\t\t\t\tconst seenIds = new Map<string, Set<string>>();\n\n\t\t\t\tfor (const baseRecord of baseRecords) {\n\t\t\t\t\tconst baseId = String(baseRecord.id);\n\n\t\t\t\t\tif (!grouped.has(baseId)) {\n\t\t\t\t\t\tconst nested: Record<string, any> = { ...baseRecord };\n\n\t\t\t\t\t\t// Initialize joined data structures based on isUnique\n\t\t\t\t\t\tfor (const [joinModel, joinAttr] of Object.entries(join)) {\n\t\t\t\t\t\t\tconst joinModelName = getModelName(joinModel);\n\t\t\t\t\t\t\tif (joinAttr.relation === \"one-to-one\") {\n\t\t\t\t\t\t\t\tnested[joinModelName] = null;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tnested[joinModelName] = [];\n\t\t\t\t\t\t\t\tseenIds.set(`${baseId}-${joinModel}`, new Set());\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgrouped.set(baseId, nested);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst nestedEntry = grouped.get(baseId)!;\n\n\t\t\t\t\t// Add joined data\n\t\t\t\t\tfor (const [joinModel, joinAttr] of Object.entries(join)) {\n\t\t\t\t\t\tconst joinModelName = getModelName(joinModel);\n\t\t\t\t\t\tconst joinTable = db[joinModelName];\n\t\t\t\t\t\tif (!joinTable) {\n\t\t\t\t\t\t\tlogger.error(\n\t\t\t\t\t\t\t\t`[MemoryAdapter] JoinOption model ${joinModelName} not found in the DB`,\n\t\t\t\t\t\t\t\tObject.keys(db),\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tthrow new Error(`JoinOption model ${joinModelName} not found`);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst matchingRecords = joinTable.filter(\n\t\t\t\t\t\t\t(joinRecord: any) =>\n\t\t\t\t\t\t\t\tjoinRecord[joinAttr.on.to] === baseRecord[joinAttr.on.from],\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\tif (joinAttr.relation === \"one-to-one\") {\n\t\t\t\t\t\t\t// For unique relationships, store a single object (or null)\n\t\t\t\t\t\t\tnestedEntry[joinModelName] = matchingRecords[0] || null;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// For non-unique relationships, store array with limit\n\t\t\t\t\t\t\tconst seenSet = seenIds.get(`${baseId}-${joinModel}`)!;\n\t\t\t\t\t\t\tconst limit = joinAttr.limit ?? 100;\n\t\t\t\t\t\t\tlet count = 0;\n\n\t\t\t\t\t\t\tfor (const matchingRecord of matchingRecords) {\n\t\t\t\t\t\t\t\tif (count >= limit) break;\n\t\t\t\t\t\t\t\tif (!seenSet.has(matchingRecord.id)) {\n\t\t\t\t\t\t\t\t\tnestedEntry[joinModelName].push(matchingRecord);\n\t\t\t\t\t\t\t\t\tseenSet.add(matchingRecord.id);\n\t\t\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn Array.from(grouped.values());\n\t\t\t}\n\t\t\treturn {\n\t\t\t\tcreate: async ({ model, data }) => {\n\t\t\t\t\tconst useNumberId =\n\t\t\t\t\t\toptions.advanced?.database?.useNumberId ||\n\t\t\t\t\t\toptions.advanced?.database?.generateId === \"serial\";\n\t\t\t\t\tif (useNumberId) {\n\t\t\t\t\t\t// @ts-expect-error\n\t\t\t\t\t\tdata.id = db[getModelName(model)]!.length + 1;\n\t\t\t\t\t}\n\t\t\t\t\tif (!db[model]) {\n\t\t\t\t\t\tdb[model] = [];\n\t\t\t\t\t}\n\t\t\t\t\tdb[model]!.push(data);\n\t\t\t\t\treturn data;\n\t\t\t\t},\n\t\t\t\tfindOne: async ({ model, where, join }) => {\n\t\t\t\t\tconst res = convertWhereClause(where, model, join);\n\t\t\t\t\tif (join) {\n\t\t\t\t\t\t// When join is present, res is an array of nested objects\n\t\t\t\t\t\tconst resArray = res as any[];\n\t\t\t\t\t\tif (!resArray.length) {\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// Return the first nested object\n\t\t\t\t\t\treturn resArray[0];\n\t\t\t\t\t}\n\t\t\t\t\t// Without join, res is an array\n\t\t\t\t\tconst resArray = res as any[];\n\t\t\t\t\tconst record = resArray[0] || null;\n\t\t\t\t\treturn record;\n\t\t\t\t},\n\t\t\t\tfindMany: async ({ model, where, sortBy, limit, offset, join }) => {\n\t\t\t\t\tlet res = convertWhereClause(where || [], model, join);\n\n\t\t\t\t\tif (join) {\n\t\t\t\t\t\t// When join is present, res is an array of nested objects\n\t\t\t\t\t\tconst resArray = res as any[];\n\t\t\t\t\t\tif (!resArray.length) {\n\t\t\t\t\t\t\treturn [];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Apply sorting to nested objects\n\t\t\t\t\t\tapplySortToRecords(resArray, sortBy, model);\n\n\t\t\t\t\t\t// Apply offset and limit\n\t\t\t\t\t\tlet paginatedRecords = resArray;\n\t\t\t\t\t\tif (offset !== undefined) {\n\t\t\t\t\t\t\tpaginatedRecords = paginatedRecords.slice(offset);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (limit !== undefined) {\n\t\t\t\t\t\t\tpaginatedRecords = paginatedRecords.slice(0, limit);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn paginatedRecords;\n\t\t\t\t\t}\n\n\t\t\t\t\t// Without join - original logic\n\t\t\t\t\tconst resArray = res as any[];\n\t\t\t\t\tlet table = applySortToRecords(resArray, sortBy, model);\n\t\t\t\t\tif (offset !== undefined) {\n\t\t\t\t\t\ttable = table!.slice(offset);\n\t\t\t\t\t}\n\t\t\t\t\tif (limit !== undefined) {\n\t\t\t\t\t\ttable = table!.slice(0, limit);\n\t\t\t\t\t}\n\t\t\t\t\treturn table || [];\n\t\t\t\t},\n\t\t\t\tcount: async ({ model, where }) => {\n\t\t\t\t\tif (where) {\n\t\t\t\t\t\tconst filteredRecords = convertWhereClause(where, model);\n\t\t\t\t\t\treturn filteredRecords.length;\n\t\t\t\t\t}\n\t\t\t\t\treturn db[model]!.length;\n\t\t\t\t},\n\t\t\t\tupdate: async ({ model, where, update }) => {\n\t\t\t\t\tconst res = convertWhereClause(where, model);\n\t\t\t\t\tres.forEach((record) => {\n\t\t\t\t\t\tObject.assign(record, update);\n\t\t\t\t\t});\n\t\t\t\t\treturn res[0] || null;\n\t\t\t\t},\n\t\t\t\tdelete: async ({ model, where }) => {\n\t\t\t\t\tconst table = db[model]!;\n\t\t\t\t\tconst res = convertWhereClause(where, model);\n\t\t\t\t\tdb[model] = table.filter((record) => !res.includes(record));\n\t\t\t\t},\n\t\t\t\tdeleteMany: async ({ model, where }) => {\n\t\t\t\t\tconst table = db[model]!;\n\t\t\t\t\tconst res = convertWhereClause(where, model);\n\t\t\t\t\tlet count = 0;\n\t\t\t\t\tdb[model] = table.filter((record) => {\n\t\t\t\t\t\tif (res.includes(record)) {\n\t\t\t\t\t\t\tcount++;\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn !res.includes(record);\n\t\t\t\t\t});\n\t\t\t\t\treturn count;\n\t\t\t\t},\n\t\t\t\tupdateMany({ model, where, update }) {\n\t\t\t\t\tconst res = convertWhereClause(where, model);\n\t\t\t\t\tres.forEach((record) => {\n\t\t\t\t\t\tObject.assign(record, update);\n\t\t\t\t\t});\n\t\t\t\t\treturn res[0] || null;\n\t\t\t\t},\n\t\t\t};\n\t\t},\n\t});\n\treturn (options: BetterAuthOptions) => {\n\t\tlazyOptions = options;\n\t\treturn adapterCreator(options);\n\t};\n};\n"],
  "mappings": "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",
  "names": ["lazyOptions: BetterAuthOptions | null", "model", "where", "nested: Record<string, any>"]
}
