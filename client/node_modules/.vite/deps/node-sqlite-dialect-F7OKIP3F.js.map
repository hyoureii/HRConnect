{
  "version": 3,
  "sources": ["../../../../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/src/adapters/kysely-adapter/node-sqlite-dialect.ts"],
  "sourcesContent": ["/**\n * @see {@link https://nodejs.org/api/sqlite.html} - Node.js SQLite API documentation\n */\n\nimport type { DatabaseSync } from \"node:sqlite\";\nimport type {\n\tDatabaseConnection,\n\tDatabaseIntrospector,\n\tDatabaseMetadata,\n\tDatabaseMetadataOptions,\n\tDialect,\n\tDialectAdapter,\n\tDialectAdapterBase,\n\tDriver,\n\tKysely,\n\tQueryCompiler,\n\tQueryResult,\n\tSchemaMetadata,\n\tTableMetadata,\n} from \"kysely\";\nimport {\n\tCompiledQuery,\n\tDEFAULT_MIGRATION_LOCK_TABLE,\n\tDEFAULT_MIGRATION_TABLE,\n\tDefaultQueryCompiler,\n\tsql,\n} from \"kysely\";\n\nclass NodeSqliteAdapter implements DialectAdapterBase {\n\tget supportsCreateIfNotExists(): boolean {\n\t\treturn true;\n\t}\n\n\tget supportsTransactionalDdl(): boolean {\n\t\treturn false;\n\t}\n\n\tget supportsReturning(): boolean {\n\t\treturn true;\n\t}\n\n\tasync acquireMigrationLock(): Promise<void> {\n\t\t// SQLite only has one connection that's reserved by the migration system\n\t\t// for the whole time between acquireMigrationLock and releaseMigrationLock.\n\t\t// We don't need to do anything here.\n\t}\n\n\tasync releaseMigrationLock(): Promise<void> {\n\t\t// SQLite only has one connection that's reserved by the migration system\n\t\t// for the whole time between acquireMigrationLock and releaseMigrationLock.\n\t\t// We don't need to do anything here.\n\t}\n\tget supportsOutput(): boolean {\n\t\treturn true;\n\t}\n}\n\n/**\n * Config for the SQLite dialect.\n */\nexport interface NodeSqliteDialectConfig {\n\t/**\n\t * A sqlite DatabaseSync instance or a function that returns one.\n\t */\n\tdatabase: DatabaseSync;\n\n\t/**\n\t * Called once when the first query is executed.\n\t */\n\tonCreateConnection?:\n\t\t| ((connection: DatabaseConnection) => Promise<void>)\n\t\t| undefined;\n}\n\nclass NodeSqliteDriver implements Driver {\n\treadonly #config: NodeSqliteDialectConfig;\n\treadonly #connectionMutex = new ConnectionMutex();\n\n\t#db?: DatabaseSync;\n\t#connection?: DatabaseConnection;\n\n\tconstructor(config: NodeSqliteDialectConfig) {\n\t\tthis.#config = { ...config };\n\t}\n\n\tasync init(): Promise<void> {\n\t\tthis.#db = this.#config.database;\n\n\t\tthis.#connection = new NodeSqliteConnection(this.#db);\n\n\t\tif (this.#config.onCreateConnection) {\n\t\t\tawait this.#config.onCreateConnection(this.#connection);\n\t\t}\n\t}\n\n\tasync acquireConnection(): Promise<DatabaseConnection> {\n\t\t// SQLite only has one single connection. We use a mutex here to wait\n\t\t// until the single connection has been released.\n\t\tawait this.#connectionMutex.lock();\n\t\treturn this.#connection!;\n\t}\n\n\tasync beginTransaction(connection: DatabaseConnection): Promise<void> {\n\t\tawait connection.executeQuery(CompiledQuery.raw(\"begin\"));\n\t}\n\n\tasync commitTransaction(connection: DatabaseConnection): Promise<void> {\n\t\tawait connection.executeQuery(CompiledQuery.raw(\"commit\"));\n\t}\n\n\tasync rollbackTransaction(connection: DatabaseConnection): Promise<void> {\n\t\tawait connection.executeQuery(CompiledQuery.raw(\"rollback\"));\n\t}\n\n\tasync releaseConnection(): Promise<void> {\n\t\tthis.#connectionMutex.unlock();\n\t}\n\n\tasync destroy(): Promise<void> {\n\t\tthis.#db?.close();\n\t}\n}\n\nclass NodeSqliteConnection implements DatabaseConnection {\n\treadonly #db: DatabaseSync;\n\n\tconstructor(db: DatabaseSync) {\n\t\tthis.#db = db;\n\t}\n\n\texecuteQuery<O>(compiledQuery: CompiledQuery): Promise<QueryResult<O>> {\n\t\tconst { sql, parameters } = compiledQuery;\n\t\tconst stmt = this.#db.prepare(sql);\n\n\t\tconst rows = stmt.all(...(parameters as any[])) as O[];\n\n\t\treturn Promise.resolve({\n\t\t\trows,\n\t\t});\n\t}\n\n\tasync *streamQuery() {\n\t\tthrow new Error(\"Streaming query is not supported by SQLite driver.\");\n\t}\n}\n\nclass ConnectionMutex {\n\t#promise?: Promise<void>;\n\t#resolve?: () => void;\n\n\tasync lock(): Promise<void> {\n\t\twhile (this.#promise) {\n\t\t\tawait this.#promise;\n\t\t}\n\n\t\tthis.#promise = new Promise((resolve) => {\n\t\t\tthis.#resolve = resolve;\n\t\t});\n\t}\n\n\tunlock(): void {\n\t\tconst resolve = this.#resolve;\n\n\t\tthis.#promise = undefined;\n\t\tthis.#resolve = undefined;\n\n\t\tresolve?.();\n\t}\n}\n\nclass NodeSqliteIntrospector implements DatabaseIntrospector {\n\treadonly #db: Kysely<unknown>;\n\n\tconstructor(db: Kysely<unknown>) {\n\t\tthis.#db = db;\n\t}\n\n\tasync getSchemas(): Promise<SchemaMetadata[]> {\n\t\t// Sqlite doesn't support schemas.\n\t\treturn [];\n\t}\n\n\tasync getTables(\n\t\toptions: DatabaseMetadataOptions = { withInternalKyselyTables: false },\n\t): Promise<TableMetadata[]> {\n\t\tlet query = this.#db\n\t\t\t// @ts-expect-error\n\t\t\t.selectFrom(\"sqlite_schema\")\n\t\t\t// @ts-expect-error\n\t\t\t.where(\"type\", \"=\", \"table\")\n\t\t\t// @ts-expect-error\n\t\t\t.where(\"name\", \"not like\", \"sqlite_%\")\n\t\t\t.select(\"name\")\n\t\t\t.$castTo<{ name: string }>();\n\n\t\tif (!options.withInternalKyselyTables) {\n\t\t\tquery = query\n\t\t\t\t// @ts-expect-error\n\t\t\t\t.where(\"name\", \"!=\", DEFAULT_MIGRATION_TABLE)\n\t\t\t\t// @ts-expect-error\n\t\t\t\t.where(\"name\", \"!=\", DEFAULT_MIGRATION_LOCK_TABLE);\n\t\t}\n\n\t\tconst tables = await query.execute();\n\t\treturn Promise.all(tables.map(({ name }) => this.#getTableMetadata(name)));\n\t}\n\n\tasync getMetadata(\n\t\toptions?: DatabaseMetadataOptions | undefined,\n\t): Promise<DatabaseMetadata> {\n\t\treturn {\n\t\t\ttables: await this.getTables(options),\n\t\t};\n\t}\n\n\tasync #getTableMetadata(table: string): Promise<TableMetadata> {\n\t\tconst db = this.#db;\n\n\t\t// Get the SQL that was used to create the table.\n\t\tconst createSql = await db\n\t\t\t// @ts-expect-error\n\t\t\t.selectFrom(\"sqlite_master\")\n\t\t\t// @ts-expect-error\n\t\t\t.where(\"name\", \"=\", table)\n\t\t\t.select(\"sql\")\n\t\t\t.$castTo<{ sql: string | undefined }>()\n\t\t\t.execute();\n\n\t\t// Try to find the name of the column that has `autoincrement` >&\n\t\tconst autoIncrementCol = createSql[0]?.sql\n\t\t\t?.split(/[\\(\\),]/)\n\t\t\t?.find((it) => it.toLowerCase().includes(\"autoincrement\"))\n\t\t\t?.split(/\\s+/)?.[0]\n\t\t\t?.replace(/[\"`]/g, \"\");\n\n\t\tconst columns = await db\n\t\t\t.selectFrom(\n\t\t\t\tsql<{\n\t\t\t\t\tname: string;\n\t\t\t\t\ttype: string;\n\t\t\t\t\tnotnull: 0 | 1;\n\t\t\t\t\tdflt_value: any;\n\t\t\t\t}>`pragma_table_info(${table})`.as(\"table_info\"),\n\t\t\t)\n\t\t\t.select([\"name\", \"type\", \"notnull\", \"dflt_value\"])\n\t\t\t.execute();\n\n\t\treturn {\n\t\t\tname: table,\n\t\t\tcolumns: columns.map((col) => ({\n\t\t\t\tname: col.name,\n\t\t\t\tdataType: col.type,\n\t\t\t\tisNullable: !col.notnull,\n\t\t\t\tisAutoIncrementing: col.name === autoIncrementCol,\n\t\t\t\thasDefaultValue: col.dflt_value != null,\n\t\t\t})),\n\t\t\tisView: true,\n\t\t};\n\t}\n}\n\nclass NodeSqliteQueryCompiler extends DefaultQueryCompiler {\n\tprotected override getCurrentParameterPlaceholder() {\n\t\treturn \"?\";\n\t}\n\n\tprotected override getLeftIdentifierWrapper(): string {\n\t\treturn '\"';\n\t}\n\n\tprotected override getRightIdentifierWrapper(): string {\n\t\treturn '\"';\n\t}\n\n\tprotected override getAutoIncrement() {\n\t\treturn \"autoincrement\";\n\t}\n}\n\nexport class NodeSqliteDialect implements Dialect {\n\treadonly #config: NodeSqliteDialectConfig;\n\n\tconstructor(config: NodeSqliteDialectConfig) {\n\t\tthis.#config = { ...config };\n\t}\n\n\tcreateDriver(): Driver {\n\t\treturn new NodeSqliteDriver(this.#config);\n\t}\n\n\tcreateQueryCompiler(): QueryCompiler {\n\t\treturn new NodeSqliteQueryCompiler();\n\t}\n\n\tcreateAdapter(): DialectAdapter {\n\t\treturn new NodeSqliteAdapter();\n\t}\n\n\tcreateIntrospector(db: Kysely<any>): DatabaseIntrospector {\n\t\treturn new NodeSqliteIntrospector(db);\n\t}\n}\n"],
  "mappings": "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",
  "names": ["#db", "#connection", "sql", "#config"]
}
