{
  "version": 3,
  "sources": ["../../../../node_modules/.bun/better-auth@1.4.10+2d8ddc2d470fbe56/node_modules/better-auth/src/adapters/kysely-adapter/kysely-adapter.ts"],
  "sourcesContent": ["import type { BetterAuthOptions } from \"@better-auth/core\";\nimport type {\n\tAdapterFactoryCustomizeAdapterCreator,\n\tAdapterFactoryOptions,\n\tDBAdapter,\n\tDBAdapterDebugLogOption,\n\tJoinConfig,\n\tWhere,\n} from \"@better-auth/core/db/adapter\";\nimport { createAdapterFactory } from \"@better-auth/core/db/adapter\";\nimport type {\n\tInsertQueryBuilder,\n\tKysely,\n\tRawBuilder,\n\tUpdateQueryBuilder,\n} from \"kysely\";\nimport { sql } from \"kysely\";\nimport type { KyselyDatabaseType } from \"./types\";\n\ninterface KyselyAdapterConfig {\n\t/**\n\t * Database type.\n\t */\n\ttype?: KyselyDatabaseType | undefined;\n\t/**\n\t * Enable debug logs for the adapter\n\t *\n\t * @default false\n\t */\n\tdebugLogs?: DBAdapterDebugLogOption | undefined;\n\t/**\n\t * Use plural for table names.\n\t *\n\t * @default false\n\t */\n\tusePlural?: boolean | undefined;\n\t/**\n\t * Whether to execute multiple operations in a transaction.\n\t *\n\t * If the database doesn't support transactions,\n\t * set this to `false` and operations will be executed sequentially.\n\t * @default false\n\t */\n\ttransaction?: boolean | undefined;\n}\n\nexport const kyselyAdapter = (\n\tdb: Kysely<any>,\n\tconfig?: KyselyAdapterConfig | undefined,\n) => {\n\tlet lazyOptions: BetterAuthOptions | null = null;\n\tconst createCustomAdapter = (\n\t\tdb: Kysely<any>,\n\t): AdapterFactoryCustomizeAdapterCreator => {\n\t\treturn ({\n\t\t\tgetFieldName,\n\t\t\tschema,\n\t\t\tgetDefaultFieldName,\n\t\t\tgetDefaultModelName,\n\t\t\tgetFieldAttributes,\n\t\t\tgetModelName,\n\t\t}) => {\n\t\t\tconst selectAllJoins = (join: JoinConfig | undefined) => {\n\t\t\t\t// Use selectAll which will handle column naming appropriately\n\t\t\t\tconst allSelects: RawBuilder<unknown>[] = [];\n\t\t\t\tconst allSelectsStr: {\n\t\t\t\t\tjoinModel: string;\n\t\t\t\t\tjoinModelRef: string;\n\t\t\t\t\tfieldName: string;\n\t\t\t\t}[] = [];\n\t\t\t\tif (join) {\n\t\t\t\t\tfor (const [joinModel, _] of Object.entries(join)) {\n\t\t\t\t\t\tconst fields = schema[getDefaultModelName(joinModel)]?.fields;\n\t\t\t\t\t\tconst [_joinModelSchema, joinModelName] = joinModel.includes(\".\")\n\t\t\t\t\t\t\t? joinModel.split(\".\")\n\t\t\t\t\t\t\t: [undefined, joinModel];\n\n\t\t\t\t\t\tif (!fields) continue;\n\t\t\t\t\t\tfields.id = { type: \"string\" }; // make sure there is at least an id field\n\t\t\t\t\t\tfor (const [field, fieldAttr] of Object.entries(fields)) {\n\t\t\t\t\t\t\tallSelects.push(\n\t\t\t\t\t\t\t\tsql`${sql.ref(`join_${joinModelName}`)}.${sql.ref(fieldAttr.fieldName || field)} as ${sql.ref(`_joined_${joinModelName}_${fieldAttr.fieldName || field}`)}`,\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\tallSelectsStr.push({\n\t\t\t\t\t\t\t\tjoinModel: joinModel,\n\t\t\t\t\t\t\t\tjoinModelRef: joinModelName,\n\t\t\t\t\t\t\t\tfieldName: fieldAttr.fieldName || field,\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn { allSelectsStr, allSelects };\n\t\t\t};\n\n\t\t\tconst withReturning = async (\n\t\t\t\tvalues: Record<string, any>,\n\t\t\t\tbuilder:\n\t\t\t\t\t| InsertQueryBuilder<any, any, any>\n\t\t\t\t\t| UpdateQueryBuilder<any, string, string, any>,\n\t\t\t\tmodel: string,\n\t\t\t\twhere: Where[],\n\t\t\t) => {\n\t\t\t\tlet res: any;\n\t\t\t\tif (config?.type === \"mysql\") {\n\t\t\t\t\t// This isn't good, but kysely doesn't support returning in mysql and it doesn't return the inserted id.\n\t\t\t\t\t// Change this if there is a better way.\n\t\t\t\t\tawait builder.execute();\n\t\t\t\t\tconst field = values.id\n\t\t\t\t\t\t? \"id\"\n\t\t\t\t\t\t: where.length > 0 && where[0]?.field\n\t\t\t\t\t\t\t? where[0].field\n\t\t\t\t\t\t\t: \"id\";\n\n\t\t\t\t\tif (!values.id && where.length === 0) {\n\t\t\t\t\t\tres = await db\n\t\t\t\t\t\t\t.selectFrom(model)\n\t\t\t\t\t\t\t.selectAll()\n\t\t\t\t\t\t\t.orderBy(getFieldName({ model, field }), \"desc\")\n\t\t\t\t\t\t\t.limit(1)\n\t\t\t\t\t\t\t.executeTakeFirst();\n\t\t\t\t\t\treturn res;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst value = values[field] || where[0]?.value;\n\t\t\t\t\tres = await db\n\t\t\t\t\t\t.selectFrom(model)\n\t\t\t\t\t\t.selectAll()\n\t\t\t\t\t\t.orderBy(getFieldName({ model, field }), \"desc\")\n\t\t\t\t\t\t.where(getFieldName({ model, field }), \"=\", value)\n\t\t\t\t\t\t.limit(1)\n\t\t\t\t\t\t.executeTakeFirst();\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\tif (config?.type === \"mssql\") {\n\t\t\t\t\tres = await builder.outputAll(\"inserted\").executeTakeFirst();\n\t\t\t\t\treturn res;\n\t\t\t\t}\n\t\t\t\tres = await builder.returningAll().executeTakeFirst();\n\t\t\t\treturn res;\n\t\t\t};\n\t\t\tfunction convertWhereClause(model: string, w?: Where[] | undefined) {\n\t\t\t\tif (!w)\n\t\t\t\t\treturn {\n\t\t\t\t\t\tand: null,\n\t\t\t\t\t\tor: null,\n\t\t\t\t\t};\n\n\t\t\t\tconst conditions = {\n\t\t\t\t\tand: [] as any[],\n\t\t\t\t\tor: [] as any[],\n\t\t\t\t};\n\n\t\t\t\tw.forEach((condition) => {\n\t\t\t\t\tlet {\n\t\t\t\t\t\tfield: _field,\n\t\t\t\t\t\tvalue: _value,\n\t\t\t\t\t\toperator = \"=\",\n\t\t\t\t\t\tconnector = \"AND\",\n\t\t\t\t\t} = condition;\n\t\t\t\t\tlet value: any = _value;\n\t\t\t\t\tlet field: string | any = getFieldName({\n\t\t\t\t\t\tmodel,\n\t\t\t\t\t\tfield: _field,\n\t\t\t\t\t});\n\n\t\t\t\t\tconst expr = (eb: any) => {\n\t\t\t\t\t\tconst f = `${model}.${field}`;\n\t\t\t\t\t\tif (operator.toLowerCase() === \"in\") {\n\t\t\t\t\t\t\treturn eb(f, \"in\", Array.isArray(value) ? value : [value]);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (operator.toLowerCase() === \"not_in\") {\n\t\t\t\t\t\t\treturn eb(f, \"not in\", Array.isArray(value) ? value : [value]);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (operator === \"contains\") {\n\t\t\t\t\t\t\treturn eb(f, \"like\", `%${value}%`);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (operator === \"starts_with\") {\n\t\t\t\t\t\t\treturn eb(f, \"like\", `${value}%`);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (operator === \"ends_with\") {\n\t\t\t\t\t\t\treturn eb(f, \"like\", `%${value}`);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (operator === \"eq\") {\n\t\t\t\t\t\t\treturn eb(f, \"=\", value);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (operator === \"ne\") {\n\t\t\t\t\t\t\treturn eb(f, \"<>\", value);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (operator === \"gt\") {\n\t\t\t\t\t\t\treturn eb(f, \">\", value);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (operator === \"gte\") {\n\t\t\t\t\t\t\treturn eb(f, \">=\", value);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (operator === \"lt\") {\n\t\t\t\t\t\t\treturn eb(f, \"<\", value);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (operator === \"lte\") {\n\t\t\t\t\t\t\treturn eb(f, \"<=\", value);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn eb(f, operator, value);\n\t\t\t\t\t};\n\n\t\t\t\t\tif (connector === \"OR\") {\n\t\t\t\t\t\tconditions.or.push(expr);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tconditions.and.push(expr);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\treturn {\n\t\t\t\t\tand: conditions.and.length ? conditions.and : null,\n\t\t\t\t\tor: conditions.or.length ? conditions.or : null,\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tfunction processJoinedResults(\n\t\t\t\trows: any[],\n\t\t\t\tjoinConfig: JoinConfig | undefined,\n\t\t\t\tallSelectsStr: {\n\t\t\t\t\tjoinModel: string;\n\t\t\t\t\tjoinModelRef: string;\n\t\t\t\t\tfieldName: string;\n\t\t\t\t}[],\n\t\t\t) {\n\t\t\t\tif (!joinConfig || !rows.length) {\n\t\t\t\t\treturn rows;\n\t\t\t\t}\n\n\t\t\t\t// Group rows by main model ID\n\t\t\t\tconst groupedByMainId = new Map<string, any>();\n\n\t\t\t\tfor (const currentRow of rows) {\n\t\t\t\t\t// Separate main model columns from joined columns\n\t\t\t\t\tconst mainModelFields: Record<string, any> = {};\n\t\t\t\t\tconst joinedModelFields: Record<string, Record<string, any>> = {};\n\n\t\t\t\t\t// Initialize joined model fields map\n\t\t\t\t\tfor (const [joinModel] of Object.entries(joinConfig)) {\n\t\t\t\t\t\tjoinedModelFields[getModelName(joinModel)] = {};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Distribute all columns - collect complete objects per model\n\t\t\t\t\tfor (const [key, value] of Object.entries(currentRow)) {\n\t\t\t\t\t\tconst keyStr = String(key);\n\t\t\t\t\t\tlet assigned = false;\n\n\t\t\t\t\t\t// Check if this is a joined column\n\t\t\t\t\t\tfor (const {\n\t\t\t\t\t\t\tjoinModel,\n\t\t\t\t\t\t\tfieldName,\n\t\t\t\t\t\t\tjoinModelRef,\n\t\t\t\t\t\t} of allSelectsStr) {\n\t\t\t\t\t\t\tif (keyStr === `_joined_${joinModelRef}_${fieldName}`) {\n\t\t\t\t\t\t\t\tjoinedModelFields[getModelName(joinModel)]![\n\t\t\t\t\t\t\t\t\tgetFieldName({\n\t\t\t\t\t\t\t\t\t\tmodel: joinModel,\n\t\t\t\t\t\t\t\t\t\tfield: fieldName,\n\t\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t] = value;\n\t\t\t\t\t\t\t\tassigned = true;\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (!assigned) {\n\t\t\t\t\t\t\tmainModelFields[key] = value;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tconst mainId = mainModelFields.id;\n\t\t\t\t\tif (!mainId) continue;\n\n\t\t\t\t\t// Initialize or get existing entry for this main model\n\t\t\t\t\tif (!groupedByMainId.has(mainId)) {\n\t\t\t\t\t\tconst entry: Record<string, any> = { ...mainModelFields };\n\n\t\t\t\t\t\t// Initialize joined models based on uniqueness\n\t\t\t\t\t\tfor (const [joinModel, joinAttr] of Object.entries(joinConfig)) {\n\t\t\t\t\t\t\tentry[getModelName(joinModel)] =\n\t\t\t\t\t\t\t\tjoinAttr.relation === \"one-to-one\" ? null : [];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tgroupedByMainId.set(mainId, entry);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst entry = groupedByMainId.get(mainId)!;\n\n\t\t\t\t\t// Add joined records to the entry\n\t\t\t\t\tfor (const [joinModel, joinAttr] of Object.entries(joinConfig)) {\n\t\t\t\t\t\tconst isUnique = joinAttr.relation === \"one-to-one\";\n\t\t\t\t\t\tconst limit = joinAttr.limit ?? 100;\n\n\t\t\t\t\t\tconst joinedObj = joinedModelFields[getModelName(joinModel)];\n\n\t\t\t\t\t\tconst hasData =\n\t\t\t\t\t\t\tjoinedObj &&\n\t\t\t\t\t\t\tObject.keys(joinedObj).length > 0 &&\n\t\t\t\t\t\t\tObject.values(joinedObj).some(\n\t\t\t\t\t\t\t\t(value) => value !== null && value !== undefined,\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\tif (isUnique) {\n\t\t\t\t\t\t\tentry[getModelName(joinModel)] = hasData ? joinedObj : null;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// For arrays, append if not already there (deduplicate by id) and respect limit\n\t\t\t\t\t\t\tconst joinModelName = getModelName(joinModel);\n\t\t\t\t\t\t\tif (Array.isArray(entry[joinModelName]) && hasData) {\n\t\t\t\t\t\t\t\t// Check if we've reached the limit before processing\n\t\t\t\t\t\t\t\tif (entry[joinModelName].length >= limit) {\n\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// Get the id field name using getFieldName to ensure correct transformation\n\t\t\t\t\t\t\t\tconst idFieldName = getFieldName({\n\t\t\t\t\t\t\t\t\tmodel: joinModel,\n\t\t\t\t\t\t\t\t\tfield: \"id\",\n\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t\tconst joinedId = joinedObj[idFieldName];\n\n\t\t\t\t\t\t\t\t// Only deduplicate if we have an id field\n\t\t\t\t\t\t\t\tif (joinedId) {\n\t\t\t\t\t\t\t\t\tconst exists = entry[joinModelName].some(\n\t\t\t\t\t\t\t\t\t\t(item: any) => item[idFieldName] === joinedId,\n\t\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t\t\tif (!exists && entry[joinModelName].length < limit) {\n\t\t\t\t\t\t\t\t\t\tentry[joinModelName].push(joinedObj);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t// If no id field, still add the object if it has data and limit not reached\n\t\t\t\t\t\t\t\t\tif (entry[joinModelName].length < limit) {\n\t\t\t\t\t\t\t\t\t\tentry[joinModelName].push(joinedObj);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlet result = Array.from(groupedByMainId.values());\n\n\t\t\t\t// Apply final limit to non-unique join arrays as a safety measure\n\t\t\t\tfor (const entry of result) {\n\t\t\t\t\tfor (const [joinModel, joinAttr] of Object.entries(joinConfig)) {\n\t\t\t\t\t\tif (joinAttr.relation !== \"one-to-one\") {\n\t\t\t\t\t\t\tconst joinModelName = getModelName(joinModel);\n\t\t\t\t\t\t\tif (Array.isArray(entry[joinModelName])) {\n\t\t\t\t\t\t\t\tconst limit = joinAttr.limit ?? 100;\n\t\t\t\t\t\t\t\tif (entry[joinModelName].length > limit) {\n\t\t\t\t\t\t\t\t\tentry[joinModelName] = entry[joinModelName].slice(0, limit);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\tasync create({ data, model }) {\n\t\t\t\t\tconst builder = db.insertInto(model).values(data);\n\t\t\t\t\tconst returned = await withReturning(data, builder, model, []);\n\t\t\t\t\treturn returned;\n\t\t\t\t},\n\t\t\t\tasync findOne({ model, where, select, join }) {\n\t\t\t\t\tconst { and, or } = convertWhereClause(model, where);\n\t\t\t\t\tlet query: any = db\n\t\t\t\t\t\t.selectFrom((eb) => {\n\t\t\t\t\t\t\tlet b = eb.selectFrom(model);\n\t\t\t\t\t\t\tif (and) {\n\t\t\t\t\t\t\t\tb = b.where((eb: any) =>\n\t\t\t\t\t\t\t\t\teb.and(and.map((expr: any) => expr(eb))),\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (or) {\n\t\t\t\t\t\t\t\tb = b.where((eb: any) =>\n\t\t\t\t\t\t\t\t\teb.or(or.map((expr: any) => expr(eb))),\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treturn b.selectAll().as(\"primary\");\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.selectAll(\"primary\");\n\n\t\t\t\t\tif (join) {\n\t\t\t\t\t\tfor (const [joinModel, joinAttr] of Object.entries(join)) {\n\t\t\t\t\t\t\tconst [_joinModelSchema, joinModelName] = joinModel.includes(\".\")\n\t\t\t\t\t\t\t\t? joinModel.split(\".\")\n\t\t\t\t\t\t\t\t: [undefined, joinModel];\n\n\t\t\t\t\t\t\tquery = query.leftJoin(\n\t\t\t\t\t\t\t\t`${joinModel} as join_${joinModelName}`,\n\t\t\t\t\t\t\t\t(join: any) =>\n\t\t\t\t\t\t\t\t\tjoin.onRef(\n\t\t\t\t\t\t\t\t\t\t`join_${joinModelName}.${joinAttr.on.to}`,\n\t\t\t\t\t\t\t\t\t\t\"=\",\n\t\t\t\t\t\t\t\t\t\t`primary.${joinAttr.on.from}`,\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tconst { allSelectsStr, allSelects } = selectAllJoins(join);\n\t\t\t\t\tquery = query.select(allSelects);\n\n\t\t\t\t\tconst res = await query.execute();\n\t\t\t\t\tif (!res || !Array.isArray(res) || res.length === 0) return null;\n\n\t\t\t\t\t// Get the first row from the result array\n\t\t\t\t\tconst row = res[0];\n\n\t\t\t\t\tif (join) {\n\t\t\t\t\t\tconst processedRows = processJoinedResults(\n\t\t\t\t\t\t\tres,\n\t\t\t\t\t\t\tjoin,\n\t\t\t\t\t\t\tallSelectsStr,\n\t\t\t\t\t\t);\n\n\t\t\t\t\t\treturn processedRows[0] as any;\n\t\t\t\t\t}\n\n\t\t\t\t\treturn row as any;\n\t\t\t\t},\n\t\t\t\tasync findMany({ model, where, limit, offset, sortBy, join }) {\n\t\t\t\t\tconst { and, or } = convertWhereClause(model, where);\n\t\t\t\t\tlet query: any = db\n\t\t\t\t\t\t.selectFrom((eb) => {\n\t\t\t\t\t\t\tlet b = eb.selectFrom(model);\n\n\t\t\t\t\t\t\tif (config?.type === \"mssql\") {\n\t\t\t\t\t\t\t\tif (offset !== undefined) {\n\t\t\t\t\t\t\t\t\tif (!sortBy) {\n\t\t\t\t\t\t\t\t\t\tb = b.orderBy(getFieldName({ model, field: \"id\" }));\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tb = b.offset(offset).fetch(limit || 100);\n\t\t\t\t\t\t\t\t} else if (limit !== undefined) {\n\t\t\t\t\t\t\t\t\tb = b.top(limit);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tif (limit !== undefined) {\n\t\t\t\t\t\t\t\t\tb = b.limit(limit);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif (offset !== undefined) {\n\t\t\t\t\t\t\t\t\tb = b.offset(offset);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (sortBy?.field) {\n\t\t\t\t\t\t\t\tb = b.orderBy(\n\t\t\t\t\t\t\t\t\t`${getFieldName({ model, field: sortBy.field })}`,\n\t\t\t\t\t\t\t\t\tsortBy.direction,\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (and) {\n\t\t\t\t\t\t\t\tb = b.where((eb: any) =>\n\t\t\t\t\t\t\t\t\teb.and(and.map((expr: any) => expr(eb))),\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tif (or) {\n\t\t\t\t\t\t\t\tb = b.where((eb: any) =>\n\t\t\t\t\t\t\t\t\teb.or(or.map((expr: any) => expr(eb))),\n\t\t\t\t\t\t\t\t);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\treturn b.selectAll().as(\"primary\");\n\t\t\t\t\t\t})\n\t\t\t\t\t\t.selectAll(\"primary\");\n\n\t\t\t\t\tif (join) {\n\t\t\t\t\t\tfor (const [joinModel, joinAttr] of Object.entries(join)) {\n\t\t\t\t\t\t\t// it's possible users provide a schema name in the model name (`<schema>.<model>`)\n\t\t\t\t\t\t\tconst [_joinModelSchema, joinModelName] = joinModel.includes(\".\")\n\t\t\t\t\t\t\t\t? joinModel.split(\".\")\n\t\t\t\t\t\t\t\t: [undefined, joinModel];\n\n\t\t\t\t\t\t\tquery = query.leftJoin(\n\t\t\t\t\t\t\t\t`${joinModel} as join_${joinModelName}`,\n\t\t\t\t\t\t\t\t(join: any) =>\n\t\t\t\t\t\t\t\t\tjoin.onRef(\n\t\t\t\t\t\t\t\t\t\t`join_${joinModelName}.${joinAttr.on.to}`,\n\t\t\t\t\t\t\t\t\t\t\"=\",\n\t\t\t\t\t\t\t\t\t\t`primary.${joinAttr.on.from}`,\n\t\t\t\t\t\t\t\t\t),\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tconst { allSelectsStr, allSelects } = selectAllJoins(join);\n\n\t\t\t\t\tquery = query.select(allSelects);\n\n\t\t\t\t\tif (sortBy?.field) {\n\t\t\t\t\t\tquery = query.orderBy(\n\t\t\t\t\t\t\t`${getFieldName({ model, field: sortBy.field })}`,\n\t\t\t\t\t\t\tsortBy.direction,\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst res = await query.execute();\n\n\t\t\t\t\tif (!res) return [];\n\t\t\t\t\tif (join) return processJoinedResults(res, join, allSelectsStr);\n\t\t\t\t\treturn res;\n\t\t\t\t},\n\t\t\t\tasync update({ model, where, update: values }) {\n\t\t\t\t\tconst { and, or } = convertWhereClause(model, where);\n\n\t\t\t\t\tlet query = db.updateTable(model).set(values as any);\n\t\t\t\t\tif (and) {\n\t\t\t\t\t\tquery = query.where((eb) => eb.and(and.map((expr) => expr(eb))));\n\t\t\t\t\t}\n\t\t\t\t\tif (or) {\n\t\t\t\t\t\tquery = query.where((eb) => eb.or(or.map((expr) => expr(eb))));\n\t\t\t\t\t}\n\t\t\t\t\treturn await withReturning(values as any, query, model, where);\n\t\t\t\t},\n\t\t\t\tasync updateMany({ model, where, update: values }) {\n\t\t\t\t\tconst { and, or } = convertWhereClause(model, where);\n\t\t\t\t\tlet query = db.updateTable(model).set(values as any);\n\t\t\t\t\tif (and) {\n\t\t\t\t\t\tquery = query.where((eb) => eb.and(and.map((expr) => expr(eb))));\n\t\t\t\t\t}\n\t\t\t\t\tif (or) {\n\t\t\t\t\t\tquery = query.where((eb) => eb.or(or.map((expr) => expr(eb))));\n\t\t\t\t\t}\n\t\t\t\t\tconst res = (await query.executeTakeFirst()).numUpdatedRows;\n\t\t\t\t\treturn res > Number.MAX_SAFE_INTEGER\n\t\t\t\t\t\t? Number.MAX_SAFE_INTEGER\n\t\t\t\t\t\t: Number(res);\n\t\t\t\t},\n\t\t\t\tasync count({ model, where }) {\n\t\t\t\t\tconst { and, or } = convertWhereClause(model, where);\n\t\t\t\t\tlet query = db\n\t\t\t\t\t\t.selectFrom(model)\n\t\t\t\t\t\t// a temporal solution for counting other than \"*\" - see more - https://www.sqlite.org/quirks.html#double_quoted_string_literals_are_accepted\n\t\t\t\t\t\t.select(db.fn.count(\"id\").as(\"count\"));\n\t\t\t\t\tif (and) {\n\t\t\t\t\t\tquery = query.where((eb) => eb.and(and.map((expr) => expr(eb))));\n\t\t\t\t\t}\n\t\t\t\t\tif (or) {\n\t\t\t\t\t\tquery = query.where((eb) => eb.or(or.map((expr) => expr(eb))));\n\t\t\t\t\t}\n\t\t\t\t\tconst res = await query.execute();\n\t\t\t\t\tif (typeof res[0]!.count === \"number\") {\n\t\t\t\t\t\treturn res[0]!.count;\n\t\t\t\t\t}\n\t\t\t\t\tif (typeof res[0]!.count === \"bigint\") {\n\t\t\t\t\t\treturn Number(res[0]!.count);\n\t\t\t\t\t}\n\t\t\t\t\treturn parseInt(res[0]!.count);\n\t\t\t\t},\n\t\t\t\tasync delete({ model, where }) {\n\t\t\t\t\tconst { and, or } = convertWhereClause(model, where);\n\t\t\t\t\tlet query = db.deleteFrom(model);\n\t\t\t\t\tif (and) {\n\t\t\t\t\t\tquery = query.where((eb) => eb.and(and.map((expr) => expr(eb))));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (or) {\n\t\t\t\t\t\tquery = query.where((eb) => eb.or(or.map((expr) => expr(eb))));\n\t\t\t\t\t}\n\t\t\t\t\tawait query.execute();\n\t\t\t\t},\n\t\t\t\tasync deleteMany({ model, where }) {\n\t\t\t\t\tconst { and, or } = convertWhereClause(model, where);\n\t\t\t\t\tlet query = db.deleteFrom(model);\n\t\t\t\t\tif (and) {\n\t\t\t\t\t\tquery = query.where((eb) => eb.and(and.map((expr) => expr(eb))));\n\t\t\t\t\t}\n\t\t\t\t\tif (or) {\n\t\t\t\t\t\tquery = query.where((eb) => eb.or(or.map((expr) => expr(eb))));\n\t\t\t\t\t}\n\t\t\t\t\tconst res = (await query.executeTakeFirst()).numDeletedRows;\n\t\t\t\t\treturn res > Number.MAX_SAFE_INTEGER\n\t\t\t\t\t\t? Number.MAX_SAFE_INTEGER\n\t\t\t\t\t\t: Number(res);\n\t\t\t\t},\n\t\t\t\toptions: config,\n\t\t\t};\n\t\t};\n\t};\n\tlet adapterOptions: AdapterFactoryOptions | null = null;\n\tadapterOptions = {\n\t\tconfig: {\n\t\t\tadapterId: \"kysely\",\n\t\t\tadapterName: \"Kysely Adapter\",\n\t\t\tusePlural: config?.usePlural,\n\t\t\tdebugLogs: config?.debugLogs,\n\t\t\tsupportsBooleans:\n\t\t\t\tconfig?.type === \"sqlite\" ||\n\t\t\t\tconfig?.type === \"mssql\" ||\n\t\t\t\tconfig?.type === \"mysql\" ||\n\t\t\t\t!config?.type\n\t\t\t\t\t? false\n\t\t\t\t\t: true,\n\t\t\tsupportsDates:\n\t\t\t\tconfig?.type === \"sqlite\" || config?.type === \"mssql\" || !config?.type\n\t\t\t\t\t? false\n\t\t\t\t\t: true,\n\t\t\tsupportsJSON:\n\t\t\t\tconfig?.type === \"postgres\"\n\t\t\t\t\t? true // even if there is JSON support, only pg supports passing direct json, all others must stringify\n\t\t\t\t\t: false,\n\t\t\tsupportsArrays: false, // Even if field supports JSON, we must pass stringified arrays to the database.\n\t\t\tsupportsUUIDs: config?.type === \"postgres\" ? true : false,\n\t\t\ttransaction: config?.transaction\n\t\t\t\t? (cb) =>\n\t\t\t\t\t\tdb.transaction().execute((trx) => {\n\t\t\t\t\t\t\tconst adapter = createAdapterFactory({\n\t\t\t\t\t\t\t\tconfig: adapterOptions!.config,\n\t\t\t\t\t\t\t\tadapter: createCustomAdapter(trx),\n\t\t\t\t\t\t\t})(lazyOptions!);\n\t\t\t\t\t\t\treturn cb(adapter);\n\t\t\t\t\t\t})\n\t\t\t\t: false,\n\t\t},\n\t\tadapter: createCustomAdapter(db),\n\t};\n\n\tconst adapter = createAdapterFactory(adapterOptions);\n\n\treturn (options: BetterAuthOptions): DBAdapter<BetterAuthOptions> => {\n\t\tlazyOptions = options;\n\t\treturn adapter(options);\n\t};\n};\n"],
  "mappings": "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",
  "names": ["lazyOptions: BetterAuthOptions | null", "allSelects: RawBuilder<unknown>[]", "allSelectsStr: {\n\t\t\t\t\tjoinModel: string;\n\t\t\t\t\tjoinModelRef: string;\n\t\t\t\t\tfieldName: string;\n\t\t\t\t}[]", "res: any", "db", "value: any", "field: string | any", "mainModelFields: Record<string, any>", "joinedModelFields: Record<string, Record<string, any>>", "entry: Record<string, any>", "entry", "query: any", "eb", "join", "adapterOptions: AdapterFactoryOptions | null"]
}
